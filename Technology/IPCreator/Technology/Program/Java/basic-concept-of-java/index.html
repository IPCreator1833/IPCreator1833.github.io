<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon.ico">
  <link rel="mask-icon" href="/img/apple-touch-icon.png" color="#222">
  <link rel="alternate" href="/atom.xml" title="生命之旅" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-corner-indicator.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: true,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},
    path: 'search.json',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Java is a good Coffee for ProgrammerResolve Problems from the views of Java designer , Compiler, CPU, Memery…  见过最多的，也最可悲的是—— 永远不相信自己所有的问题就出在自己从来都不肯耐心把最基础的东西弄清楚弄明白。[1]">
<meta name="keywords" content="Basic Concept">
<meta property="og:type" content="article">
<meta property="og:title" content="The Basic Concepts of Java">
<meta property="og:url" content="https://hazyman.com/Technology/IPCreator/Technology/Program/Java/basic-concept-of-java/index.html">
<meta property="og:site_name" content="生命之旅">
<meta property="og:description" content="Java is a good Coffee for ProgrammerResolve Problems from the views of Java designer , Compiler, CPU, Memery…  见过最多的，也最可悲的是—— 永远不相信自己所有的问题就出在自己从来都不肯耐心把最基础的东西弄清楚弄明白。[1]">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-02-22T00:34:12.533Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="The Basic Concepts of Java">
<meta name="twitter:description" content="Java is a good Coffee for ProgrammerResolve Problems from the views of Java designer , Compiler, CPU, Memery…  见过最多的，也最可悲的是—— 永远不相信自己所有的问题就出在自己从来都不肯耐心把最基础的东西弄清楚弄明白。[1]">

<link rel="canonical" href="https://hazyman.com/Technology/IPCreator/Technology/Program/Java/basic-concept-of-java/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>The Basic Concepts of Java | 生命之旅</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">生命之旅</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">常识、专业和价值。</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/IPCreator1833" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hazyman.com/Technology/IPCreator/Technology/Program/Java/basic-concept-of-java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/work-hard-life-easy.png">
      <meta itemprop="name" content="IPCreator">
      <meta itemprop="description" content="Life is a journey.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="生命之旅">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          The Basic Concepts of Java
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index">
                    <span itemprop="name">Technology</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/Technology/IPCreator/Technology/Program/Java/basic-concept-of-java/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Technology/IPCreator/Technology/Program/Java/basic-concept-of-java/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img alt data-src="http://ong8f1obl.bkt.clouddn.com/java.jpg"></p>
<blockquote>
<p>Java is a good Coffee for Programmer<br>Resolve Problems from the views of Java designer , Compiler, CPU, Memery…</p>
</blockquote>
<p>见过最多的，也最可悲的是—— 永远不相信自己所有的问题就出在自己从来都不肯耐心把最基础的东西弄清楚弄明白。<sup>[1]<sup></sup></sup></p>
<a id="more"></a>
<h2 id="On-job-Training-2"><a href="#On-job-Training-2" class="headerlink" title="On job Training[2]"></a>On job Training<sup>[2]<sup></sup></sup></h2><h3 id="启发编程思想，培养编程感觉"><a href="#启发编程思想，培养编程感觉" class="headerlink" title="启发编程思想，培养编程感觉"></a>启发编程思想，培养编程感觉</h3><p>用程序来解决生活中的实际问题</p>
<blockquote>
<p>How –&gt; Why</p>
</blockquote>
<h3 id="Java-virtual-machine"><a href="#Java-virtual-machine" class="headerlink" title="Java virtual machine"></a>Java virtual machine</h3><p>可运行Java字节码的假想计算机</p>
<p>javac：编译器，在javac命令中，可以使用通配符来指定一次编译多个源文件<br>java: 解析器，启动一个Jvm</p>
<p>javac 将java源程序翻译为jvm可执行代码——java字节码，这一编译过程同c/c++有些不同，当C编译器生成一个对象的代码时，该代码是为在某一特定硬件平台运行而产生的。因此，在编译过程中，编译程序通过查表将所有对符号的引用转换为特定的内存偏移量，以保证程序的运行。</p>
<p>java编译器却不将对变量和方法的引用编译为数值引用，也不确定程序执行过程中的内存布局，而是将这些符号引用信息保留在字节码中，由解析器在运行过程中创立内存布局，然后再通过查表来确定一个方法所在的地址，这样就有效保证了java的可移植性和安全性。</p>
<p><img alt data-src="http://onzc6nld3.bkt.clouddn.com/1.1.jpg"></p>
<p><img alt data-src="http://onzc6nld3.bkt.clouddn.com/1.1-.jpg"></p>
<p>运行jvm字节码的工作是由解析器来完成</p>
<p><img alt data-src="http://onzc6nld3.bkt.clouddn.com/1.22.jpg"></p>
<ol>
<li>代码的装入</li>
</ol>
<p>由class loader完成，其负责装入运行一个程序需要的所有代码，这也包括程序代码中的类所继承的类和被其调用的类。当类装载器装入一个类时，该类被放在自己的名字空间中。除了通过符号引用自己名字空间以外的类，类之间没有其他办法可以影响其他类。在本台计算机上的所有类都在同一地址空间内，而所有从外部引进的类，都有一个自己独立的名字空间。这使得本地类通过共享相同的名字空间获得较高的运行效率，同时又保证它们与从外部引进的类不会相互影响。</p>
<p>当装入了运行程序需要的所有类后，解析器便可确定整个可执行程序的内存布局。解析器为符号引用于特定的地址空间建立对应关系及查询表。通过在这一阶段确定代码的内存布局，java很好地解决了由超类改变而使子类崩溃的问题，同时也防止了代码对地址的非法访问。</p>
<ol start="2">
<li><p>代码的校验<br>被装入的代码由字节码校验器进行检查，校验器可发现操作数栈溢出、非法数据类型转化等多种错误。通过校验后，代码便开始执行。</p>
</li>
<li><p>代码的执行<br>Java字节码的执行有两种方式：<br>A、即时编译方式<br>  解析器先将字节码编译成机器码，然后再执行该机器码。<br>B、解析执行方式<br>   解析器通过每次解析并执行一小段代码来完成java字节码程序的所有操作。<br>通常采用的是第二种方法。由于jvm规格描述具有足够的灵活性，这使得将字节码翻译为机器代码的工作具有较高的效率，对于那些对运行速度要求较高的应用程序，解析器可将java字节码即时编译为机器码，从而很好地保证了java代码的可移植性和高性能。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Usage: java [-options] class [args...]</span><br><span class="line">           (to execute a <span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">   or  java [-options] -jar jarfile [args...]</span><br><span class="line">           (to execute a jar file)</span><br><span class="line">where options include:</span><br><span class="line">    -d32          use a <span class="number">32</span>-bit data model <span class="keyword">if</span> available</span><br><span class="line">    -d64          use a <span class="number">64</span>-bit data model <span class="keyword">if</span> available</span><br><span class="line">    -server       to select the <span class="string">"server"</span> VM</span><br><span class="line">                  The <span class="keyword">default</span> VM is server.</span><br><span class="line"></span><br><span class="line">    -cp &lt;<span class="class"><span class="keyword">class</span> <span class="title">search</span> <span class="title">path</span> <span class="title">of</span> <span class="title">directories</span> <span class="title">and</span> <span class="title">zip</span>/<span class="title">jar</span> <span class="title">files</span>&gt;</span></span><br><span class="line"><span class="class">    -<span class="title">classpath</span> &lt;<span class="title">class</span> <span class="title">search</span> <span class="title">path</span> <span class="title">of</span> <span class="title">directories</span> <span class="title">and</span> <span class="title">zip</span>/<span class="title">jar</span> <span class="title">files</span>&gt;</span></span><br><span class="line"><span class="class">                  <span class="title">A</span> </span>; separated list of directories, JAR archives,</span><br><span class="line">                  and ZIP archives to search <span class="keyword">for</span> <span class="class"><span class="keyword">class</span> <span class="title">files</span>.</span></span><br><span class="line"><span class="class">    -<span class="title">D</span>&lt;<span class="title">name</span>&gt;</span>=&lt;value&gt;</span><br><span class="line">                  set a system property</span><br><span class="line">    -verbose:[class|gc|jni]</span><br><span class="line">                  enable verbose output</span><br><span class="line">    -version      print product version and exit</span><br><span class="line">    -version:&lt;value&gt;</span><br><span class="line">                  Warning: <span class="keyword">this</span> feature is deprecated and will be removed</span><br><span class="line">                  in a future release.</span><br><span class="line">                  require the specified version to run</span><br><span class="line">    -showversion  print product version and <span class="keyword">continue</span></span><br><span class="line">    -jre-restrict-search | -no-jre-restrict-search</span><br><span class="line">                  Warning: <span class="keyword">this</span> feature is deprecated and will be removed</span><br><span class="line">                  in a future release.</span><br><span class="line">                  include/exclude user <span class="keyword">private</span> JREs in the version search</span><br><span class="line">    -? -help      print <span class="keyword">this</span> help message</span><br><span class="line">    -X            print help on non-standard options</span><br><span class="line">    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  enable assertions with specified granularity</span><br><span class="line">    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  disable assertions with specified granularity</span><br><span class="line">    -esa | -enablesystemassertions</span><br><span class="line">                  enable system assertions</span><br><span class="line">    -dsa | -disablesystemassertions</span><br><span class="line">                  disable system assertions</span><br><span class="line">    -agentlib:&lt;libname&gt;[=&lt;options&gt;]</span><br><span class="line">                  load <span class="keyword">native</span> agent library &lt;libname&gt;, e.g. -agentlib:hprof</span><br><span class="line">                  see also, -agentlib:jdwp=help and -agentlib:hprof=help</span><br><span class="line">    -agentpath:&lt;pathname&gt;[=&lt;options&gt;]</span><br><span class="line">                  load <span class="keyword">native</span> agent library by full pathname</span><br><span class="line">    -javaagent:&lt;jarpath&gt;[=&lt;options&gt;]</span><br><span class="line">                  load Java programming language agent, see java.lang.instrument</span><br><span class="line">    -splash:&lt;imagepath&gt;</span><br><span class="line">                  show splash screen with specified image</span><br><span class="line">See http:<span class="comment">//www.oracle.com/technetwork/java/javase/documentation/index.html for more details.</span></span><br></pre></td></tr></table></figure>
<h3 id="Java-Garbage-Collector"><a href="#Java-Garbage-Collector" class="headerlink" title="Java Garbage Collector"></a>Java Garbage Collector</h3><p>Java类的实例对象和数组所需的存储空间是在堆上分配的，解析器具体承担为类实例分配空间的工作。解析器在为一个实例对象分配完存储空间后，便开始记录对该实例对象所占用的内存区域的使用。一旦对象使用完毕，便将其回收到垃圾箱中。</p>
<p>在java语言中，除了new语句外没有其他方法为一个对象申请和释放内存。对内存进行释放和回收的工作是由java运行体统承担的，这允许java运行系统的设计者自己决定碎片回收的方法。</p>
<p>在java程序运行过程中，一个垃圾回收器会不定时地被唤起检查是否有不再被使用的对象，并释放它们占用的内存空间，垃圾回收器不由程序员控制，也无规律可循，并不会一产生垃圾，它就被唤起，甚至有可能到程序终止，它都没有启动的机会。</p>
<p>不同的jvm采用不同的回收策略，一般有两种比较常用：</p>
<ol>
<li><p>复制式回收策略<br>先将正在运行中的程序暂停，然后把正在被使用的所有对象从他们所在的堆内存里复制到另一块堆内存，那些不再被使用的对象所占据的内存空间就被释放掉。</p>
</li>
<li><p>自省式回收策略<br>检测所有正在使用的对象，并为它们标注，完成这项工作后再将所有不再被使用的对象所占据的内存空间一次释放。</p>
</li>
</ol>
<p>Java把内存划分成两种，一种是栈内存，另一种是堆内存。</p>
<p>在方法中定义的一些基本类型的变量和对象的引用变量都是在方法的栈内存中分配，当在一段代码块（也就是一对花括号{}之间）定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。</p>
<p>堆内存用来存放由new创建的对象和数组，在堆中分配的内存，由java虚拟机的gc来管理，在堆中产生一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象，引用变量就相当于是为数组或对象起的一个名称（叫代号也行）。引用变量时普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放，而数组和对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它时，才会变为垃圾，不再被使用，但仍然占据内存空间不放，在随后一个不确定的时间呗GC释放，这也是java比较占内存的原因。</p>
<blockquote>
<p>Java内部还是有指针的，只是把指针的概念对用户隐藏起来了。</p>
</blockquote>
<h3 id="Pitfall"><a href="#Pitfall" class="headerlink" title="Pitfall"></a>Pitfall</h3><h4 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h4><p>与java有关的环境变量对空格和中文是非常敏感的<br>java -verbose，显示JVM详细的加载过程</p>
<p>环境变量：OS中定义的变量，可供操作系统上所有应用程序使用<br>Windows：在cmd中，用set命令查看，是用户和系统环境变量的总和<br>path：设置供OS去寻找和执行应用程序的路径，当前目录–&gt;Path设置的目录，以最先找到的为准<br>Windows，用;分隔，Linux用:分隔<br>Windows，用%variable%取值，Linux用$variable取值</p>
<p><img alt data-src="http://onzc6nld3.bkt.clouddn.com/1.2.jpg"></p>
<p>classpath：jvm按照classpath环境变量指定的目录顺序去查找这个类，以最先找到的为准，注意：与linux类似，jvm只会到classpath指定的目录中去寻找类，而不会自动在当前目录中去寻找</p>
<p>.代表java虚拟机运行时的当前工作目录</p>
<p>系统Windows，用;分隔，Linux用:分隔</p>
<h3 id="Java-Class"><a href="#Java-Class" class="headerlink" title="Java Class"></a>Java Class</h3><p>Java中的程序必须以类的形式存在，一个类要被解析器直接启动运行，必须要有main方法，jvm运行时，首先会调用main方法，main方法的写法是固定的，public static void main(String[] args)</p>
<p>如果在class前没有public修饰符，命名可以是一切合法的名称，而带有public，必须与源文件同名</p>
<p>xxx.java中可以定义多个class，javac之后，产生多个class文件，能直接用java启动的只有那个含有main方法的类</p>
<h3 id="Java-Grammar"><a href="#Java-Grammar" class="headerlink" title="Java Grammar"></a>Java Grammar</h3><p>java是严格区分大小写的<br>java所有的程序代码分为结构定义和功能执行语句，一条语句可以写在若干行上，功能执行语句的最后必须用;结束。</p>
<p>java程序中一句连续的字符串不能分开在两行中写，如果太长，可以分成两个字符串，再用+号连起来，然后在+处断行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单行注释//</span><br><span class="line">多行注释/*   */</span><br><span class="line">文档注释/**  */</span><br></pre></td></tr></table></figure>
<p>多行注释可以嵌套单行注释，但是不能嵌套多行注释</p>
<p>标识符，不能以数字开头，不能是java中的保留关键字</p>
<blockquote>
<p>正确的路有一条，错误的路千万条，何苦要去记住哪些错误的路呢？永远用字幕开头，尽量不要包含其他的符号。</p>
</blockquote>
<p>注意：Java中没有sizeof、goto、const这些关键字，但不能用goto、const作为变量名。</p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><ol>
<li><p>整型常量<br>十六进制0x开头<br>八进制0开头<br>长整型l结尾</p>
</li>
<li><p>浮点数常量<br>单精度f/F结尾<br>双精度d/D结尾<br>小数常量的默认类型为double<br>float类型后面一定要加f/F</p>
</li>
<li><p>布尔常量<br>true和false</p>
</li>
<li><p>字符常量<br>java中的字符占用两个字节，是用unicode码表示的。<br>单引号<br>还可以用unicode码值来表示对应的字符</p>
</li>
<li><p>字符串常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;</span><br><span class="line">\反斜杠转义字符</span><br><span class="line">\\</span><br><span class="line">\r回车</span><br><span class="line">\n换行</span><br><span class="line">\t制表符</span><br><span class="line">\b退格键</span><br></pre></td></tr></table></figure>
</li>
<li><p>null常量<br>表示引用的对象为空</p>
</li>
</ol>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>用一个变量定义一块内存以后，程序就可以用变量名代表这块内存中的数据。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,y;</span><br><span class="line">y=x+<span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<p>先取出x代表的那块内存单元的数，加上3，然后把结果放到y所在的那块内存单元。</p>
<p>Java基本变量类型，都是小写：<br>整数：byte,,short,int,long<br>浮点：float，double<br>字符：char （与c语言不同，java的字符占两个字节，是unicode编码的）<br>布尔：boolean</p>
<p>注意：java语言中没有无符号的数据类型</p>
<p>引用类型：类、接口、数组</p>
<p>计算机里只有数值，当你在内存中看到一个数值时，这个数值可能代表各种意义，比如你看到的文字、图像和听到的声音等都是使用数字形式来表示的，生活中的数值也可以代表其他意义，如1234可以代表密码、存款额、电报信息等，根据上下线索，我们能够知道这些数值代表的意义。其实字符也是一个数字，当要给一个字符变量赋值时，就可以直接用整数，如97对应字符’a’，使用char ch=97 将字符a赋值给变量ch，如果我们要将字符x赋值给一个char变量，该填一个怎样的整数呢？显然，不太容易记住每个字符所对应的数字，所以，我们就用单引号加上这个字符本身来表示那个字符对应的数字，如char ch=’x’。</p>
<p>变量的作用域（scope）<br>在c/c++/java里，一对花括号中间的部分就是一个代码块，代码块决定其中定义的变量的作用域。</p>
<p>局部变量在进行取值操作前必须被初始化或进行过赋值操作，否则会出现编译错误</p>
<h4 id="基本数据类型之间的转换"><a href="#基本数据类型之间的转换" class="headerlink" title="基本数据类型之间的转换"></a>基本数据类型之间的转换</h4><ol>
<li><p>自动（隐式）<br>同时满足两个条件：<br>A、两种类型彼此兼容；<br>B、目标类型的取值范围要大于源类型。</p>
</li>
<li><p>强制（显式）<br>类型不兼容或者取值范围要小于源类型</p>
</li>
</ol>
<p>字符串可以使用+同其他的数据类型相连形成一个新的字符串(将其他数据类型值默认转化为十进制)</p>
<p>源和目标分别是两个大小不同的内存块（由变量及数据的类型来决定），将源数据赋值给目标内存的过程，就是用目标内存块去套取源内存中的数据，能套多少算多少。</p>
<ol start="3">
<li>表达式的数据类型自动提升</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">5</span>;</span><br><span class="line">b = b-<span class="number">2</span>;</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>
<p>在表达式取值时，变量值被自动提升为int类型</p>
<blockquote>
<p>b = (byte)(b-2)</p>
</blockquote>
<p>java定义了若干适用于表达式的类型提升规则<br>A、所有的byte类型、short类型和char类型的值将被提升到int类型；<br>B、如果一个操作数是long类型，计算结果就是long类型<br>C、如果一个操作数是float类型，计算结果就是float类型<br>D、如果一个操作数是double类型，计算结果就是double类型</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><img alt data-src="http://onzc6nld3.bkt.clouddn.com/2.4.jpg"></p>
<p>方法要接收调用程序传递进来的参数，必须为每个传递进来的参数定义一个变量。如果方法没有return语句，编译时，系统会自动在方法的最后添加一个return。</p>
<p>void：不知道是什么类型，可定义方法时又非要填写一个返回值类型，就用它充数吧。</p>
<h4 id="方法的重载-overload"><a href="#方法的重载-overload" class="headerlink" title="方法的重载(overload)"></a>方法的重载(overload)</h4><p>java的编译器很聪明，能够根据调用方法时所传递的参数的个数和类型选择相应的方法，重载方法的参数列表必须不同，要么是参数的个数不同，要么是参数的类型不同。重载方法的返回值类型可以相同，也可以不同。</p>
<blockquote>
<p>如果两个方法的参数类型和个数完全一样，返回值类型不同，行不行？如果你是java的设计者，而且你的用户在程序里编写了这样的两个方法，在调用时，你能根据他所传递的参数来为他选择到底该用哪个吗？没有办法吧！那就是不能这样做。学编程不需要死记硬背，靠的是动脑筋来思考，这样的学习才能做到举一反三、触类旁通。</p>
</blockquote>
<h3 id="Java中的运算符"><a href="#Java中的运算符" class="headerlink" title="Java中的运算符"></a>Java中的运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“+”除字符串相加功能外，还能降字符串与其他的数据类型相连成一个新的字符串，条件是表达式中至少有一个字符串，如&quot;x&quot;+123的结果是&quot;x123&quot;</span><br><span class="line">如果对负数取模，可以把模数符号忽略不计，如5%(-2)=1，但是被模数是负数就另当别论了如(-5)%(-2)=-1</span><br><span class="line">/，整数除和小数除是有区别的，整数之间做除法，只保留整数部分而舍弃小数部分。3510/1000*1000=3000</span><br></pre></td></tr></table></figure>
<p>为了避免将比较运算符==误写成=，有经验的程序员干脆写成if(3==x)，将常量放在==前面，这样万一写错，编译器就会报错。</p>
<p><strong>逻辑运算符</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp; 或者|无论任何情况，&amp;两边的表达式都会参与计算</span><br><span class="line">&amp;&amp; 或者||当左边为false时，则将不会计算其右边的表达式</span><br></pre></td></tr></table></figure></p>
<p>XOR异或，只有当^连接的两个布尔表达式的值不相同时，该组合才返回true值。</p>
<p><strong>移位运算符</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;左移</span><br><span class="line">&gt;&gt;右移</span><br><span class="line">&gt;&gt;&gt;无符号右移</span><br></pre></td></tr></table></figure></p>
<p>右移时，如果最高位是0，左边移空的高位就填入0<br>如果最高位是1，左边移空的高位就填入1<br>无符号右移，不管高位是0还是1，左边移空的高位都填入0</p>
<p>移位运算符适用数据类型有byte、short、char、int、long</p>
<ol>
<li>对低于int类型的操作数将先自动转换为int类型再移位；</li>
<li>对于int类型整数移位a&gt;&gt;b，系统先将b对32取模，得到的结果才是真正移位的位数。</li>
<li>对于long类型整数移位时a&gt;&gt;b，则是先将移位位数对64取模。</li>
</ol>
<p>移位能为我们实现整数除以或乘以2的n次方的效果，如x&gt;&gt;1的结果和x/2的结果是一样的，x&lt;&lt;2和x*4的结果也是一样的。一个数左移n位，就等于这个数乘以2的n次方，一个数右移n位，就等于这个数除以2的n次方。</p>
<blockquote>
<p>注意：移位不会改变变量本身的值</p>
</blockquote>
<p>经验分享：不要在一行中编写太复杂的表达式，也就是不要在一行中进行太多的运算，除可读性差之外，还极容易出错。多用括号分成多条语句，括号的优先级是最高的。</p>
<h3 id="程序的流程控制"><a href="#程序的流程控制" class="headerlink" title="程序的流程控制"></a>程序的流程控制</h3><p>结构化程序设计角度：</p>
<ol>
<li>顺序</li>
<li>选择</li>
<li>循环</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于if x then y，还有一种更简洁的写法</span><br><span class="line">变量 = 布尔表达式?语句1:语句2</span><br></pre></td></tr></table></figure>
<p>求绝对值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y= x&gt;0?x:-x</span><br></pre></td></tr></table></figure></p>
<p>在java中，if和elseif括号中的表达式的结果必须是布尔型的，这一点和c/c++不一样</p>
<p>switch语句判断条件可以接受byte,short,int,char类型，不接受其它类型<br>case是一旦碰到第一次匹配，如果没有break，就会继续执行。</p>
<p>注意while表达式的括号后一定不要加;</p>
<p>do while语句的结尾处多了一个分号;</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是多个相同类型数据的组合，实现对这些数据的统一管理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int [] x = new int[100];</span><br><span class="line">int x[] = new int[100];</span><br></pre></td></tr></table></figure></p>
<p><img alt data-src="http://onzc6nld3.bkt.clouddn.com/2.14.jpg"></p>
<p>数组的静态初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = &#123;1,2,3,4&#125;;</span><br><span class="line">int a[] = new int[]&#123;3,4,5&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意：在java语言中声明数组时，无论用何种方式定义数组，都不能指定其长度。</p>
<p>多维数组，在java中并没有真正的多维数组，只有数组的数组，虽然在应用上很像C语言中的多维数组，但还是有区别的。在C语言中定义一个二维数组，必须是一个x*y二维矩阵块，类似我们通常所见到的棋盘。</p>
<p>Java中多维数组不一定是规则矩阵形式</p>
<p><img alt data-src="http://onzc6nld3.bkt.clouddn.com/2.18.jpg"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int [][] xx = &#123;&#123;3,2,7&#125;,&#123;1,5&#125;,&#123;6&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>与一维数组一样，在声明多维数组时不能指定其长度。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>什么是面向对象，这是一个相对概念，是相对面向过程而言的。<br>要理解什么是幸福，要先理解什么是痛苦一样的道理。</p>
<h3 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h3><p>Windows窗口–&gt;结构体<br>HideWindow、MoveWindow，接收参数<br>谓语与宾语的关系，程序的重心集中在方法（谓语）上</p>
<h3 id="面向对象-1"><a href="#面向对象-1" class="headerlink" title="面向对象"></a>面向对象</h3><p>Windows窗口，主体，有属性，<br>有动作（方法，Hide,Move…）<br>主语与谓语的关系，程序的重点集中在主体/对象（主语）上</p>
<p>封装性，用类封装了数据和方法<br>真正能体现面向对象的强大优势的地方，是在面向对象的继承与多态性方面<br>封装性是面向对象的根源和最根本的属性</p>
<p>封装：Encapsulation<br>继承：Inheritance<br>多态：Polymorphism</p>
<p>面向对象的编程思想力图使在计算机语言中对事物的描述与现实世界中该事物的本来面目尽可能地一致，类和对象就是面向对象方法的核心概念。类时对某一类事物的描述，是抽象的、概念上的定义，对象是实际存在的该类事物的个体，因而也成实例（Instance）。</p>
<p>面向对象程序设计的重点是类的设计。</p>
<p>类的属性：类的成员变量<br>类的方法：类的成员方法<br>一个类中的方法可以直接访问同类中的任何成员（包括成员变量和成员方法）</p>
<p>注意：方法中的变量若与类成员变量同名，则该方法中对这个变量名的访问时局部变量而非成员变量。</p>
<p>对象的引用句柄是在栈中分配的一个变量，对象本身是在堆中分配的，原理同之前讲过的数组一样。</p>
<p>当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值，除了基本数据类型之外的变量类型都是引用类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>、<span class="keyword">short</span>、<span class="keyword">int</span>： <span class="number">0</span></span><br><span class="line"><span class="keyword">long</span>:<span class="number">0L</span></span><br><span class="line"><span class="keyword">float</span>:<span class="number">0.0F</span></span><br><span class="line"><span class="keyword">double</span>:<span class="number">0.0</span>D</span><br><span class="line"><span class="keyword">char</span>：<span class="string">'\u0000'</span>（表示为空）</span><br><span class="line"><span class="keyword">boolean</span>：<span class="keyword">false</span></span><br><span class="line">All reference type：<span class="keyword">null</span></span><br></pre></td></tr></table></figure></p>
<h3 id="对象的比较"><a href="#对象的比较" class="headerlink" title="对象的比较"></a>对象的比较</h3><p>==用于比较两个变量的值是否相等<br>equals()方法用于比较两个对象的内容是否一致</p>
<p>equls方法是String类的一个成员方法，用于比较两个引用变量所指向的对象的内容是否相等，就像比较两个人的长相是否一样。</p>
<h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p>创建完对象，在调用该对象的方法时，也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = new Person();</span><br><span class="line">p1.show();</span><br><span class="line"></span><br><span class="line">// 这句代码执行完，这个对象也就变成了垃圾</span><br><span class="line">new Person().show();</span><br></pre></td></tr></table></figure>
<p>使用匿名对象的两种情况：<br>A、如果对一个对象只需要进行一次方法调用<br>B、将匿名对象作为实参传递给一个方法调用</p>
<h3 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h3><p>如果外面的程序可以随意修改一个类的成员变量，会造成不可预料的程序错误，就像一个人的身高，不能被外部随意修改，只能通过各种摄取营养的方法去修改这个属性。</p>
<p>为了实现良好的封装性，通常将类的成员变量声明为private，再通过public的方法来对这个变量进行访问。</p>
<p>一个类通常就是一个小的模块，模块设计追求强内聚（许多功能尽量在类的内部独立完成，不让外面干预），弱耦合（提供给外部尽量少的方法调用）。</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ol>
<li>它具有与类相同的名称</li>
<li>它不含返回值</li>
<li>它不能在方法中用return语句返回一个值</li>
</ol>
<p>构造方法在程序设计中非常有用，它可以为类的成员变量进行初始化工作。<br>每一个人一出生就必须先洗澡。</p>
<p>注意：在构造方法里不含返回值的概念是不同于void的，对于public void这样的写法就不再是构造方法，而变成了普通方法。</p>
<p>构造方法的重载<br>new 类名(参数列表)</p>
<p>在执行构造方法中的代码之前，进行属性的显式初始化，也就是执行在定义成员变量时就对其进行赋值的语句。</p>
<p>在java的每个类里都至少有一个构造方法，如果没有定义，系统会自动为这个类产生一个默认的构造方法，没有参数，方法体中也没有任何代码，即什么也不做。</p>
<p>一旦定义了构造方法，系统就不再产生默认的构造方法。</p>
<p>经验：只要定义有参数的构造方法，都最好再定义一个无参数的构造方法。构造方法一般都是public的，因为它们在对象产生时，会被系统自动调用。</p>
<p>每个成员方法内部，都有一个this引用变量，指向调用这个方法的对象。<br><img alt data-src="http://onzc6nld3.bkt.clouddn.com/3.14.jpg"></p>
<blockquote>
<p>对于一个方法来说，只要是对象，它就可以调用，它根本就不区分是不是自己所属的那个对象。</p>
</blockquote>
<p>this应用场景：<br>A、想通过构造方法将外部传入的参数赋值给类成员变量，构造方法的形式参数名称与类的成员变量名相同；</p>
<p>B、假设有一个容器类和一个部件类，在容器类的某个方法中要创建部件类的实例对象，而部件类的构造方法要接收一个代表其所在容器的参数。</p>
<p>C、我们可以在一个构造方法里调用其他重载的构造方法，不是用构造方法名，而是用this（参数列表）的形式，根据其中的参数列表，选择相应的构造方法。</p>
<h3 id="GC有关的知识"><a href="#GC有关的知识" class="headerlink" title="GC有关的知识"></a>GC有关的知识</h3><blockquote>
<p>皮之不存毛将焉附，如果对象都不存在，又怎么能够调用它的方法，无论是构造方法被调用，还是析构方法被调用，对象都在内存中存在。</p>
</blockquote>
<p>Java的finalize()方法的作用类似c++中的析构方法，finalize()方法是在对象被当成垃圾从内存中释放前调用，而不是在对象变成垃圾前调用，垃圾回收器的启用不由程序员控制，业务规律可循，并不会一产生垃圾，它就被唤起，甚至有可能到程序终止，它都没有启动的机会。</p>
<p>System.gc()，强制启动垃圾回收器来回收垃圾。</p>
<p><img alt data-src="http://onzc6nld3.bkt.clouddn.com/3.15.jpg"></p>
<blockquote>
<p>读代码时，不是专盯代码本身，而是要看内存状态。</p>
</blockquote>
<h3 id="方法的参数传递"><a href="#方法的参数传递" class="headerlink" title="方法的参数传递"></a>方法的参数传递</h3><h4 id="基本数据类型的参数传递"><a href="#基本数据类型的参数传递" class="headerlink" title="基本数据类型的参数传递"></a>基本数据类型的参数传递</h4><p>基本类型的变量作为实参传递，并不能改变这个变量的值。<br><img alt data-src="http://onzc6nld3.bkt.clouddn.com/3.16.jpg"></p>
<h4 id="引用数据类型的参数传递"><a href="#引用数据类型的参数传递" class="headerlink" title="引用数据类型的参数传递"></a>引用数据类型的参数传递</h4><p>一个对象可以有多个句柄（名称/引用）<br><img alt data-src="http://onzc6nld3.bkt.clouddn.com/3.17.jpg"></p>
<blockquote>
<p>Java语言在给被调用方法的参数赋值时，只采用传值的方式。所以，基本类型数据传递的是该数据的值本身，引用类型数据传递的也是这个变量的值本身，即对象的引用（句柄），而非对象本身，通过方法调用，可以改变对象的内容，但是对象的引用是不能改变的。对于数组，也属于引用类型。</p>
</blockquote>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><h4 id="static-变量"><a href="#static-变量" class="headerlink" title="static 变量"></a>static 变量</h4><p>有时候，我们希望无论是否产生了对象，或无论产生了多少对象的情况下，某些特定的数据在内存空间里只有一份，例如所有的中国人都有国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。</p>
<p>静态变量在某种程度上与其他语言的全局变量相类似，如果不是私有的就可以在类的外部进行访问，此时不需要产生类的实例对象，只需要类名就可以引用。对于静态成员变量，我们叫类属性(class attributes)</p>
<p>用static标识符修饰的变量，它们在类被载入时创建，只要类存在，static变量就存在。</p>
<h4 id="static-方法"><a href="#static-方法" class="headerlink" title="static 方法"></a>static 方法</h4><p>对于静态成员方法，我们叫类方法(class method)，采用static关键字说明类的属性和方法不属于类的某个实例对象。</p>
<p>注意：</p>
<ol>
<li>在静态方法里只能直接调用同类中其他的静态成员（包括变量和方法），而不能直接访问类中的非静态成员。这是因为，对于非静态的方法和变量，需要先创建类的实例对象后才可使用。</li>
<li>静态方法不能以任何方式引用this和super关键字，道理同1</li>
<li>main()方法是静态的，因此jvm在执行main方法时不创建main方法所在的类的实例对象，因而在main方法中，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。</li>
</ol>
<h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p>static block，当类被载入时，静态代码块被执行，且只被执行一次，静态块经常用来进行类属性的初始化。尽管产生了类的多个实例对象，但其中的静态代码块只被执行一次。</p>
<p>当一个程序用到了其他的类，才会去装载那个类。</p>
<blockquote>
<p>类是在第一次被使用的时候才被装载，而不是在程序启动时就装载程序中所有可能要用到的类。</p>
</blockquote>
<h4 id="单态设计模式"><a href="#单态设计模式" class="headerlink" title="单态设计模式"></a>单态设计模式</h4><p>设计模式是在大量的实践总结和理论化之后优选的代码结构、编程风格以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免得自己再去思考和摸索。</p>
<p>了解和掌握设计模式，这也是java开发者提高自身素质的一个很好选择。</p>
<p>单态设计模式：在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。</p>
<ol>
<li>将类的构造方法的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类的内部仍可以产生该类的对象。</li>
</ol>
<h4 id="理解main方法的语法"><a href="#理解main方法的语法" class="headerlink" title="理解main方法的语法"></a>理解main方法的语法</h4><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>在一个类内部定义类，这就是嵌套类（nested classes），也叫内部类。<br>嵌套类可以直接访问嵌套它的类的成员，包括private成员，但是嵌套类的成员却不能被嵌套它的类直接访问。</p>
<p>在类中直接定义的嵌套类的使用范围，仅限于这个类的内部，A类中定义了一个B类，那么B为A所知，却不被A的外面所知。内部类可以声明为private或protected。</p>
<p><img alt data-src="http://onzc6nld3.bkt.clouddn.com/3.21.jpg"></p>
<p>在内部类对象保存了一个对外部类对象的引用，当内部类的成员方法中访问某一变量时，如果在该方法和内部类中都没有定义过这个变量，调用就会被传递给内部类中保存的那个外部类对象的引用，通过那个外部类对象的引用去调用这个变量，在内部类中调用外部类的方法也是一样的道理。</p>
<p>应用场景：<br>当一个类中的程序代码要用到另一个类的实例对象，而另一个类中的程序代码又要访问第一个类中的成员，将另一个类做成第一个类的内部类，程序代码就要容易编写得多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> out_i = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">		in.display();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"display out_i = "</span> + out_i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用static修饰一个内部类，这个类就相当于是一个外部定义的类。<br>非static内部类中，成员是不能声明为static的。</p>
<p><img alt data-src="http://onzc6nld3.bkt.clouddn.com/3.22-0.jpg"><br><img alt data-src="http://onzc6nld3.bkt.clouddn.com/3.22-1.jpg"></p>
<p>内部类也可以通过创建对象从外部类之外被调用，只要将内部类声明为public即可。</p>
<p>内部类Inner被声明为public，在外部就可以创建其外部类Outer的实例对象，再通过Outer类的实例对象创建Inner类的实例对象，就可以使用Inner类的实例对象来调用内部类Inner中的方法了。</p>
<p>嵌套类也可以在程序块的范围内定义。如，在方法中，或甚至在for循环体内部等。</p>
<p>在方法中定义的内部类只能访问方法中的final类型的局部变量，因为用final定义的局部变量相当于是一个常量，它的生命周期超出方法运行的生命周期。</p>
<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>关键字：extends</p>
<ol>
<li>java只支持单继承，不允许多重继承，即：一个子类只能有一个父类</li>
<li>一个类可以被多个类继承</li>
<li>可以有多层继承</li>
<li>子类继承父类所有的成员变量和成员方法，但不继承父类的构造方法。在子类的构造方法中可使用语句super(参数列表)调用父类的构造方法。</li>
<li>如果子类的构造方法中没有显式地调用父类的构造方法，也没有使用this关键字调用重载的其它构造方法，则在产生子类的实例对象时，系统默认调用父类无参数的构造方法。</li>
<li>如果子类构造方法中没有显式地调用父类构造方法，而父类中又没有无参数的构造方法，则编译出错。经验：我们在定义类时，只要定义了有参数的构造方法，通常都还需要定义一个无参数的构造方法。</li>
</ol>
<h3 id="子类对象实例化过程"><a href="#子类对象实例化过程" class="headerlink" title="子类对象实例化过程"></a>子类对象实例化过程</h3><ol>
<li>分配成员变量的存储空间并进行默认的初始化；</li>
<li>绑定构造方法参数，就是new Class(实际参数列表)中所传递进的参数赋值给构造方法中的形式参数变量；</li>
<li>如有this()调用，则调用相应的重载构造方法，被调用的重载构造方法的执行流程结束后，回到当前构造方法，当前构造方法直接跳转到步骤6执行；</li>
<li>显式或隐式追溯调用父类的构造方法（一直到Object类为止，Object是所有java类的最顶层父类），父类的构造方法又从步骤2开始对父类执行这些流程，父类的构造方法的执行流程结束后，回到当前构造方法，当前构造方法继续往下执行。</li>
<li>进行实例变量的显式初始化操作，也就是执行在定义成员变量时就对其进行赋值的语句。</li>
<li>执行当前构造方法的方法体中的程序代码。</li>
</ol>
<p>注意：this()方法调用语句与this.school=school的区别，前者指调用其他的构造方法，后者是一个普通的赋值语句。</p>
<p>为什么？</p>
<ol>
<li>为什么super(…)和this(…)调用语句不能同时在一个构造方法中出现？</li>
<li>为什么super(…)或this(…)调用语句只能作为构造方法的第一句出现？</li>
</ol>
<p><img alt data-src="http://onzc6nld3.bkt.clouddn.com/4.1.jpg"></p>
<h3 id="覆盖父类的方法"><a href="#覆盖父类的方法" class="headerlink" title="覆盖父类的方法"></a>覆盖父类的方法</h3><p>覆盖方法必须和被覆盖方法具有相同的方法名称、参数列表和返回值类型<br>覆盖方法时，不能使用比父类中被覆盖的方法更严格的访问权限，如父类的方法时public，子类的方法就不能是private。</p>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ol>
<li>在java中声明类、属性和方法时，可使用关键字final来修饰。</li>
<li>final标记的类不能被继承。</li>
<li>final标记的方法不能被子类重写；</li>
<li>final标记的变量（成员变量或局部变量）即成为常量（这个常量也只能在这个类的内部使用，不能在类的外部直接使用，当用public static final共同标记常量时，这个常量就成了全局的常量，并且只能在定义时赋值，java中的全局常量也放在一个类中定义），只能赋值一次。final标记的成员变量必须在声明的同时或在该类的构造方法中显式赋值，然后才能使用。</li>
<li>方法中定义的内置类只能访问该方法内的final类型的局部变量，用final定义的局部变量相当于是一个常量，它的生命周期超出方法运行的生命周期。将一个形参定义成final也是可以的，这就限定了我们在方法中修改形式参数的值。</li>
</ol>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>Java中可以定义一些不含方法体的方法，它的方法体的实现交给该类的子类根据自己的情况去实现，这样的方法就是抽象方法，包含抽象方法的类就叫抽象类，一个抽象类中可以有一个或多个抽象方法。任何带有抽象方法的类都必须声明为抽象类。</p>
<p>修饰符：abstract<br>抽象类不能被实例化<br>抽象方法只需声明，而不需实现。</p>
<p>抽象类的子类必须覆盖所有的抽象方法后才能被实例化，否则这个子类还是个抽象类。</p>
<p>abstract 返回值类型 抽象方法(参数列表)</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>如果一个抽象类中的所有方法都是抽象的，就可以将这个类用另外一种方式来定义，也就是接口定义。</p>
<p>接口是抽象方法和常量值的定义的集合，从本质上讲，接口是一种特殊的抽象类，这种类中只包含常量和方法的定义，而没有变量和方法的实现。</p>
<p>即使没有显式地将其中的成员用public关键字标识，但这些成员都是public访问类型的。</p>
<p>接口里的变量默认是用public static final标识的，所以，接口中定义的变量就是全局静态常量。</p>
<ol>
<li>可以用extends关键字去继承一个已有的接口</li>
<li>也可以定义一个类，用implements关键字去实现一个接口中的所有方法</li>
<li>还可以去定义一个抽象类，用implements关键字去实现一个接口中定义的部分方法</li>
</ol>
<blockquote>
<p>在java中，设计接口的目的是为了让类不必受限于单一继承的关系，而可以灵活地同时继承一些共有的特性，从而达到多重继承的目的，而且避免了C++中多重继承的复杂关系所产生的问题。多重继承的危险性在于一个类有可能继承了同一个方法的不同实现，对接口来讲绝不会发生这种情况，因为接口没有任何实现。</p>
</blockquote>
<p>一个类可以在继承一个父类的同时，实现一个或多个接口，extends关键字必须位于implements关键字之前。</p>
<ol>
<li>实现一个接口就是要实现该接口的所有方法（抽象类除外）</li>
<li>接口中的方法都是抽象的</li>
<li>多个无关的类可以实现同一个接口</li>
<li>一个类可以实现多个无关的接口</li>
</ol>
<blockquote>
<p>调用者和被调用者必须共同遵守某一限定，调用者按照这个限定进行方法调用，被调用者按照这个限定进行方法实现，在面向对象的编程语言中，这种限定就是通过接口类来表示的，主板和各种PCI卡就是按照PCI接口进行约定的。</p>
</blockquote>
<p>java编译器并不能根据一个类中有哪些方法，就知道它是某个类的子类的，编译器只能从extends和implements关键字上来了解。</p>
<h3 id="对象的多态性"><a href="#对象的多态性" class="headerlink" title="对象的多态性"></a>对象的多态性</h3><h4 id="对象的类型转换"><a href="#对象的类型转换" class="headerlink" title="对象的类型转换"></a>对象的类型转换</h4><ol>
<li>子类转换成父类</li>
<li>父类转换成子类<br>强制转换：目的是让编译器进行语法检查时开点后门，放你过关，强制类型转换并不是要对内存中的对象大动手术，不是要将男人变成女人。</li>
</ol>
<p>强制类型转换的前提是程序员提前就知道要转换的父类引用类型对象的本来面目确实是子类类型的。</p>
<blockquote>
<p>可以用instanceof判断是否一个类实现了某个接口，也可以用它来判断一个实例对象是否属于一个类。</p>
</blockquote>
<h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><p>Object类时java类层中的最高层类，是所有类的超类，java中任何一个类都是它的子类，由于所有类都是object衍生出来的，所以object的方法适用于所有类。</p>
<p>Object中有一个equals方法，用于比较两个对象是否相等，默认值为false，为了确保准确，自定义类中必须覆盖Object类的equals方法。</p>
<h4 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h4><ol>
<li>应用程序不必为每一个派生类（子类）编写功能调用，只需要对抽象基类进行处理即可。</li>
<li>派生类的功能可以被基类的方法或引用变量调用，这叫后向兼容，可以提高程序的可扩充性和可维护性。</li>
</ol>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>内部类可以声明是抽象类或是一个接口，它可以被另外一个内部类来继承或实现，内部类可以继承外部类，也可以用final关键字修饰。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常定义了程序中遇到的非致命的错误，而不是编译时的语法错误，如程序打开一个不存在的文件，网络连接中断，操作数越界，装载一个不存在的类等…</p>
<p>当try代码块中的程序发生了异常，系统将这个异常发生的代码行号，类别等信息封装到一个对象中，并将这个对象传递给catch代码块。</p>
<h4 id="throws关键字"><a href="#throws关键字" class="headerlink" title="throws关键字"></a>throws关键字</h4><p>定义方法时用throws关键字声明了它有可能发生异常，调用者就必须使用try…catch语句进行处理，这叫防患于未然。</p>
<p>在a调用方法中不处理，继续throws，一直到main方法<br>java中一个方法时可以被声明成抛出多个异常的。</p>
<p>Exception类是所有异常类的父类，除了ArithmeticException、NullPointerException、ArrayIndexOutOfBoundsException等系统异常外，我们也可以定义自己的异常类。</p>
<p>java是通过throw关键字抛出异常对象的<br>throw 异常对象;</p>
<p>在一个方法内使用throw关键字抛出了异常对象，如果该方法内部没有用try…catch语句对这个抛出的异常进行处理，则此方法应声明抛出异常，而由该方法的调用者负责处理。</p>
<p>我们可以在一个方法中使用throw、try…catch语句来实现程序的跳转<br><img alt data-src="http://onzc6nld3.bkt.clouddn.com/4.4.4.jpg"></p>
<h4 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h4><p>finally语句中的代码不管异常是否被捕获总是要被执行的。<br>finally中的代码块不能被执行的唯一情况是：在被保护代码块中执行了System.exit()</p>
<p>注意：</p>
<ol>
<li>一个方法被覆盖时，覆盖它的方法必须抛出相同的异常或异常的子类；</li>
<li>如果父类抛出多个异常，那么重写（覆盖）方法必须抛出那些异常的一个子集，也就是说，不能抛出新的异常。</li>
</ol>
<p>java没有goto语句，它保留goto关键字只是为了让程序员不要搞混。java利用带标号的break和continue语句来取代goto。java中严格定义的异常处理机制使goto没有再存在的必要，取消这种随意跳转的语句有利于优化代码以及保持系统的健壮性和安全性。</p>
<blockquote>
<p>java异常强制我们去考虑程序的强健性和安全性</p>
</blockquote>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>java通过引入package机制，提供类的多层类命名空间。</p>
<p>位于包中的每个类的完整名称都应该是包名与类名的组合。<br>同一个包中的类相互访问，不用指定包名。</p>
<blockquote>
<p>同是中国的两个城市，使用时非要加个中国前缀，也是行得通的，但让人听起来就有点像汉奸了</p>
</blockquote>
<p>如果从外部访问一个包中的类，必须使用类的完整名称。<br>虚拟机在装载带有包名的类时，会先找到classpath环境变量指定的目录，再在这些目录中，按照与包名层次相对应的目录结构去查找class文件。</p>
<p>在编译时，让javac来生成与包名层次相对应的目录结构，而不必手工去创建。</p>
<p>javac -d  . Test.java</p>
<p>. 代表当前目录</p>
<p>如果没有-d选项，.class文件存放在当前工作目录</p>
<p>位于在包中的类，在文件系统中的存放位置，必须有与包名层次相对应的目录结构。在package语句中，用.来指明包的层次。</p>
<p>虚拟机在装载带有包名的类时，会先找到classpath环境变量指定的目录，再在这些目录中，按照与包名层次相对应的目录结构去查找class文件。</p>
<ol>
<li>即使java/class文件名相同，但其中包含的类的完整名称却不一定相同。</li>
<li>同一个包中的类不必位于同样的目录，因为java是通过classpath去寻找顶层包名。</li>
</ol>
<p>包名必须在程序中通过package语句指定，而不是靠目录结构来指定，先要有了包名后，才需要相应的目录结构。</p>
<p>包声明放在源文件的最前面，每个源文件只能声明一个包。</p>
<p>在实际应用中，虽然编译了一个修改过的java源文件，但运行可能是某个旧的class文件，特别是旧的class文件所在的目录再classpath环境变量中的位置，位于新的class文件所在的目录的前面，问题就更加隐蔽了。</p>
<p>当我们在编译过程中遇到了问题，有时并不是程序本身所带来的问题，需要我们放眼全局，思路更加开阔一些，从多个方面去思考和解决问题。</p>
<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>父包和子包之间，能从语意上表示某种血缘和亲近关系，但父包和子包在使用上没有任何关系，如父包中的类调用子包中的类，必须引用子包的全名，而不能省略父包名部分。</p>
<p>import一个包中所有的类，并不会import这个包中的子包中的类，如果程序中用到了子包的类，需要再次对子包作单独引入。</p>
<h4 id="jdk中的常用包"><a href="#jdk中的常用包" class="headerlink" title="jdk中的常用包"></a>jdk中的常用包</h4><ol>
<li>java.lang<br>包含一些java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能；</li>
</ol>
<p>java1.2以后的版本中，java.lang这个包会自动被导入，对于其中的类，不需要使用import语句来做导入，如System类</p>
<ol start="2">
<li><p>java.io<br>包含能提供多种输入/输出功能的类</p>
</li>
<li><p>java.util<br>包含一些实用工具类，如定义系统特性、使用与日期日历相关的方法。</p>
</li>
<li><p>java.net<br>包含执行与网络相关的操作的类</p>
</li>
</ol>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>访问修饰符共有4个：default、public、protected、private</p>
<h4 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h4><p>private<br>不能在方法体内声明的变量前加private修饰符</p>
<p>default 默认访问控制：default、friendly、package<br>对于默认访问控制成员，可以被这个包中的其它类访问。如果一个子类与父类位于不同的包中，子类也不能访问父类中的默认访问控制成员。</p>
<p>protect：既可以被同一个包中的其他类访问，也可以被不同包中的子类访问。</p>
<p>public：所有类，不管访问类与被访问类是否在同一个包中。</p>
<p><img alt data-src="http://onzc6nld3.bkt.clouddn.com/4.1table.jpg"></p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>只有两种访问权限<br>即：public和默认</p>
<p>父类不能是private和protected，否则子类无法继承<br>public修饰的类能被所有的类访问，<br>默认修饰的类，只能被同一包中的所有类访问。</p>
<h3 id="java命名习惯"><a href="#java命名习惯" class="headerlink" title="java命名习惯"></a>java命名习惯</h3><ol>
<li>包名中的字母一律小写，如xxyyzz</li>
<li>类名、接口名应当使用名词，每个单词的首字母大写，如XxYyZz</li>
<li>方法名，第一个单词小写，后面每个单词的首字母大写，如xxYyZz</li>
<li>变量名，第一个单词小写，后面每个单词的首字母大写，如xxYyZz</li>
<li>常量名中的每一个字母一律大写，如XXXYYYZZZ</li>
</ol>
<h3 id="使用jar文件"><a href="#使用jar文件" class="headerlink" title="使用jar文件"></a>使用jar文件</h3><p>我们用的jdk中的包与类主要在jdk的安装目录的jre\lib\rt.jara文件中，由于java虚拟机会自动找到这个jar包，所以我们在使用这个jar包的类时，无需再用classpath来指向它们的位置。</p>
<p>jar: java archive file</p>
<p>jar文件是一种压缩文件，与常见的zip压缩文件格式兼容，习惯上称之为jar包，我们将开发的类压缩到jar文件中，以jar包的方式提供给别人使用。只要别人的classpath环境变量的设置中包含这个jar文件，java虚拟机就能自动在内存中解压这个jar文件，把这个jar文件当做一个目录，在这个jar文件中去寻找所需要的类及包名所对应的目录结构。</p>
<p><img alt data-src="http://onzc6nld3.bkt.clouddn.com/4.7.jpg"></p>
<h4 id="jar-命令详解"><a href="#jar-命令详解" class="headerlink" title="jar 命令详解"></a>jar 命令详解</h4><p>jar命令是随jdk自动安装的，存放在jdk安装目录下的bin目录中。</p>
<p>jar命令可以用来对大量的类进行压缩，然后存为jar文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Usage: jar &#123;ctxui&#125;[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files ...</span><br><span class="line">Options:</span><br><span class="line">    -c  create <span class="keyword">new</span> archive</span><br><span class="line">    -t  list table of contents <span class="keyword">for</span> archive</span><br><span class="line">    -<span class="function">x  extract <span class="title">named</span> <span class="params">(or all)</span> files from archive</span></span><br><span class="line"><span class="function">    -u  update existing archive</span></span><br><span class="line"><span class="function">    -v  generate verbose output on standard output</span></span><br><span class="line"><span class="function">    -f  specify archive file name</span></span><br><span class="line"><span class="function">    -m  include manifest information from specified manifest file</span></span><br><span class="line"><span class="function">    -n  perform Pack200 normalization after creating a new archive</span></span><br><span class="line"><span class="function">    -e  specify application entry point <span class="keyword">for</span> stand-alone application</span></span><br><span class="line"><span class="function">        bundled into an executable jar file</span></span><br><span class="line"><span class="function">    -0  store only</span>; use no ZIP compression</span><br><span class="line">    -P  preserve leading <span class="string">'/'</span> (absolute path) and <span class="string">".."</span> (parent directory) components from file names</span><br><span class="line">    -M  <span class="keyword">do</span> not create a manifest file <span class="keyword">for</span> the entries</span><br><span class="line">    -i  generate index information <span class="keyword">for</span> the specified jar files</span><br><span class="line">    -C  change to the specified directory and include the following file</span><br><span class="line">If any file is a directory then it is processed recursively.</span><br><span class="line">The manifest file name, the archive file name and the entry point name are</span><br><span class="line">specified in the same order as the <span class="string">'m'</span>, <span class="string">'f'</span> and <span class="string">'e'</span> flags.</span><br><span class="line"></span><br><span class="line">Example 1: to archive two class files into an archive called classes.jar:</span><br><span class="line">       jar cvf classes.jar Foo<span class="class">.<span class="keyword">class</span> <span class="title">Bar</span>.<span class="title">class</span></span></span><br><span class="line">Example 2: use an existing manifest file 'mymanifest' and archive all the</span><br><span class="line">           files in the foo/ directory into <span class="string">'classes.jar'</span>:</span><br><span class="line">       jar cvfm classes.jar mymanifest -C foo/ .</span><br></pre></td></tr></table></figure>
<p>注意：使用jar压缩文件夹时，在生成的jar文件中会保留在jar命令中所出现的路径名</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>在多任务系统中，每个独立执行的程序称为进程，也就是”正在进行的程序”</p>
</blockquote>
<p>每个进程都有独立的代码和数据空间（进程上下文）</p>
<blockquote>
<p>一个线程就是一个程序内部的一条执行线索</p>
</blockquote>
<p>当程序启动运行时，就自动产生了一个线程，主方法main就是在这个线程上运行的，当不再产生线程时，程序就是单线程的。如果要一个程序实现多段代码同时交替运行，就需产生多个线程，并指定每个线程上所要运行的程序代码段。</p>
<p>创建多线程有两种方法，继承Thread类和实现Runnable接口。</p>
<h4 id="用Thread类创建线程"><a href="#用Thread类创建线程" class="headerlink" title="用Thread类创建线程"></a>用Thread类创建线程</h4><p>Java的线程时通过java.lang.Thread类来控制的，一个Thread类的对象代表一个线程，而且只能代表一个线程，通过Thread类和它定义的对象，我们可以获得当前线程对象、获取某一线程的名称，可以实现控制线程暂停一段时间等功能。</p>
<p><img alt data-src="http://onzc6nld3.bkt.clouddn.com/5.3.jpg"></p>
<ol>
<li><p>要将一段代码在一个新的线程上运行，该代码应该在一个类的run方法中，并且run方法所在的类是Thread类的子类。倒过来说，要实现多线程，必须编写一个继承了Thread类的子类，子类要覆盖Thread类中的run方法，在子类的run方法中调用想在新线程上运行的程序代码。</p>
</li>
<li><p>启动一个新的线程，不是直接调用Thread子类对象的run方法，而是调用Thread子类对象的start（从Thread类中继承的）方法，Thread类对象的start方法将产生一个新的线程，并在该线程上运行该Thread类对象中的run方法，根据面向对象的多态性，在该线程上实际运行的是Thread子类（也就是我们编写的那个类）对象中的run方法。</p>
</li>
<li><p>由于线程的代码在run方法中，那么该方法执行完以后，线程也就相应的结束了，因而可以通过控制run方法中的循环条件来控制线程的终止。</p>
</li>
</ol>
<p>Thread类有许多构造方法，通过Thread()构造方法创建的，线程将调用线程对象的run()方法作为其运行代码。如果Thread类的子类没有覆盖run方法，则程序会调用Thread类中的run方法，而该方法什么也不做，所以新的线程刚一产生就结束了。</p>
<p>直接在程序中写 new Thread().start()，新的线程将直接调用Thread类中的run()方法，效果同上。</p>
<p>综上，使用Thread()构造方法，适用于覆盖了run方法的Thread子类创建线程对象的情况。</p>
<h4 id="使用Runnable接口创建多线程"><a href="#使用Runnable接口创建多线程" class="headerlink" title="使用Runnable接口创建多线程"></a>使用Runnable接口创建多线程</h4><p>Thread(Runnable target)构造方法<br>Runnable接口类，该接口只有一个run()方法，当使用Thread（Runnable target）方法创建线程对象时，需要为该方法传递一个实现了Runnable接口的类对象，这样创建的线程将调用那个实现了Runnable接口的类对象中的run()方法作为其运行代码，而不再调用Thread类中的run方法了。</p>
<p>一个线程对象只能启动一个线程，无论你调用多少遍start()方法，结果都只有一个线程。</p>
<p>创建多个Thread类子类的对象，就等于创建了四个资源，每个线程在独立地处理各自的资源。</p>
<p>经验：一个资源（一个Thread类子类或实现了Runnable接口的类的对象），创建多个线程去处理同一个资源，并且每个线程上所允许的是相同的程序代码。</p>
<p>如：Windows上可以启动多个记事本程序，也就是多个进程使用的是同一个记事本程序代码。</p>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>实现Runnable接口相对于继承Thread类来说，有下述好处：</p>
<ol>
<li><p>适合多个相同程序代码的线程去处理同一资源的情况，把虚拟CPU（线程）同程序的代码、数据有效分离，较好地体现了面向对象的设计思想。</p>
</li>
<li><p>可以避免由于java的单继承性带来的局限。当我们要将已经继承了某一个类的子类放入多线程中，由于一个类不能同时又两个父类，所以不能用继承Thread类的方式，只能采用实现Runnable接口的方式。</p>
</li>
<li><p>有利于程序的健壮性，代码能够被多个线程共享，代码与数据是独立的。当多个线程的执行代码来自于同一个类的实例时，即称它们共享相同的代码，多个线程可以操作相同的数据，与它们的代码无关。当共享访问相同的对象时，即它们共享相同的数据。当线程被构造时，需要的代码和数据通过一个对象作为构造方法实参传递进去，这个对象就是一个实现了Runnable接口的类的实例。</p>
</li>
</ol>
<h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>对java程序来说，只要还有一个前台线程在运行，这个进程就不会结束，如果一个进程只有后台线程运行，这个进程就会结束。前台线程时相对后台线程而言的，如果对某个线程对象在启动（调用start方法）之前调用了setDaemon(true)方法，这个线程就变成了后台线程。</p>
<h4 id="join联合线程"><a href="#join联合线程" class="headerlink" title="join联合线程"></a>join联合线程</h4><p>Thread类的join方法，作用是把a线程合并到调用a.join()语句的线程中。除了无参数的join方法外，还有两个带参数的join方法，分别是join(long millis)和join(long millis, int nanos)，它们的作用是指定合并时间，前者精确到毫秒，后者精确到纳秒，意思是两个线程合并指定的时间后，又开始分离，回到合并前的状态。</p>
<h4 id="多线程实践"><a href="#多线程实践" class="headerlink" title="多线程实践"></a>多线程实践</h4><ol>
<li><p>网络聊天程序<br>发送过程与接收过程在两个不同的线程上运行，彼此之间没有任何约束<br><img alt data-src="http://onzc6nld3.bkt.clouddn.com/5.10.jpg"></p>
</li>
<li><p>耗时数据处理取消机制<br>创建一个新的线程，该线程与用户交互，接收用户的输入，当接收到用户的停止命令时，新线程将主线程的循环条件Flag设置为假，即通知主线程在下次检查循环条件时结束复制过程。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> bFlag =<span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span>(bFlag)&#123;</span><br><span class="line">    <span class="comment">//复制程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>www服务器<br>为每一个来访者创建一个线程</li>
</ol>
<h4 id="多线程同步"><a href="#多线程同步" class="headerlink" title="多线程同步"></a>多线程同步</h4><p>sleep(long millis)<br>线程的睡眠是可以被打断的，通过Thread.interrupt()，线程的睡眠被打断后进入Runnable状态。</p>
<blockquote>
<p>线程安全，类的同一个实例的方法在多个线程被调用，是否会出现意外。</p>
</blockquote>
<p>一、同步代码块<br>代码块的原子性，好比一座独木桥，任一时刻，只能有一个人在桥上行走，程序中不能有多个线程同时在这两句代码之间执行，这就是线程同步。</p>
<p>将这些需要具有原子性的代码，放入synchronized语句中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object 可以是任意的一个对象</span></span><br><span class="line"><span class="keyword">synchronized</span>(object)&#123;代码段&#125;</span><br></pre></td></tr></table></figure>
<p>任何类型的对象都有一个标志位，该标志位具有0、1两种状态，其开始状态为1，当执行synchronized(object)语句后，object对象的标志位变为0状态，知道执行完整个synchronized语句中的代码块后又回到1状态。</p>
<p>一个线程执行到synchronized语句处，先检查object对象（监视器）的标志位（锁旗标），如果为0状态，表明已经有另外的线程的执行状态正在有关的同步代码块中，这个线程将暂时阻塞（加入到一个与该对象的锁旗标相关联的等待线程池中），让出cpu资源，直到另外的线程执行完有关的同步代码块，将object对象的标志位恢复到1状态，这个阻塞就被取消，线程能够继续往下执行，并将object对象的标志位变为0状态，防止其它线程再进入有关的同步代码块中。如果有多个线程因等待同一对象的标志位而处于阻塞状态时，当对象的标志位恢复到1状态时，只会有一个线程能够继续运行，其它线程仍然处于阻塞等待状态。</p>
<p>若干个不同的代码块也可以实现相互之间的同步，只要各synchronized(object)语句中的object完全是同一个对象就可以。</p>
<p>一个刚锁定了监视器的线程在监视器被解锁后可以再次进入并锁定同一监视器，好比篮球运动员的篮球出手后可以再次去抢回来一样。</p>
<p>当在同步块中遇到break语句或抛出异常时，线程也会释放该锁旗标。</p>
<p>当cpu进入了一段同步代码块中执行，cpu是可以切换到其他线程的，只是在准备执行其他线程的代码时，发现其它线程处于阻塞状态，cpu又会回到先前的线程上。这个过程就类似于幸运之神刚一光顾其他有关线程，没想到吃了个闭门羹，便又离开了。</p>
<p>同步是以牺牲程序的性能为代价的，因为i系统要不停地对同步监视器进行检查，需要更多的开销。</p>
<p>除了可以对代码块进行同步外，也可以对方法实现同步，只要在需要同步的方法定义前加上synchronized关键字即可。</p>
<p>同步方法所用的监视器对象就是this对象</p>
<blockquote>
<p>老手就是在大量的实践中，犯下众多错误，然后经过反复调试、观察、比较，最后在总结、积累经验的过程中成长起来的。在计算机编程过程中，我们有时候会因为自己知识的不全面而作出错误的结论。</p>
</blockquote>
<p><img alt data-src="http://onzc6nld3.bkt.clouddn.com/5.2.jpg"></p>
<h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><p>两个线程对两个同步对象具有循环依赖时，就会出现死锁，例如一个线程进入对象X的监视器，而另一个对象进入了对象Y的监视器，这时进入X对象监视器的线程如果还试图进入Y对象的监视器就会被阻隔，接着进入Y对象监视器的线程如果试图进入X对象的监视器也会被阻隔，这样两个线程都处于挂起状态。程序发生死锁后最明显的特征就是程序的运行处于停滞不前状态。</p>
<p>两个人在吃饭，甲拿到了一根筷子和一把刀子，乙拿到了一把叉子和一根筷子，他们都无法吃到饭。<br>甲：你先给我筷子，我再给你刀子<br>乙：你先给我刀子，我才给你筷子<br>……</p>
<h3 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h3><p>java是通过object类的wait、notify、notifyall这三个方法来实现线程间的通信。所有的类都是从Object继承的，因此在任何类中都可以直接使用这些方法。</p>
<p>wait：告诉当前线程放弃监视器并进入睡眠状态，直到其他线程进入同一监视器并调用notify为止；<br>notify：唤醒同一对象监视器中调用wait的第一个线程，类似于饭馆有一个空位后通知所有等候就餐的顾客中的第一位可以入座的情况；<br>notifyAll：唤醒同一个对象监视器中调用wait的所有线程，只有最高优先级的线程首先被唤醒并执行。</p>
<p>上述三个方法只能在synchronized方法中调用，即：无论线程调用一个对象的wait还是notify方法，该线程必须先得到该对象的锁旗标，这样，notify只能唤醒同一个对象监视器中调用wait的线程，使用多个对象监视器，我们就可以分组有多个wait、notify的情况，同组里的wait只能被同组的notify唤醒。</p>
<p>一个线程的等待和唤醒过程可以用下图表示：<br><img alt data-src="http://onzc6nld3.bkt.clouddn.com/5.13.jpg"></p>
<h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><p>线程产生和消亡的整个过程，如下图所示：</p>
<p><img alt data-src="http://onzc6nld3.bkt.clouddn.com/5.4.jpg"></p>
<p>一个线程的产生式从我们调用了start方法开始进入Runnable状态，即可以被调度运行状态，并没有真正开始运行，调度器可以将CPU分配给它，真正运行其中的程序代码。线程在运行过程中，有以下几个可能的去向：</p>
<ol>
<li>没有遇到任何阻隔，运行完成直接结束，也就是run()方法执行完毕；</li>
<li>调度器将CPU分配给其他线程，这个线程又变为Runnable状态；</li>
<li>请求锁旗标，却得不到，这时候它要等待对象的锁旗标，得到锁旗标后又会进入Runnable状态开始运行；</li>
<li>遇到wait方法，它会被放入等待池中继续等待，直到有notify()或interrupt()方法执行，它才会被唤醒或打断，开始等待对象锁旗标，等到锁旗标后进入Runnable状态继续执行。</li>
</ol>
<p>控制线程生命周期的方法有suspend、resume和stop方法，但不推荐使用。</p>
<p>不推荐使用suspend和resume的原因如下：</p>
<ol>
<li>会导致死锁的发生；</li>
<li>它允许一个线程通过直接控制另外一个线程乙的代码来直接控制那个线程乙。</li>
</ol>
<p>不推荐使用stop的原因如下：<br>虽然stop能够避免死锁的发生，但是带来了另外的不足，如果一个线程正在操作共享数据段，操作过程中没有完成就stop了的话，就会导致数据的不完整性。</p>
<p>经验：推荐使用控制run方法中循环条件的方式来结束一个线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLife</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">		ThreadLifeTest threadLifeTest = <span class="keyword">new</span> ThreadLifeTest();</span><br><span class="line">		<span class="keyword">new</span> Thread(threadLifeTest).start();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">5</span>==i)&#123;</span><br><span class="line">				threadLifeTest.stopMe();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"main thread is running"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLifeTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> bFlag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopMe</span><span class="params">()</span></span>&#123;</span><br><span class="line">		bFlag = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(bFlag)&#123;</span><br><span class="line">			System.out.println(<span class="string">"ThreadLifeTest.run()"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：调用了目标线程的stopMe方法之后，cpu不一定会马上切换到目标线程，目标线程也就不一定会马上终止。稍后切换到目标线程之后，终止了while循环，run方法结束，目标线程随之结束。</p>
<h3 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h3><p>API Application Programming Interface</p>
<p>学习编程语言与学汉语</p>
<ol>
<li><p>语法</p>
</li>
<li><p>成语<br>学习编程语言，掌握了大量API，就像学习汉语时掌握了大量的成语一样，我们在处理某些问题时将会轻而易举，同样，我们也能从这些API类中学会大师们组织java类的方法，划分系统结构的技巧。</p>
</li>
</ol>
<p>区别：对API来说，完全可以在需要时通过某种方式临时获取，现学现用</p>
<ol start="3">
<li>学会写文章的技巧和手法，找到写文章的灵感<br>学习编程，也需要掌握分析与解决问题的手法，养成良好的编程习惯与风格，体会出一种编程的感觉。</li>
</ol>
<p>唐诗宋词/优秀散文<br>优秀的源代码<br>一些大学老师从事实际项目开发的经验不太丰富，只能讲些语法和API方面的知识，没有能力帮你分析与讲解编程经验与体会，就像许多小学老师自己都写不出好的作文来，但却可以成为语文老师一样的道理。</p>
<blockquote>
<p>专家不是靠书本学出来的，是有了一定的基础后，在工作中再总结、在学习的过程中成长起来的。我们没有必要去了解一门语言中的每个方面和细节，虽然，我们了解的越多，水平似乎就越高，但这都是要以时间和精力为代价的，学习到一定程度后，要适可而止，否则，一辈子都只有疲于学习的份儿了，就完全违背了“学以致用”的初衷。</p>
</blockquote>
<p>当你掌握了一门语言的语法特点后，能够看懂一般的程序，在需要时能够参照文档资料看懂以前还没有接触过的某个方面的程序，能够自己写出以恶搞有某种实际应用的小程序，你就算掌握了这门语言，剩下的就是你在工作中如何去积累经验的问题了。</p>
<p>会写一个程序的标准，是理解编程思想，再用自己的想法去独立写下来，对程序中的每个细节都是真正明白的。</p>
<h4 id="String类和StringBuffer类"><a href="#String类和StringBuffer类" class="headerlink" title="String类和StringBuffer类"></a>String类和StringBuffer类</h4><p>一个字符串就是一连串的字符，Java定义了String和StringBuffer两个类来封装对字符串的各种操作，都被放到了java.lang包中，不需要import java.lang这个语句导入该包就可以直接使用它们。</p>
<p>String类用于比较两个字符串、查找和抽取串中的字符或子串、字符串与其他类型之间的相互转换等。String类对象的内容一旦被初始化就不能再改变。</p>
<p>StringBuffer类用于内容可以改变的字符串，可以将其它各种类型的数据增加，插入到字符串中，也可以翻转字符串中原来的内容。一旦通过StringBuffer生成了最终想要的字符串，就应该使用StringBuffer.toString方法将其转换成String类，随后，就可以使用String类的各种方法操纵这个字符串了。</p>
<p>Java为字符串提供了特别的连接操作符+，可以把其它各种类型的数据转换成字符串，并前后连接成新的字符串。连接操作符+的功能是通过StringBuffer类和它的append方法实现的。</p>
<blockquote>
<p>String x = “a”+4+”c”;</p>
</blockquote>
<p>等效于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer temp = new StringBuffer();</span><br><span class="line">temp.append(&quot;a&quot;);</span><br><span class="line">temp.append(&quot;4&quot;);</span><br><span class="line">temp.append(&quot;c&quot;);</span><br><span class="line">x =temp.toString();</span><br></pre></td></tr></table></figure></p>
<p>注意：<br>String s1 = “hello”<br>String s2 = “hello”<br>s1和s2是同一个对象。</p>
<p>String s1 = new String(“hello”);<br>String s2 = new String(“hello”);<br>s1和s2是两个不同的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">byte</span> buf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		String strInfo = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"please enter info, input bye for exit"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">			ch = System.in.read();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">				strInfo = <span class="keyword">new</span> String(buf,<span class="number">0</span>,pos);</span><br><span class="line">				<span class="keyword">if</span>(<span class="string">"bye"</span>.equals(strInfo))&#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					System.out.println(strInfo);</span><br><span class="line">					pos=<span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					buf[pos++]=(<span class="keyword">byte</span>)ch;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String(buf,0,pos)把数组buf里面的值从0到pos取出，用来创建新的String类对象。<br>equals，比较String类对象的内容是否等于某一字符串常量<br>equalsIgnoreCase<br>indexof(int ch)、indexof(int ch,int fromIndex)<br>indexof(String str)、indexof(String str, int fromIndex)<br>substring(int beginIndex)、<br>substring(int beginIndex, int endIndex) 返回beginIndex到endIndex-1的一个字符串</p>
<p>String类中的replace和toUpperCase都不能改变字符串的内容，它们的返回值都是String类，即生成一个新的字符串，而不是改变原来的字符串内容。</p>
<h4 id="基本数据类型的对象包装类"><a href="#基本数据类型的对象包装类" class="headerlink" title="基本数据类型的对象包装类"></a>基本数据类型的对象包装类</h4><p>java对数据既提供基本数据的简单类型，也提供了相应的包装类，使用基本简单数据类型，可以改善系统的性能，也能满足大多数应用需求，但基本简单类型不具有对象的特性，不能满足某些特殊的需求。譬如很多类的很多方法参数类型都是object，Integer类来包装整数。包装类对象在进行基本数据类型的类型转换时也特别有用。</p>
<p>8种基本数据类型都有其对应的包装类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> bool= <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">byte</span> bt= <span class="keyword">new</span> Byte((<span class="keyword">byte</span>) <span class="string">'t'</span>);</span><br><span class="line"><span class="keyword">char</span> ch = <span class="keyword">new</span> Character(<span class="string">'t'</span>);</span><br><span class="line"><span class="keyword">short</span> st = <span class="keyword">new</span> Short((<span class="keyword">short</span>) <span class="number">18</span>);</span><br><span class="line"><span class="keyword">int</span> it = <span class="keyword">new</span> Integer(<span class="number">18</span>);</span><br><span class="line"><span class="keyword">long</span> lg = <span class="keyword">new</span> Long(<span class="number">18</span>);</span><br><span class="line"><span class="keyword">float</span> ft = <span class="keyword">new</span> Float(<span class="number">1.8f</span>);</span><br><span class="line"><span class="keyword">double</span> db = <span class="keyword">new</span> Double(<span class="number">1.8</span>d);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要善于找出包装类的一些共性的地方，达到举一反三，学一通百的效果</p>
</blockquote>
<p>要将字符串转换成基本数据类型，几乎都是用Xxx包装类.parseXxx方式实现（一个例外是对于Boolean类，用的是getBoolean）</p>
<p>要将包装类转换成基本数据，几乎都是Xxx包装类对象.xxxValue方式。</p>
<h3 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h3><h4 id="Vector类"><a href="#Vector类" class="headerlink" title="Vector类"></a>Vector类</h4><p>Vector类是Java语言提供的一种高级数据结构，可用于保存一些列对象，java不支持动态数组，Vector类提供了一种与动态数组相近的功能。</p>
<p>如果我们不能预先确定要保存的对象的数目，或是需要方便获得某个对象的存放位置，Vector类都是一种不错的选择。</p>
<h4 id="Enumeration接口类"><a href="#Enumeration接口类" class="headerlink" title="Enumeration接口类"></a>Enumeration接口类</h4><p>Enumeration是一个接口类，它提供了一种访问各种数据结构中的所有数据的抽象机制，我们要访问各种数据结构对象中的所有元素时，都可以使用同样的方式，调用同样的方法。有了这样的数据结构，就很容易学一通百，以不变应万变。</p>
<h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h4><h4 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h4><p>我们要取出保存在实现了Collection接口对象中的所有对象，我们也必须通过Collection.iterator方法返回要给Iterator接口对象，Iterator接口的功能与使用同Enumeration接口非常相似。</p>
<p>Java2平台的数据结构类设计人员本可以扩展Enumeration接口，而不用创建Iterator这个新接口。但他们不喜欢Enumeration接口方法冗长的名字，因而创建了Iterator这个新接口，并缩短了方法名长度。</p>
<p>Java中，不能直接用Collection接口类创建对象，而必须用实现了Collection接口的类来创建对象，ArrayList类就是一个实现了Collection接口的类。</p>
<blockquote>
<p>不要变成只会照着书做，而不会自学和思考的人，假设有人真的把java api全部背了下来，以后再遇到别的公司开发的java类，不还是一样不会吗？</p>
</blockquote>
<p>什么时候用Vector，什么时候用ArrayList，Vector类中的所有方法都是线程同步的，两个线程并发访问Vector对象将是安全的，但只有一个线程访问Vector对象时，因为源程序仍调用了同步方法，需要额外的监视器检查，运行效率要低一些。</p>
<p>ArrayList类中的所有方法是非同步的，程序的效率会高一些。</p>
<h4 id="集合类接口的比较"><a href="#集合类接口的比较" class="headerlink" title="集合类接口的比较"></a>集合类接口的比较</h4><p>Collection——对象之间没有指定的顺序，允许重复元素；<br>Set——对象之间没有指定的顺序，不允许重复元素；<br>List——对象之间有指定的顺序，允许重复元素。</p>
<p><img alt data-src="http://onzc6nld3.bkt.clouddn.com/6.3.jpg"></p>
<h4 id="Hashtable类"><a href="#Hashtable类" class="headerlink" title="Hashtable类"></a>Hashtable类</h4><p>Hashtable也是一种高级数据结构，用以快速检索数据。Hashtable不仅可以像Vector一样动态存储一系列的对象，而且对存储的每一个对象（值value）都要安排另一个对象（关键字key）与之相关联。</p>
<p>向Hashtable对象中存储数据，使用的是Hashtable.put(Object key, Object value)方法，从Hashtable中检索数据，使用Hashtable.get(Object key)方法。值和关键字都可以是任何类型的非空的对象。</p>
<p>要想成功地从Hashtable中检索数据，用作关键字的对象必须正确覆盖了Object.hashCode方法和Object.equals方法（检索时，必须比较所用关键字是否与存储在Hashtable中的某个关键字相等，如果两个关键字对象不能正确判断是否相等，检索是不可能正确的）。</p>
<p>Object.hashCode方法返回一个叫散列码的值，这个值是由对象的地址以某种方式转换来的，内容相同的两个对象，既然是两个对象，地址就不可能一样，所以Object.hashCode返回的值也不一样。</p>
<p>要想两个内容相同的Object子类对象的hashcode方法返回一样的散列码，子类必须覆盖Object.hashCode方法。</p>
<p>用于关键字的类，如果它的两个对象用equals方法比较是相同的，那么这两个对象的hashCode方法返回值也要一样，所以我们也要覆盖hashCode方法。</p>
<p>String类，已按关键字类的要求覆盖了这两个方法，如果两个String对象的内容不相等，它们的hashCode的返回值也不相等，如果两个String对象的内容相等，它们的hashCode的返回值也相等。所以我们在实现自己编写的关键字类的hashCode方法时，可以调用这个关键字类的String类型的成员变量的hashCode方法来计算关键字类的hashCode返回值。</p>
<p>注意：StringBuffer类没有按照关键字类的要求覆盖hashCode方法，即使两个StringBuffer类对象的内容相等，但这两个对象的hashCode方法的返回值却不相等。所以不能用StringBuffer作为关键字类。</p>
<h4 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h4><p>Properties是Hashtable的子类，它增加了将Hashtable对象中的关键字、值对保存到文件和从文件中读取关键字/值对到Hashtable对象中的方法。<br><img alt data-src="http://onzc6nld3.bkt.clouddn.com/6.4.jpg"></p>
<p>如果要用到Properties类的store方法进行存储，每个属性的关键字和值都必须是字符串类型的。直接用setProperty、getProperty方法进行属性的设置与读取。</p>
<h4 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h4><p>Java不支持全局方法和变量，java设计者将一些系统相关的方法和变量收集到了一个统一的类——System类，System类中的所有成员都是静态的，可以直接使用System类名做前缀。如System.in ， System.out等</p>
<p>System.exit(int status)方法，提前终止虚拟机的运行，对于发生了异常情况下而想终止虚拟机的运行，传递一个非零值作为参数，对于在用户正常操作下，终止虚拟机的运行，传递零值作为参数。</p>
<p>System.CurrentTimeMillis()方法，返回自1970年1月1日0点0分0秒起至今的以毫秒为单位的时间，这是一个long类型的大数值。在计算机内部，只有数值，没有真正的日期类型及其它各种类型，我们平常用到的日期本质上就是一个数值，但通过这个数值，能够推算出其对应的具体日期时间。</p>
<p>getProperties方法与java环境属性<br>getProperties方法获得当前虚拟机的环境属性。<br>Windows环境变量，每一个属性都是变量与值成对的形式出现。<br>同样的道理，java作为一个虚拟的操作系统，它也有自己的环境属性，Properties是Hashtable的子类，正好可以用于存储环境属性中的多个变量/值对格式的数据，getProperties方法返回值是，包含了当前虚拟机的所有环境属性的Properties类型的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Properties sp = System.getProperties();</span><br><span class="line">		Enumeration e = sp.propertyNames();</span><br><span class="line">		<span class="keyword">while</span>(e.hasMoreElements())&#123;</span><br><span class="line">			String key = (String)e.nextElement();</span><br><span class="line">			System.out.println(key+<span class="string">"="</span>+sp.getProperty(key));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在windows中，很容易增加一个新的环境属性，如何为java虚拟机增加一个新的环境属性呢？</p>
<p>java 命令有一个-D <name>=<value>格式的选项可以设置新的系统环境属性。</value></name></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-D&lt;name&gt;=&lt;value&gt;</span><br><span class="line">                 set a system property</span><br></pre></td></tr></table></figure>
<p>如</p>
<blockquote>
<p>java -DAAA=bbb<br>java -DAAA=bbb  -DCCC=ddd</p>
</blockquote>
<p>注意：-D与AAA之间没有空格</p>
<h4 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h4><p>Runtime类封装了Java命令本身的运行进程，其中的许多方法与System中的方法相重复。我们不能直接创建Runtime实例，但可以通过静态方法Runtime.getRuntime获得正在运行的Runtime对象的引用。</p>
<p>Exec方法，Java命令运行后，本身是多任务操作系统上的一个进程，在这个进程启动一个新的进程，即执行其他程序时使用exec方法。exec方法返回一个代表子进程的Process类对象，通过这个对象，Java进程可以与子进程交互。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRuntime</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Process p=<span class="keyword">null</span>;</span><br><span class="line">		p = Runtime.getRuntime().exec(<span class="string">"notepad.exe"</span>);</span><br><span class="line">		Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">		p.destroy();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于程序不能直接创建类Runtime的实例，所以可以保证我们只会产生一个Runtime的实例对象，而不能产生多个实例对象，这种情况就是单态设计模式。</p>
<h4 id="Date与Calendar、DateFormat类"><a href="#Date与Calendar、DateFormat类" class="headerlink" title="Date与Calendar、DateFormat类"></a>Date与Calendar、DateFormat类</h4><p>Date类用于表示日期和时间，最简单的构造方法时Date()，它以当前的日期和时间初始化一个Date对象。</p>
<p>由于开始设计Date时没有考虑到国际化，所以后来又设计了两个新的类来解决Date类中的问题，一个是Calendar类，一个是DateFormat类。</p>
<p>Calendar类是一个抽象基类，主要用于完成日期字段之间相互操作的功能，如Calendar.add方法可以实现在某一日期的基础上增加若干天（或年、月、小时、分、秒等日期字段）后的新日期<br>Calendar.set方法修改日期对象中的年、月、日、小时、分、秒等日期字段的值。<br>Calendar.getInstance方法可以返回一个Calendar类型（更确切地说是它的某个子类）的对象实例，GregorianCalendar类是JDK目前提供的一个唯一的Calendar子类，Calendar.getInstance方法返回的就是预设了当前时间的GregorianCalendar类对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Calendar cl = Calendar.getInstance();</span></span><br><span class="line">Calendar cl = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">System.out.println(<span class="string">""</span>+cl.get(cl.YEAR)+cl.get(cl.MONTH)+cl.get(cl.DAY_OF_MONTH));</span><br><span class="line">cl.add(cl.DAY_OF_YEAR, <span class="number">315</span>);</span><br><span class="line">System.out.println(<span class="string">""</span>+cl.get(cl.YEAR)+cl.get(cl.MONTH)+cl.get(cl.DAY_OF_MONTH));</span><br></pre></td></tr></table></figure>
<p>虽然Calendar类几乎完全替代了Date类，但在某些情况下，我们仍有可能要用到Date类，譬如，程序中用的另外一个类的方法要求一个Date类型的参数。</p>
<p>我们有时要将Date对象表示的日期用指定的格式输出和将特定格式的日期字符串转换成一个Date对象。</p>
<p>Java.text.DataFormat就是实现这种功能的抽象基类，<br>Java.text.SimpleDateFormat类是JDK目前提供的一个DateFormat子类，它是一个具体类，使用它就可以完成把Date对象格式化为本地字符串，或者通过语义分析把日期或时间字符串转换成Date对象的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">SimpleDateFormat sdf2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日"</span>);</span><br><span class="line">Date d=sdf1.parse(<span class="string">"2017-04-09"</span>);</span><br><span class="line">System.out.println(sdf2.format(d));</span><br></pre></td></tr></table></figure>
<p>SimpleDateFormat类就相当于一个模板，其中yyyy对应的是年，MM对应的是月，dd对应的是日。详细可参考<a href="http://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="noopener">JDK</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Letter	Date or Time Component	Presentation	Examples</span><br><span class="line">G	Era designator	Text	AD</span><br><span class="line">y	Year	Year	<span class="number">1996</span>; <span class="number">96</span></span><br><span class="line">Y	Week year	Year	<span class="number">2009</span>; <span class="number">09</span></span><br><span class="line"><span class="function">M	Month in <span class="title">year</span> <span class="params">(context sensitive)</span>	Month	July</span>; Jul; <span class="number">07</span></span><br><span class="line"><span class="function">L	Month in <span class="title">year</span> <span class="params">(standalone form)</span>	Month	July</span>; Jul; <span class="number">07</span></span><br><span class="line">w	Week in year	Number	<span class="number">27</span></span><br><span class="line">W	Week in month	Number	<span class="number">2</span></span><br><span class="line">D	Day in year	Number	<span class="number">189</span></span><br><span class="line">d	Day in month	Number	<span class="number">10</span></span><br><span class="line">F	Day of week in month	Number	<span class="number">2</span></span><br><span class="line">E	Day name in week	Text	Tuesday; Tue</span><br><span class="line"><span class="function">u	Day number of <span class="title">week</span> <span class="params">(<span class="number">1</span> = Monday, ..., <span class="number">7</span> = Sunday)</span>	Number	1</span></span><br><span class="line"><span class="function">a	Am/pm marker	Text	PM</span></span><br><span class="line"><span class="function">H	Hour in <span class="title">day</span> <span class="params">(<span class="number">0</span><span class="number">-23</span>)</span>	Number	0</span></span><br><span class="line"><span class="function">k	Hour in <span class="title">day</span> <span class="params">(<span class="number">1</span><span class="number">-24</span>)</span>	Number	24</span></span><br><span class="line"><span class="function">K	Hour in am/<span class="title">pm</span> <span class="params">(<span class="number">0</span><span class="number">-11</span>)</span>	Number	0</span></span><br><span class="line"><span class="function">h	Hour in am/<span class="title">pm</span> <span class="params">(<span class="number">1</span><span class="number">-12</span>)</span>	Number	12</span></span><br><span class="line"><span class="function">m	Minute in hour	Number	30</span></span><br><span class="line"><span class="function">s	Second in minute	Number	55</span></span><br><span class="line"><span class="function">S	Millisecond	Number	978</span></span><br><span class="line"><span class="function">z	Time zone	General time zone	Pacific Standard Time</span>; PST; GMT-<span class="number">08</span>:<span class="number">00</span></span><br><span class="line">Z	Time zone	RFC <span class="number">822</span> time zone	-<span class="number">0800</span></span><br><span class="line">X	Time zone	ISO <span class="number">8601</span> time zone	-<span class="number">08</span>; -<span class="number">0800</span>; -<span class="number">08</span>:<span class="number">00</span></span><br><span class="line"></span><br><span class="line">Date and Time Pattern	Result</span><br><span class="line"><span class="string">"yyyy.MM.dd G 'at' HH:mm:ss z"</span>	<span class="number">2001.07</span><span class="number">.04</span> AD at <span class="number">12</span>:<span class="number">08</span>:<span class="number">56</span> PDT</span><br><span class="line"><span class="string">"EEE, MMM d, ''yy"</span>	Wed, Jul <span class="number">4</span>, <span class="string">'01</span></span><br><span class="line"><span class="string">"h:mm a"	12:08 PM</span></span><br><span class="line"><span class="string">"hh '</span>o<span class="string">''</span>clock<span class="string">' a, zzzz"	12 o'</span>clock PM, Pacific Daylight Time</span><br><span class="line"><span class="string">"K:mm a, z"</span>	<span class="number">0</span>:<span class="number">08</span> PM, PDT</span><br><span class="line"><span class="string">"yyyyy.MMMMM.dd GGG hh:mm aaa"</span>	<span class="number">02001</span>.July<span class="number">.04</span> AD <span class="number">12</span>:<span class="number">08</span> PM</span><br><span class="line"><span class="string">"EEE, d MMM yyyy HH:mm:ss Z"</span>	Wed, <span class="number">4</span> Jul <span class="number">2001</span> <span class="number">12</span>:<span class="number">08</span>:<span class="number">56</span> -<span class="number">0700</span></span><br><span class="line"><span class="string">"yyMMddHHmmssZ"</span>	<span class="number">010704120856</span>-<span class="number">0700</span></span><br><span class="line"><span class="string">"yyyy-MM-dd'T'HH:mm:ss.SSSZ"</span>	<span class="number">2001</span>-<span class="number">07</span>-<span class="number">04</span>T12:<span class="number">08</span>:<span class="number">56.235</span>-<span class="number">0700</span></span><br><span class="line"><span class="string">"yyyy-MM-dd'T'HH:mm:ss.SSSXXX"</span>	<span class="number">2001</span>-<span class="number">07</span>-<span class="number">04</span>T12:<span class="number">08</span>:<span class="number">56.235</span>-<span class="number">07</span>:<span class="number">00</span></span><br><span class="line"><span class="string">"YYYY-'W'ww-u"</span>	<span class="number">2001</span>-W27-<span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="Math与Random类"><a href="#Math与Random类" class="headerlink" title="Math与Random类"></a>Math与Random类</h4><p>Math类包含了所有用于几何和三角的浮点运算方法，这些方法都是静态的，每个方法的使用都非常简单，一看JDK文档就能明白。</p>
<p>Random类是一个伪随机数产生器，随机数是按照某种算法产生的，一旦用一个初值创建Random对象，就可以得到一系列的随机数，但如果用相同的初值创建Random对象，得到的随机数序列是相同的，也就是说，在程序中我们看到的“随机数”是固定的那些数，起不到随机的作用，针对这个问题，Java设计者们在Random类的Random()构造方法中使用当前时间来初始化Random对象，因为没有任何时刻的时间是相同的，所以就可以减少随机数序列相同的可能性。</p>
<h4 id="学习API的方法"><a href="#学习API的方法" class="headerlink" title="学习API的方法"></a>学习API的方法</h4><blockquote>
<p>作者写得越多，读者就要花费更多的时间来阅读，如果读者并不能从更多的篇幅中学到更多有价值的知识，那就是在浪费读者的宝贵时间。</p>
</blockquote>
<p>最聪明的人是最会利用工具和资源的人，必须要学会查阅文档。</p>
<p>大家根据自己的实际情况，可以提前通读一下JDK文档中大部分类及类中的方法，做到遇到问题时心中有数，也可以暂时不读，只掌握原理，处理过程，解决方法，等到以后有具体的实际需求时，再来查阅JDK文档。</p>
<h3 id="IO-输入输出"><a href="#IO-输入输出" class="headerlink" title="IO/输入输出"></a>IO/输入输出</h3><p>Java语言定义了许多类专门负责各种方式的输入输出，这些类都被放在java.io包中。</p>
<p>程序中，键盘被当做输入文件，显示器被当做输出文件。</p>
<h4 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h4><p>File类是IO包中唯一代表磁盘文件本身的对象，File类定义了一些与平台无关的方法来操纵文件，通过调用File类提供的各种方法，我们能够创建、删除文件、重命名文件，判断文件的读写权限及是否存在，设置和查询文件的最近修改时间。</p>
<p>在java中，目录也被当做file使用，只是多了一些目录特有的功能——可以用list方法列出目录中的文件名。在Unix下的路径分隔符为/，在Dos下的路径分隔符为\，Java可以正确处理Unix和Dos的路径分隔符，即使我们在Windows环境下使用/作为路径分隔符，Java仍然能够正确处理。</p>
<p>注意：delete方法删除由File对象的路径所表示的磁盘文件或目录。如果删除的对象是目录，该目录中的内容必须为空。</p>
<p>File类不能访问文件的内容，即不能够从文件中读取数据或往文件里写数据，它只能对文件本身的属性进行操作。</p>
<h4 id="RandomAccessFile类"><a href="#RandomAccessFile类" class="headerlink" title="RandomAccessFile类"></a>RandomAccessFile类</h4><p>RandomAccessFile类可以说是Java语言中功能最为丰富的文件访问类，它提供了众多的文件访问方法。RandomAccessFile类支持“随机访问”方式，我们可以跳转到文件的任意位置处读写数据。</p>
<p>该类仅限于操作文件，不能访问其它的IO设备，如网络、内存映像等。</p>
<p>RandomAccessFile可以以只读或读写方式打开文件，具体使用哪种方式取决于我们创建RandomAccessFile类对象的构造方式：</p>
<p>new RandomAccessFile(f,”rw”);// 读写方式<br>new RandomAccessFile(f,”r”);// 只读方式</p>
<p>注意：当我们的程序需要以读写的方式打开一个文件时，如果这个文件不存在，程序会为你创建。</p>
<p>String.substring(int beginIndex, int endIndex)方法可以用于取出一个字符串的部分子字符串，要注意的一个细节是：子字符串中的第一个字符对应的是原字符串中的脚标为beginIndex处的字符，但最后的字符对应的是原字符串中的脚标为endIndex-1处的字符，而不是endIndex处的字符。</p>
<h4 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h4><p>流的概念：</p>
<blockquote>
<p>数据流是一串连续不断的数据的集合，就像水管里的水流，在水管的一端一点一点地供水，而在水管的另一端看到的是一股连续不断的水流。数据写入程序可以是一段一段地向数据流管道中写入数据，这些数据段会按先后顺序形成一个长的数据流。对数据读取程序来说，看不到数据流在写入时的分段情况，每次可以读取其中的任意长度的数据，但只能先读取前面的数据后，再读取后面的数据。不管写入时是将数据分多次写入，还是作为一个整体一次写入，读取时的效果都是完全一样的。</p>
</blockquote>
<p>我们将IO流类分为两大类：</p>
<ol>
<li><p>节点流类<br>程序用于直接操作目标设备所对应的类。</p>
</li>
<li><p>包装类（处理流类、过滤流类）<br>一个间接流类去调用节点流类，以达到更加灵活方便地读写各种类型的数据。</p>
</li>
</ol>
<h4 id="InputStream与OutputStream"><a href="#InputStream与OutputStream" class="headerlink" title="InputStream与OutputStream"></a>InputStream与OutputStream</h4><p>程序可以从中连续读取字节的对象叫输入流，用InputStream类完成。<br>程序能向其中连续写入字节的对象叫输出流，用OutputStream类完成。</p>
<p>InputStream与OutputStream对象是两个抽象类，它们下面有许多子类，包括网络、管道、内存、文件等具体的IO设备，如FileInputStream类对应的就是文件输入流，是一个节点流类。</p>
<p>我们将这些节点流类所对应的IO源和目标成为流节点（Node）。</p>
<blockquote>
<p>输入输出类是相对程序而言的，不是代表文件的。</p>
</blockquote>
<p>如要将A文件的内容写入B文件中，<br>程序要对A文件创建一个输入类，对B文件要创建一个输出类。</p>
<p>InputStream定义了Java的输入流模型。该类中的所有方法在遇到错误时都会引发IOException异常，下面是InputStream类中方法的一个简要说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 返回当前输入流中可读的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>	<span class="title">available</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Returns an estimate of the number of bytes that can be <span class="title">read</span> <span class="params">(or skipped over)</span> from <span class="keyword">this</span> input stream without blocking by the next invocation of a method <span class="keyword">for</span> <span class="keyword">this</span> input stream.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 关闭，系统释放与这个流相关的资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>	<span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Closes <span class="keyword">this</span> input stream and releases any system resources associated with the stream.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 在输入流的当前位置处放上一个标志，允许最多再读入readlimit个字节</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>	<span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span></span></span><br><span class="line"><span class="function">Marks the current position in <span class="keyword">this</span> input stream.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 如果当前流支持mark/reset操作就返回true</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>	<span class="title">markSupported</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Tests <span class="keyword">if</span> <span class="keyword">this</span> input stream supports the mark and reset methods.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回下一个输入字节的整型表示，如果返回-1表示遇到流的末尾，结束。</span></span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span>	<span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Reads the next <span class="keyword">byte</span> of data from the input stream.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 读入b.length个字节放到b中bin返回实际读入的字节数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>	<span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span></span><br><span class="line"><span class="function">Reads some number of bytes from the input stream and stores them into the buffer array b.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 把流中的数据读到数组b中从脚标为off开始的len个数组元素中</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>	<span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">Reads up to len bytes of data from the input stream into an array of bytes.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//把输入指针返回到以前所做的标志处</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>	<span class="title">reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Repositions <span class="keyword">this</span> stream to the position at the time the mark method was last called on <span class="keyword">this</span> input stream.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 跳过输入流上的n个字节并返回实际跳过的字节数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span>	<span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function">Skips over and discards n bytes of data from <span class="keyword">this</span> input stream.</span></span><br></pre></td></tr></table></figure>
<p>InputStream是一个抽象类，程序中实际使用的是它的各种子类对象。不是所有的子类都会支持InputStream中定义的某些方法的，如skip，mark，reset等，这些方法支队某些子类有用。</p>
<blockquote>
<p>流是操作系统产生的一种资源。当我们在程序中创建了一个IO流对象，同时系统内也会创建了一个叫流的东西，在这种情况下，计算机内存中实际上产生了两个事物，一个是Java程序中的类的实例对象，一个是系统本身产生的某种资源，窗口、Socket等都是这样的情况，Java垃圾回收器只能管理程序中的类的实例对象，没法去管理系统产生的资源，所以程序需要调用close方法，去通知系统释放其自身产生的资源。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭输出流</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>	<span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Closes <span class="keyword">this</span> output stream and releases any system resources associated with <span class="keyword">this</span> stream.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 彻底完成输出并清空缓冲区</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>	<span class="title">flush</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Flushes <span class="keyword">this</span> output stream and forces any buffered output bytes to be written out.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//将整个字节数组写到输出流中</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>	<span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span></span><br><span class="line"><span class="function">Writes b.length bytes from the specified <span class="keyword">byte</span> array to <span class="keyword">this</span> output stream.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 将字节数组b中的从off开始的len个字节写到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>	<span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">Writes len bytes from the specified <span class="keyword">byte</span> array starting at offset off to <span class="keyword">this</span> output stream.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 将一个字节写到输出流，这里的参数是int类型，它允许write使用表达式而不用强制转换成byte类型。</span></span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span>	<span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">Writes the specified <span class="keyword">byte</span> to <span class="keyword">this</span> output stream.</span></span><br></pre></td></tr></table></figure>
<p>计算机访问外部设备，要比直接访问内存慢得多。使用内存缓冲区有两个方面的好处：</p>
<ol>
<li>提高cpu的使用率</li>
<li>write并没有马上真正写入到外设，我们还有机会回滚部分写入的数据。</li>
</ol>
<p>C语言默认情况下就会使用缓冲区，而在java中，有的类使用率缓冲区，有的类没有使用缓冲区，我们还可以在程序中使用专门的包装类来实现自己的缓冲区。</p>
<p>flush方法就是用于即使在缓冲区没有满的情况下，也将缓冲区的内容强制写入到外设，习惯上称这个过程为刷新。它只对那些使用缓冲区的OutputStream子类有效。如果我们调用了close方法，系统在关闭这个流之前，也会将缓冲区的内容刷新到硬盘文件的。</p>
<blockquote>
<p>读者花更多的时间去开阔自己的知识面和思维，了解更多的原理，而不是花大量时间去死记硬背某些细节和术语，特别是一个类中的每个方法名的具体拼写，具体的参数形式，java中有哪些关键字等这些死板的东西，只要有个印象就足够了。</p>
</blockquote>
<h4 id="FileInputStream与FileOutputStream"><a href="#FileInputStream与FileOutputStream" class="headerlink" title="FileInputStream与FileOutputStream"></a>FileInputStream与FileOutputStream</h4><p>这两个流节点用来操作磁盘文件，在创建一个FileInputStream对象时通过构造方法指定文件的路径和名字，当然这个文件应当是存在和可读的。</p>
<p>在创建一个FileOutputStream对象时指定文件如果存在，将要被覆盖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream inOne = <span class="keyword">new</span> FileInputStream(<span class="string">"hello.test"</span>);</span><br><span class="line">File f = <span class="keyword">new</span> File();</span><br><span class="line">FileInputStream inTwo = <span class="keyword">new</span> FileInputStream(f);</span><br></pre></td></tr></table></figure>
<p>创建一个FileOutputStream对象时，可以为其指定还不存在的文件名，但不能是存在的目录名，也不能是一个已被其他程序打开了的文件。</p>
<p>FileOutputStream先创建输出对象，然后再准备输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		File f = <span class="keyword">new</span> File(<span class="string">"hello.txt"</span>);</span><br><span class="line">		FileOutputStream out = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">		<span class="keyword">byte</span> buf[]=<span class="string">"hello ipcreator"</span>.getBytes();</span><br><span class="line">		out.write(buf);</span><br><span class="line">		out.close();</span><br><span class="line"></span><br><span class="line">		FileInputStream in = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">		<span class="keyword">byte</span> [] contentBuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = in.read(contentBuf);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(buf,<span class="number">0</span>,len));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FileInputStream,FileOutputStream这两个类只提供了对字节或字节数组进行读取的方法，对于字符串的读写，我们还需要进行额外的转换。</p>
<p>FileOutputStream没有使用缓冲区。</p>
<h4 id="Reader与Writer"><a href="#Reader与Writer" class="headerlink" title="Reader与Writer"></a>Reader与Writer</h4><p>Java为字符文本的输入输出专门提供了一套单独的类，Reader和Writer两个抽象类与InputStream，OutputStream两个类相对应，同样，Reader和Writer下面也有许多子类，对具体IO设备进行字符输入输出，如FileReader就是用来读取文件流中的字符。</p>
<p>FileWriter使用了缓冲区。</p>
<h4 id="PipedInputStream与PipedOutputStream"><a href="#PipedInputStream与PipedOutputStream" class="headerlink" title="PipedInputStream与PipedOutputStream"></a>PipedInputStream与PipedOutputStream</h4><p>这两个类主要用来完成线程之间的通信，一个线程的PipedInputStream对象能够从另外一个线程的PipedOutputStream对象中读取数据。</p>
<p>JDK还提供了PipedWriter和PipedReader这两个类来用于字符文本的管道通信。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPipedReader</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Writer writer = <span class="keyword">new</span> Writer();</span><br><span class="line">		Reader reader = <span class="keyword">new</span> Reader();</span><br><span class="line">		Thread writerThread = <span class="keyword">new</span> Thread(writer);</span><br><span class="line">		Thread readerThread = <span class="keyword">new</span> Thread(reader);</span><br><span class="line"></span><br><span class="line">		PipedWriter pipedWriter = writer.getPipedWriter();</span><br><span class="line">		PipedReader pipedReader = reader.getPipedReader();</span><br><span class="line">		pipedWriter.connect(pipedReader);</span><br><span class="line"></span><br><span class="line">		writerThread.start();</span><br><span class="line">		readerThread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> PipedWriter writer = <span class="keyword">new</span> PipedWriter();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> PipedWriter <span class="title">getPipedWriter</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> writer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			writer.write(<span class="string">"hello Reader"</span>);</span><br><span class="line">			writer.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> PipedReader reader = <span class="keyword">new</span> PipedReader();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> PipedReader <span class="title">getPipedReader</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> reader;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			len = reader.read(buf);</span><br><span class="line">			reader.close();</span><br><span class="line">			System.out.println(<span class="keyword">new</span> String(buf,<span class="number">0</span>,len));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用管道流类，可以实现各个程序模块之间的松耦合通信，我们可以灵活地将多个这样的模块的输出流与输入流相连接，以拼装成满足各种应用的程序，而不用对模块内部进行修改。假设有一个使用了管道流的压缩或加密的模块，我们的调用程序只管向该模块的输入流中送入数据，从该模块的输出流中取得数据，就完成了我们数据的压缩或加密，这个模块就像黑匣子一样，我们根本不用去了解它的任何细节。</p>
</blockquote>
<h3 id="ByteArrayInputStream-与ByteArrayOutputStream"><a href="#ByteArrayInputStream-与ByteArrayOutputStream" class="headerlink" title="ByteArrayInputStream 与ByteArrayOutputStream"></a>ByteArrayInputStream 与ByteArrayOutputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayInputStream(<span class="keyword">byte</span>[] buf)</span><br><span class="line">Creates a ByteArrayInputStream so that it uses buf as its buffer array.</span><br><span class="line"></span><br><span class="line">ByteArrayInputStream(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span><br><span class="line">Creates ByteArrayInputStream that uses buf as its buffer array.</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个32字节的缓冲区</span></span><br><span class="line">ByteArrayOutputStream()</span><br><span class="line">Creates a <span class="keyword">new</span> <span class="keyword">byte</span> array output stream.</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据参数指定的大小创建缓冲区，缓冲区的大小在数据过多时能够自动增长</span></span><br><span class="line">ByteArrayOutputStream(<span class="keyword">int</span> size)</span><br><span class="line">Creates a <span class="keyword">new</span> <span class="keyword">byte</span> array output stream, with a buffer capacity of the specified size, in bytes.</span><br></pre></td></tr></table></figure>
<p>这两个流的作用在于，用IO流的方式来完成对字节数组内容的读写，我们为什么不直接读写字节数组呢？在什么情况下该使用这两个类呢？</p>
<blockquote>
<p>内存虚拟文件/内存映像文件，他们是把一块内存虚拟成一个硬盘上的文件，原来该写到硬盘文件上的内容会被写到这个内存中，原来该从一个硬盘文件上读取内容可以改为从内存中直接读取。如果程序在运行过程中药产生一些临时文件，就可以用虚拟文件的方式来实现，我们不用访问硬盘，而是直接访问内存，会提高应用程序的效率。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArrayStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		String temp = <span class="string">"hello ipcreator"</span>;</span><br><span class="line">		<span class="keyword">byte</span>[] src = temp.getBytes();</span><br><span class="line">		ByteArrayInputStream input = <span class="keyword">new</span> ByteArrayInputStream(src);</span><br><span class="line">		ByteArrayOutputStream output = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">		transform(input,output);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(output.toByteArray()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(InputStream in, OutputStream out)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> c =<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((c=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> C=(<span class="keyword">int</span>)Character.toUpperCase(c);</span><br><span class="line">			out.write(C);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArrayReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		StringReader reader = <span class="keyword">new</span> StringReader(<span class="string">"hello arrayreader"</span>);</span><br><span class="line">		StringWriter writer = <span class="keyword">new</span> StringWriter();</span><br><span class="line">		convert(reader,writer);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(writer.toString()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">convert</span><span class="params">(Reader reader, Writer writer)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">char</span> [] charBuff= <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = reader.read(charBuff);</span><br><span class="line">		writer.write(<span class="keyword">new</span> String(charBuff,<span class="number">0</span>,len).toUpperCase());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IO程序代码的复用"><a href="#IO程序代码的复用" class="headerlink" title="IO程序代码的复用"></a>IO程序代码的复用</h4><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]<a href="http://zhibimo.com/read/xiaolai/everyone-can-use-english/chapter6.html" target="_blank" rel="noopener">everyone-can-use-english</a><br>[2]<a href>Java就业教程张孝祥PDF版.pdf</a><br>[3]<a href>Think In  Java(中文第四版).pdf</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Basic-Concept/" rel="tag"><i class="fa fa-tag"></i> Basic Concept</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/English/IPCreator/English/English Pronunciation/" rel="next" title="English Pronunciation">
                  <i class="fa fa-chevron-left"></i> English Pronunciation
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/AI/IPCreator/Technology/AI/Business/views-of-zhouhongyi-on-ai/" rel="prev" title="周鸿袆:通用型的人工智能都是骗子,必须结合垂直领域">
                  周鸿袆:通用型的人工智能都是骗子,必须结合垂直领域 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#On-job-Training-2"><span class="nav-number">1.</span> <span class="nav-text">On job Training[2]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#启发编程思想，培养编程感觉"><span class="nav-number">1.1.</span> <span class="nav-text">启发编程思想，培养编程感觉</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-virtual-machine"><span class="nav-number">1.2.</span> <span class="nav-text">Java virtual machine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-Garbage-Collector"><span class="nav-number">1.3.</span> <span class="nav-text">Java Garbage Collector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pitfall"><span class="nav-number">1.4.</span> <span class="nav-text">Pitfall</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Path"><span class="nav-number">1.4.1.</span> <span class="nav-text">Path</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-Class"><span class="nav-number">1.5.</span> <span class="nav-text">Java Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-Grammar"><span class="nav-number">1.6.</span> <span class="nav-text">Java Grammar</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常量"><span class="nav-number">1.6.1.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#变量"><span class="nav-number">1.6.2.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本数据类型之间的转换"><span class="nav-number">1.6.3.</span> <span class="nav-text">基本数据类型之间的转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法"><span class="nav-number">1.7.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法的重载-overload"><span class="nav-number">1.7.1.</span> <span class="nav-text">方法的重载(overload)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中的运算符"><span class="nav-number">1.8.</span> <span class="nav-text">Java中的运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序的流程控制"><span class="nav-number">1.9.</span> <span class="nav-text">程序的流程控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">1.10.</span> <span class="nav-text">数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象"><span class="nav-number">2.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面向过程"><span class="nav-number">2.1.</span> <span class="nav-text">面向过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象-1"><span class="nav-number">2.2.</span> <span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的比较"><span class="nav-number">2.3.</span> <span class="nav-text">对象的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名对象"><span class="nav-number">2.4.</span> <span class="nav-text">匿名对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的封装"><span class="nav-number">2.5.</span> <span class="nav-text">类的封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法"><span class="nav-number">2.5.1.</span> <span class="nav-text">构造方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC有关的知识"><span class="nav-number">2.6.</span> <span class="nav-text">GC有关的知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法的参数传递"><span class="nav-number">2.7.</span> <span class="nav-text">方法的参数传递</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本数据类型的参数传递"><span class="nav-number">2.7.1.</span> <span class="nav-text">基本数据类型的参数传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用数据类型的参数传递"><span class="nav-number">2.7.2.</span> <span class="nav-text">引用数据类型的参数传递</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static关键字"><span class="nav-number">2.8.</span> <span class="nav-text">static关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#static-变量"><span class="nav-number">2.8.1.</span> <span class="nav-text">static 变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static-方法"><span class="nav-number">2.8.2.</span> <span class="nav-text">static 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态代码块"><span class="nav-number">2.8.3.</span> <span class="nav-text">静态代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单态设计模式"><span class="nav-number">2.8.4.</span> <span class="nav-text">单态设计模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#理解main方法的语法"><span class="nav-number">2.8.5.</span> <span class="nav-text">理解main方法的语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部类"><span class="nav-number">2.8.6.</span> <span class="nav-text">内部类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的继承"><span class="nav-number">2.9.</span> <span class="nav-text">类的继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子类对象实例化过程"><span class="nav-number">2.10.</span> <span class="nav-text">子类对象实例化过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#覆盖父类的方法"><span class="nav-number">2.11.</span> <span class="nav-text">覆盖父类的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final关键字"><span class="nav-number">2.12.</span> <span class="nav-text">final关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类"><span class="nav-number">2.13.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口"><span class="nav-number">2.14.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的多态性"><span class="nav-number">2.15.</span> <span class="nav-text">对象的多态性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的类型转换"><span class="nav-number">2.15.1.</span> <span class="nav-text">对象的类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object类"><span class="nav-number">2.15.2.</span> <span class="nav-text">Object类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多态性"><span class="nav-number">2.15.3.</span> <span class="nav-text">多态性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#匿名内部类"><span class="nav-number">2.15.4.</span> <span class="nav-text">匿名内部类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常"><span class="nav-number">2.16.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#throws关键字"><span class="nav-number">2.16.1.</span> <span class="nav-text">throws关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finally关键字"><span class="nav-number">2.16.2.</span> <span class="nav-text">finally关键字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包"><span class="nav-number">2.17.</span> <span class="nav-text">包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#import"><span class="nav-number">2.17.1.</span> <span class="nav-text">import</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jdk中的常用包"><span class="nav-number">2.17.2.</span> <span class="nav-text">jdk中的常用包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问控制"><span class="nav-number">2.18.</span> <span class="nav-text">访问控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类成员"><span class="nav-number">2.18.1.</span> <span class="nav-text">类成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类"><span class="nav-number">2.18.2.</span> <span class="nav-text">类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java命名习惯"><span class="nav-number">2.19.</span> <span class="nav-text">java命名习惯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用jar文件"><span class="nav-number">2.20.</span> <span class="nav-text">使用jar文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#jar-命令详解"><span class="nav-number">2.20.1.</span> <span class="nav-text">jar 命令详解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程"><span class="nav-number">2.21.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念"><span class="nav-number">2.21.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用Thread类创建线程"><span class="nav-number">2.21.2.</span> <span class="nav-text">用Thread类创建线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用Runnable接口创建多线程"><span class="nav-number">2.21.3.</span> <span class="nav-text">使用Runnable接口创建多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对比"><span class="nav-number">2.21.4.</span> <span class="nav-text">对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#后台线程"><span class="nav-number">2.21.5.</span> <span class="nav-text">后台线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#join联合线程"><span class="nav-number">2.21.6.</span> <span class="nav-text">join联合线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程实践"><span class="nav-number">2.21.7.</span> <span class="nav-text">多线程实践</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程同步"><span class="nav-number">2.21.8.</span> <span class="nav-text">多线程同步</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁问题"><span class="nav-number">2.22.</span> <span class="nav-text">死锁问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程间的通信"><span class="nav-number">2.23.</span> <span class="nav-text">线程间的通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程生命周期"><span class="nav-number">2.24.</span> <span class="nav-text">线程生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-API"><span class="nav-number">2.25.</span> <span class="nav-text">Java API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String类和StringBuffer类"><span class="nav-number">2.25.1.</span> <span class="nav-text">String类和StringBuffer类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本数据类型的对象包装类"><span class="nav-number">2.25.2.</span> <span class="nav-text">基本数据类型的对象包装类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合类"><span class="nav-number">2.26.</span> <span class="nav-text">集合类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Vector类"><span class="nav-number">2.26.1.</span> <span class="nav-text">Vector类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Enumeration接口类"><span class="nav-number">2.26.2.</span> <span class="nav-text">Enumeration接口类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Collection接口"><span class="nav-number">2.26.3.</span> <span class="nav-text">Collection接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Iterator接口"><span class="nav-number">2.26.4.</span> <span class="nav-text">Iterator接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集合类接口的比较"><span class="nav-number">2.26.5.</span> <span class="nav-text">集合类接口的比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hashtable类"><span class="nav-number">2.26.6.</span> <span class="nav-text">Hashtable类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Properties类"><span class="nav-number">2.26.7.</span> <span class="nav-text">Properties类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#System类"><span class="nav-number">2.26.8.</span> <span class="nav-text">System类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runtime类"><span class="nav-number">2.26.9.</span> <span class="nav-text">Runtime类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Date与Calendar、DateFormat类"><span class="nav-number">2.26.10.</span> <span class="nav-text">Date与Calendar、DateFormat类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Math与Random类"><span class="nav-number">2.26.11.</span> <span class="nav-text">Math与Random类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#学习API的方法"><span class="nav-number">2.26.12.</span> <span class="nav-text">学习API的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO-输入输出"><span class="nav-number">2.27.</span> <span class="nav-text">IO/输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#File类"><span class="nav-number">2.27.1.</span> <span class="nav-text">File类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RandomAccessFile类"><span class="nav-number">2.27.2.</span> <span class="nav-text">RandomAccessFile类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#节点流"><span class="nav-number">2.27.3.</span> <span class="nav-text">节点流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InputStream与OutputStream"><span class="nav-number">2.27.4.</span> <span class="nav-text">InputStream与OutputStream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FileInputStream与FileOutputStream"><span class="nav-number">2.27.5.</span> <span class="nav-text">FileInputStream与FileOutputStream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reader与Writer"><span class="nav-number">2.27.6.</span> <span class="nav-text">Reader与Writer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PipedInputStream与PipedOutputStream"><span class="nav-number">2.27.7.</span> <span class="nav-text">PipedInputStream与PipedOutputStream</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ByteArrayInputStream-与ByteArrayOutputStream"><span class="nav-number">2.28.</span> <span class="nav-text">ByteArrayInputStream 与ByteArrayOutputStream</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IO程序代码的复用"><span class="nav-number">2.28.1.</span> <span class="nav-text">IO程序代码的复用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-number">3.</span> <span class="nav-text">Reference</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="IPCreator"
    src="/img/work-hard-life-easy.png">
  <p class="site-author-name" itemprop="name">IPCreator</p>
  <div class="site-description" itemprop="description">Life is a journey.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">1513</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1444</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://blog.163.com/zhuxuanlv@126/" title="http://blog.163.com/zhuxuanlv@126/" rel="noopener" target="_blank">163 Blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">IPCreator</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">26.8m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">405:22</span>
</div>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.5.0
  </div>


<!-- 在网页底部添加网站运行时间 -->
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/24/2019 00:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = " "+dnum+" D ";
        document.getElementById("times").innerHTML = hnum + " H " + mnum + " M " + snum + " S";
    }
setInterval("createtime()",250);
</script>
        
<div class="busuanzi-count">
  <script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  



  <script pjax>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id: 11184,
      el: 'wpac-rating',
      color: 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'C75jI23HEPhTehiFhCvUSbJY-gzGzoHsz',
    appKey: 'qy3Id9srq8HBxwKg3CVSdNNq',
    placeholder: "Just go go",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

    </div>

</body>
</html>
