<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="生命之旅" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-corner-indicator.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: true,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},
    path: 'search.json',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="出处：LBD’s Blog Java中I/O操作主要是指使用Java进行输入，输出操作. Java所有的I/O机制都是基于数据流进行输入输出，这些数据流表示了字符或者字节数据的流动序列。 数据流是一串连续不断的数据的集合，就象水管里的水流，在水管的一端一点一点地供水，而在水管的另一端看到的是一股连续不断的水流。数据写入程序可以是一段、一段地向数据流管道中写入数据，这些数据段会按先后顺序形成一个长">
<meta name="keywords" content="IO">
<meta property="og:type" content="article">
<meta property="og:title" content="The Summary of Java I&#x2F;O">
<meta property="og:url" content="https://hazyman.com/Java/IPCreator/Technology/Program/Java/anatomy-of-java-io/index.html">
<meta property="og:site_name" content="生命之旅">
<meta property="og:description" content="出处：LBD’s Blog Java中I/O操作主要是指使用Java进行输入，输出操作. Java所有的I/O机制都是基于数据流进行输入输出，这些数据流表示了字符或者字节数据的流动序列。 数据流是一串连续不断的数据的集合，就象水管里的水流，在水管的一端一点一点地供水，而在水管的另一端看到的是一股连续不断的水流。数据写入程序可以是一段、一段地向数据流管道中写入数据，这些数据段会按先后顺序形成一个长">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-03-27T09:58:44.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="The Summary of Java I&#x2F;O">
<meta name="twitter:description" content="出处：LBD’s Blog Java中I/O操作主要是指使用Java进行输入，输出操作. Java所有的I/O机制都是基于数据流进行输入输出，这些数据流表示了字符或者字节数据的流动序列。 数据流是一串连续不断的数据的集合，就象水管里的水流，在水管的一端一点一点地供水，而在水管的另一端看到的是一股连续不断的水流。数据写入程序可以是一段、一段地向数据流管道中写入数据，这些数据段会按先后顺序形成一个长">

<link rel="canonical" href="https://hazyman.com/Java/IPCreator/Technology/Program/Java/anatomy-of-java-io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>The Summary of Java I/O | 生命之旅</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">生命之旅</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">常识、专业和价值。</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/IPCreator1833" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hazyman.com/Java/IPCreator/Technology/Program/Java/anatomy-of-java-io/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/logo.jpg">
      <meta itemprop="name" content="IPCreator">
      <meta itemprop="description" content="Life is a journey.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="生命之旅">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          The Summary of Java I/O
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/Java/IPCreator/Technology/Program/Java/anatomy-of-java-io/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Java/IPCreator/Technology/Program/Java/anatomy-of-java-io/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img alt data-src="http://upload-images.jianshu.io/upload_images/1752522-adc85fb95f884363.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>出处：<a href="http://linbingdong.com/" target="_blank" rel="noopener">LBD’s Blog</a></p>
<p>Java中I/O操作主要是指使用Java进行输入，输出操作. Java所有的I/O机制都是基于数据流进行输入输出，这些数据流表示了字符或者字节数据的流动序列。</p>
<p>数据流是一串连续不断的数据的集合，就象水管里的水流，在水管的一端一点一点地供水，而在水管的另一端看到的是一股连续不断的水流。数据写入程序可以是一段、一段地向数据流管道中写入数据，这些数据段会按先后顺序形成一个长的数据流。对数据读取程序来说，看不到数据流在写入时的分段情况，每次可以读取其中的任意长度的数据，但只能先读取前面的数据后，再读取后面的数据（不能随机读取）。不管写入时是将数据分多次写入，还是作为一个整体一次写入，读取时的效果都是完全一样的。</p>
<p>简而言之：数据流是一组有序，有起点和终点的字节的数据序列。包括输入流和输出流。</p>
<p>当程序需要读取数据的时候，就会建立一个通向数据源的连接，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据的时候，就会建立一个通向目的地的连接。</p>
<p>数据流分类：</p>
<p>流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种： 1) 字节流：数据流中最小的数据单元是字节 2) 字符流：数据流中最小的数据单元是字符， Java中的字符是Unicode编码，一个字符占用两个字节。</p>
 <a id="more"></a>
<p> 概览<br>Java.io包中最重要的就是5个类和一个接口。5个类指的是File、OutputStream、InputStream、Writer、Reader；一个接口指的是Serializable。掌握了这些就掌握了Java I/O的精髓了。</p>
<p>Java I/O主要包括如下3层次：</p>
<p>流式部分——最主要的部分。如：OutputStream、InputStream、Writer、Reader等<br>非流式部分——如：File类、RandomAccessFile类和FileDescriptor等类<br>其他——文件读取部分的与安全相关的类，如：SerializablePermission类，以及与本地操作系统相关的文件系统的类，如：FileSystem类和Win32FileSystem类和WinNTFileSystem类。<br>主要类如下：</p>
<p>File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等。<br>InputStream（字节流，二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。<br>OutputStream（字节流，二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。<br>Reader（字符流，文本格式操作）：抽象类，基于字符的输入操作。<br>Writer（字符流，文本格式操作）：抽象类，基于字符的输出操作。<br>RandomAccessFile（随机文件操作）：它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作。<br><img alt data-src="http://upload-images.jianshu.io/upload_images/1752522-adc85fb95f884363.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>I/O流<br>java.io包里有4个基本类：InputStream、OutputStream及Reader、Writer类，它们分别处理字节流和字符流。</p>
<p>其他各种各样的流都是由这4个派生出来的。</p>
<p><img alt data-src="http://upload-images.jianshu.io/upload_images/1752522-ee60b12bd1f9a3dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>按来源/去向分类：</p>
<p>File（文件）： FileInputStream, FileOutputStream, FileReader, FileWriter<br>byte[]：ByteArrayInputStream, ByteArrayOutputStream<br>Char[]: CharArrayReader, CharArrayWriter<br>String: StringBufferInputStream, StringReader, StringWriter<br>网络数据流：InputStream, OutputStream, Reader, Writer<br>InputStream<br>InputStream 为字节输入流，它本身为一个抽象类，必须依靠其子类实现各种功能，此抽象类是表示字节输入流的所有类的超类。 继承自InputStream 的流都是向程序中输入数据的，且数据单位为字节（8bit）；</p>
<p>InputStream是输入字节数据用的类，所以InputStream类提供了3种重载的read方法.Inputstream类中的常用方法：</p>
<p>public abstract int read( )：读取一个byte的数据，返回值是高位补0的int类型值。若返回值=-1说明没有读取到任何字节读取工作结束。<br>public int read(byte b[ ])：读取b.length个字节的数据放到b数组中。返回值是读取的字节数。该方法实际上是调用下一个方法实现的<br>public int read(byte b[ ], int off, int len)：从输入流中最多读取len个字节的数据，存放到偏移量为off的b数组中。<br>public int available( )：返回输入流中可以读取的字节数。注意：若输入阻塞，当前线程将被挂起，如果InputStream对象调用这个方法的话，它只会返回0，这个方法必须由继承InputStream类的子类对象调用才有用，<br>public long skip(long n)：忽略输入流中的n个字节，返回值是实际忽略的字节数, 跳过一些字节来读取<br>public int close( ) ：使用完后，必须对我们打开的流进行关闭。<br>来看看几种不同的InputStream：</p>
<p>FileInputStream把一个文件作为InputStream，实现对文件的读取操作<br>ByteArrayInputStream：把内存中的一个缓冲区作为InputStream使用<br>StringBufferInputStream：把一个String对象作为InputStream<br>PipedInputStream：实现了pipe的概念，主要在线程中使用<br>SequenceInputStream：把多个InputStream合并为一个InputStream<br>OutputStream<br>OutputStream提供了3个write方法来做数据的输出，这个是和InputStream是相对应的。 　　</p>
<p>public void write(byte b[ ])：将参数b中的字节写到输出流。<br>public void write(byte b[ ], int off, int len) ：将参数b的从偏移量off开始的len个字节写到输出流。<br>public abstract void write(int b) ：先将int转换为byte类型，把低字节写入到输出流中。<br>public void flush( ) : 将数据缓冲区中数据全部输出，并清空缓冲区。<br>public void close( ) : 关闭输出流并释放与流相关的系统资源。<br>几种不同的OutputStream：</p>
<p>ByteArrayOutputStream：把信息存入内存中的一个缓冲区中<br>FileOutputStream：把信息存入文件中<br>PipedOutputStream：实现了pipe的概念，主要在线程中使用<br>SequenceOutputStream：把多个OutStream合并为一个OutStream<br>Reader和InputStream类似；Writer和OutputStream类似。</p>
<p>有两个需要注意的：</p>
<p>InputStreamReader ： 从输入流读取字节，在将它们转换成字符。<br>BufferReader :接受Reader对象作为参数，并对其添加字符缓冲器，使用readline()方法可以读取一行。<br>如何选择I/O流<br>确定是输入还是输出<br>输入:输入流 InputStream Reader<br>输出:输出流 OutputStream Writer<br>明确操作的数据对象是否是纯文本<br>是:字符流 Reader，Writer<br>否:字节流 InputStream，OutputStream<br>明确具体的设备。<br>文件：<br>读：FileInputStream,, FileReader,<br>写：FileOutputStream，FileWriter<br>数组：<br>byte[ ]：ByteArrayInputStream, ByteArrayOutputStream<br>char[ ]：CharArrayReader, CharArrayWriter<br>String：<br>StringBufferInputStream(已过时，因为其只能用于String的每个字符都是8位的字符串), StringReader, StringWriter<br>Socket流<br>键盘：用System.in（是一个InputStream对象）读取，用System.out（是一个OutoutStream对象）打印<br>是否需要转换流<br>是，就使用转换流，从Stream转化为Reader、Writer：InputStreamReader，OutputStreamWriter<br>是否需要缓冲提高效率<br>是就加上Buffered：BufferedInputStream, BufferedOuputStream, BufferedReader, BufferedWriter<br>是否需要格式化输出<br>示例代码<br>将标准输入（键盘输入）显示到标准输出（显示器），支持字符。<br>char ch;<br>BufferedReader in = new BufferedReader(new InputStreamReader(System.in));  //将字节流转为字符流，带缓冲<br>try {<br>    while ((ch = (char) in.read()) != -1){<br>        System.out.print(ch);<br>    }<br>} catch (IOException e) {<br>    e.printStackTrace();<br>}<br>将AtomicityTest.java的内容打印到显示器<br>方法一：</p>
<p>BufferedReader in = new BufferedReader(new FileReader(“AtomicityTest.java”));<br>String s;<br>try {<br>    while ((s = in.readLine()) != null){<br>        System.out.println(s);<br>    }<br>    in.close();<br>} catch (IOException e) {<br>    e.printStackTrace();<br>}<br>方法二：</p>
<p>FileReader in = new FileReader(“AtomicityTest.java”);<br>int b;<br>try {<br>    while ((b = in.read()) != -1){<br>        System.out.print((char)b);<br>    }<br>    in.close();<br>} catch (IOException e) {<br>    e.printStackTrace();<br>}<br>方法三：(有可能出现乱码）</p>
<p>FileInputStream in = new FileInputStream(“AtomicityTest.java”);<br>int n = 50;<br>byte[] buffer = new byte[n];<br>try {<br>    while ((in.read(buffer,0,n) != -1 &amp;&amp; n &gt; 0)){<br>        System.out.print(new String(buffer));<br>    }<br>    in.close();<br>} catch (IOException e) {<br>    e.printStackTrace();<br>}<br>将文件A的内容拷贝到文件B<br>FileInputStream in = new FileInputStream(“AtomicityTest.java”);<br>FileOutputStream out = new FileOutputStream(“copy.txt”);<br>int b;<br>while ((b = in.read()) != -1){<br>    out.write(b);<br>}<br>out.flush();<br>in.close();<br>out.close();<br>将标准输入的内容写入文件<br>Scanner in = new Scanner(System.in);<br>FileWriter out = new FileWriter(“systemIn.log”);<br>String s;<br>while (!(s = in.nextLine()).equals(“Q”)){<br>    out.write(s + “\n”);<br>}<br>out.flush();<br>out.close();<br>in.close();</p>
<h2 id="Java-I-O-操作示例"><a href="#Java-I-O-操作示例" class="headerlink" title="Java I/O 操作示例"></a>Java I/O 操作示例</h2><p>给出几个Java I/O 操作的示例代码。</p>
<p>创建文件或目录<br>import java.io.File;<br>import java.io.IOException;<br>public class TestFileIO {<br>    public static void main(String[] args) {<br>        File dir = new File(“dir1”);<br>        dir.mkdir();  //创建目录<br>        File file = new File(dir,”file1”);  //目录加文件名<br>        File file2 = new File(“dir1/file2”);  //完整路径<br>        try {<br>            file.createNewFile();  //创建文件,若存在同名文件,不会覆盖<br>            file2.createNewFile();<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}<br>删除文件<br>import java.io.File;<br>public class TestFileIO {<br>    public static void main(String[] args) {<br>        File file = new File(“dir1/file2”);<br>        if (file.delete()){<br>            System.out.println(file.getName() + “ is deleted!”);<br>        }else {<br>            System.out.println(“File is not deleted!”);<br>        }<br>    }<br>}<br>向文件逐行写入内容(覆盖写）<br>FileOutputStream</p>
<p>import java.io.*;<br>public class TestFileIO {<br>    public static void main(String[] args) throws IOException {<br>        File fout = new File(“dir1/file1”);<br>        FileOutputStream fos = new FileOutputStream(fout);<br>        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(fos));<br>        for (int i = 0; i &lt; 10; i++){<br>            bw.write(“something”);<br>            bw.newLine();<br>        }<br>        bw.close();<br>    }<br>}<br>FileWriter</p>
<p>import java.io.*;<br>public class TestFileIO {<br>    public static void main(String[] args) throws IOException {<br>        File fout = new File(“dir1/file1”);<br>        FileWriter fw = new FileWriter(fout);<br>        for (int i = 0; i &lt; 10; i++){<br>            fw.write(“something” + System.getProperty(“line.separator”));<br>        }<br>        fw.close();<br>    }<br>}<br>PrintWriter</p>
<p>import java.io.*;<br>public class TestFileIO {<br>    public static void main(String[] args) throws IOException {<br>        File fout = new File(“dir1/file1”);<br>        PrintWriter pw = new PrintWriter(new FileWriter(fout));<br>        for (int i = 0; i &lt; 10; i++){<br>            pw.println(“something”);<br>        }<br>        pw.close();<br>    }<br>}<br>OutputStreamWriter</p>
<p>import java.io.*;<br>public class TestFileIO {<br>    public static void main(String[] args) throws IOException {<br>        File fout = new File(“dir1/file1”);<br>        FileOutputStream fos = new FileOutputStream(fout);<br>        OutputStreamWriter osw = new OutputStreamWriter(fos);<br>        for (int i = 0; i &lt; 10; i++) {<br>            osw.write(“something” + System.getProperty(“line.separator”));<br>        }<br>        osw.close();<br>    }<br>}<br>注：<br>往文本文件里写内容用FileWriter即可，比较方便。但是如果要自己定义字符编号和byte-buffer大小的话就要用FileOutputStream。</p>
<p>PrintWriter跟FileWriter的主要区别是PrintWriter可以格式化输出。该类实现了PrintStream的所有print方法。</p>
<p>追加写<br>import java.io.<em>;<br>public class TestFileIO {<br>    public static void main(String[] args) throws IOException {<br>        File fout = new File(“dir1/file1”);<br>        FileOutputStream fos = new FileOutputStream(fout,true);  //跟覆盖写唯一的区别是这里加了个true参数。<br>        OutputStreamWriter osw = new OutputStreamWriter(fos);<br>        for (int i = 0; i &lt; 10; i++) {<br>            osw.write(“something” + System.getProperty(“line.separator”));<br>        }<br>        osw.close();<br>    }<br>}<br>拷贝文件<br>import java.io.</em>;<br>import java.nio.file.Files;<br>import java.nio.file.Path;<br>import java.nio.file.Paths;<br>public class TestFileIO {<br>    public static void main(String[] args) throws IOException {<br>        Path sour = Paths.get(“dir1/file1”);<br>        Path des = Paths.get(“dir1/file2”);<br>        Files.copy(sour,des);   //Files.copy(a,b)。<br>    }<br>}<br>合并多个文件<br>读取多个文件的内容，写入一个文件。</p>
<p>import java.io.*;<br>/**</p>
<ul>
<li>Created by lbd on 2017/1/13.<br>*/<br>public class MergeFiles {<br> public static void main(String[] args) throws IOException {<pre><code>String sourceFile1Path = &quot;dir1/file1&quot;;
String sourceFile2Path = &quot;dir1/file2&quot;;
String mergedFilePath = &quot;dir1/mergedFile.txt&quot;;
File[] files = new File[2];
files[0] = new File(sourceFile1Path);
files[1] = new File(sourceFile2Path);
File mergedFile = new File(mergedFilePath);
mergeFiles(files,mergedFile);
</code></pre> }<br> public static void mergeFiles(File[] files,File mergedFile) throws IOException {<pre><code>FileWriter fw = new FileWriter(mergedFile,true);
BufferedWriter bw = new BufferedWriter(fw);
for (File f : files){
    System.out.println(&quot;merging: &quot; + f.getName());
    FileReader fr = new FileReader(f);
    BufferedReader br = new BufferedReader(fr);
    String aLine;
    while ((aLine = br.readLine()) != null){
        bw.write(aLine);
        bw.newLine();
    }
    br.close();
}
bw.close();
</code></pre> }<br>}<br>移动文件<br>调用的是File.renameTo()方法。</li>
</ul>
<p>import java.io.*;<br>public class MoveFile {<br>    public static void main(String[] args) throws IOException {<br>        File f1 = new File(“dir1/file1”);<br>        File f2 = new File(“dir1/dir2/file3”);  //dir2目录必须存在,否则无法移动成功<br>        f1.renameTo(f2);<br>    }<br>}<br>对文件内容排序<br>file1内容如下：</p>
<p>dog<br>cat<br>–windows<br>–kankan<br>pps<br>game<br>–annot be guaranteed<br>as it is, generally speaking,<br>–impossible to make any hard gu<br>arantees in the p<br>–resence of unsynchr<br>对行进行排序，以上面的文本为例，排序后arantees in the p应该在第一行</p>
<p>import java.io.*;<br>import java.util.ArrayList;<br>import java.util.Collections;<br>/**</p>
<ul>
<li>Created by lbd on 2017/1/13.<br>*/<br>public class TestJavaIO {<br> public static void main(String[] args) throws IOException {<pre><code>File fin = new File(&quot;file1&quot;);
File fout = new File(&quot;file2&quot;);
String s;
FileWriter fw = new FileWriter(fout);
FileReader fr = new FileReader(fin);
BufferedReader br = new BufferedReader(fr);
BufferedWriter bw = new BufferedWriter(fw);
ArrayList&lt;String&gt; al = new ArrayList&lt;&gt;();
while ((s = br.readLine()) != null ){
    if (!s.trim().startsWith(&quot;-&quot;) &amp;&amp; s.trim().length() &gt; 0){
        al.add(s);
    }
}
Collections.sort(al);
for (String line : al){
    bw.write(line);
    bw.newLine();
    bw.write(&quot;------------------------------&quot;);
    bw.newLine();
}
br.close();
bw.close();
</code></pre> }<br>}<br>file2内容如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arantees in the p</span><br><span class="line">------------------------------</span><br><span class="line">as it is, generally speaking,</span><br><span class="line">------------------------------</span><br><span class="line">cat</span><br><span class="line">------------------------------</span><br><span class="line">dog</span><br><span class="line">------------------------------</span><br><span class="line">game</span><br><span class="line">------------------------------</span><br><span class="line">pps</span><br><span class="line">------------------------------</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Java-I-O底层是如何工作的？"><a href="#Java-I-O底层是如何工作的？" class="headerlink" title="Java I/O底层是如何工作的？"></a><a href="http://www.importnew.com/14111.html" target="_blank" rel="noopener">Java I/O底层是如何工作的？</a></h2><p>本博文主要讨论I/O在底层是如何工作的。本文服务的读者，迫切希望了解Java I/O操作是在机器层面如何进行映射，以及应用运行时硬件都做了什么。假定你熟悉基本的I/O操作，比如通过Java I/O API读写文件。这些内容不在本文的讨论范围。</p>
<p>目录</p>
<p>缓存处理和内核vs用户空间<br>虚拟内存<br>内存分页<br>面向文件、块的I/O<br>文件锁定<br>面向流的I/O<br>缓存处理和内核vs用户空间</p>
<p>缓冲与缓冲的处理方式,是所有I/O操作的基础。术语“输入、输出”只对数据移入和移出缓存有意义。任何时候都要把它记在心中。通常，进程执行操作系统的I/O请求包括数据从缓冲区排出（写操作）和数据填充缓冲区（读操作）。这就是I/O的整体概念。在操作系统内部执行这些传输操作的机制可以非常复杂，但从概念上讲非常简单。我们将在文中用一小部分来讨论它。</p>
<p>上图显示了一个简化的“逻辑”图，它表示块数据如何从外部源，例如一个磁盘，移动到进程的存储区域（例如RAM）中。首先，进程要求其缓冲通过read()系统调用填满。这个系统调用导致内核向磁盘控 制硬件发出一条命令要从磁盘获取数据。磁盘控制器通过DMA直接将数据写入内核的内存缓冲区，不需要主CPU进一步帮助。当请求read()操作时，一旦磁盘控制器完成了缓存的填 写，内核从内核空间的临时缓存拷贝数据到进程指定的缓存中。</p>
<p>有一点需要注意，在内核试图缓存及预取数据时，内核空间中进程请求的数据可能已经就绪了。如果这样，进程请求的数据会被拷贝出来。如果数据不可用，则进程被挂起。内核将把数据读入内存。</p>
<p>虚拟内存</p>
<p>你可能已经多次听说过虚拟内存了。让我再介绍一下。</p>
<p>所有现代操作系统都使用虚拟内存。虚拟内存意味着人工或者虚拟地址代替物理（硬件RAM）内存地址。虚拟地址有两个重要优势：</p>
<p>多个虚拟地址可以映射到相同的物理地址。<br>一个虚拟地址空间可以大于实际可用硬件内存。<br>在上面介绍中，从内核空间拷贝到最终用户缓存看起来增加了额外的工作。为什么不告诉磁盘控制器直接发送数据到用户空间的缓存呢？好吧，这是由虚拟内存实现的。用到了上面的优势1。</p>
<p>通过将内核空间地址映射到相同的物理地址作为一个用户空间的虚拟地址，DMA硬件（只能访问物理内存地址）可以填充缓存。这个缓存同时对内核和用户空间进程可见。<br><img alt data-src="http://incdn1.b0.upaiyun.com/2014/12/3efe3d5db9fe2e9bee8b0e27c9de60d3.png"></p>
<p>这就消除了内核和用户空间之间的拷贝，但是需要内核和用户缓冲区使用相同的页面对齐方式。缓冲区必须使用的块大小的倍数磁盘控制器（通常是512字节的磁盘扇区）。操作系统将其内存地址空间划分为页面，这是固定大小的字节组。这些内存页总是磁盘块大小的倍数和通常为2倍（简化寻址）。典型的内存页面大小是1024、2048和4096字节。虚拟和物理内存页面大小总是相同的。</p>
<p>内存分页</p>
<p>为了支持虚拟内存的第2个优势（拥有大于物理内 存的可寻址空间）需要进行虚拟内存分页（通常称为页交换）。这种机制凭借虚拟内存空间的页可以持久保存在外部磁盘存储，从而为其他虚拟页放入物理内存提供了空间。本质上讲，物理内存担当了分页区域的缓存。分页区是磁盘上的空间，内存页的内容被强迫交换出物理内存时会保存到这里。</p>
<p>调整内存页面大小为磁盘块大小的倍数，让内核可以直接发送指令到磁盘控制器硬件，将内存页写到磁盘或者在需要时重新加载。事实证明，所有的磁盘I/O操作都是在页面级别上完成的。这是数据在现代分页操作系统上在磁盘与物理内存之间移动的唯一方式。</p>
<p>现代CPU包含一个名为内存管理单元（MMU）的子系统。这 个设备逻辑上位于CPU与物理内存之间。它包含从虚拟地址向物理内存地址转化的映射信息。当CPU引用一个内存位置时，MMU决定哪些页需要驻留（通常通过移位或屏蔽地址的某些位）以及转化虚拟页号到物理页号（由硬件实现，速度奇快）。</p>
<p>面向文件、块I/O</p>
<p>文件I/O总是发生在文件系统的上下文切换中。文件系统跟磁盘是完全不同的事物。磁盘按段存储数据，每段512字节。它是硬件设备，对保存的文件语义一无所知。它们只是提供了一定数量的可以保存数据的插槽。从这方面来说，一个磁盘的段与 内存分页类似。它们都有统一的大小并且是个可寻址的大数组。</p>
<p>另一方面，文件系统是更高层抽象。文件系统是安排和翻译保存磁盘（或其它可随机访问，面向块的设备）数据的一种特殊方法。你写的代码几乎总是与文件系统交互，而不与磁盘直接交互。文件系统定义了文件名、路径、文件、文件属性等抽象。</p>
<p>一个文件系统组织（在硬盘中）了一系列均匀大小的数据块。有些块保存元信息，如空闲块的映射、目录、索引等。其它块包含实际的文件数据。单个文件的元信息描述哪些块包含文件数据、数据结束位置、最后更新时间等。当用户进程发送请求来读取文件数据时，文件系统实现准确定位数据在磁盘上的位置。然后采取行动将这些磁盘扇区放入内存中。</p>
<p>文件系统也有页的概念，它的大小可能与一个基本内存页面大小相同或者是它的倍数。典型的文件系统页面大小范围从2048到8192字节，并且总是一个基本内存页面大小的倍数。</p>
<p>分页文件系统执行I/O可以归结为以下逻辑步骤：</p>
<p>确定请求跨越了哪些文件系统分页（磁盘段的集合）。磁盘上的文件内容及元数据可能分布在多个文件系统页面上，这些页面可能是不连续的。<br>分配足够多的内核空间内存页面来保存相同的文件系统页面。<br>建立这些内存分页与磁盘上文件系统分页的映射。<br>对每一个内存分页产生分页错误。<br>虚拟内存系统陷入分页错误并且调度pagins（页面调入），通过从磁盘读取内容来验证这些页面。<br>一旦pageins完成，文件系统分解原始数据来提取请求的文件内容或属性信息。<br>需要注意的是，这个文件系统数据将像其它内存页一样被缓存起来。在随后的I/O请求中，一些数据或所有文件数据仍然保存在物理内存中，可以直接重用不需要从磁盘重读。</p>
<p>文件锁定</p>
<p>文件加锁是一种机制，一个进程可以阻止其它进程访问一个文件或限制其它进程访问该文件。虽然名为“文件锁定”，意味着锁定整个文件（经常做的）。锁定通常可以在一个更细粒度的水平。随着粒度下降到字节级，文件的区域通常会被锁定。锁与特定文件相关联，起始于文件的指定字节位置并运行到指定的字节范围。这一点很重要，因为它允许多个进程协作访问文件的特定区域而不妨碍别的进程在文件其它位置操作。</p>
<p>文件锁有两种形式：共享和独占。多个共享锁可以同时在相同的文件区域有效。另一方面，独占锁要求没有其它锁对请求的区域有效。</p>
<p>流I/O</p>
<p>并非所有的I/O是面向块的。还有流I/O，它是管道的原型，必须顺序访问I/O数据流的字节。常见的数据流有TTY（控制台）设备、打印端口和网络连接。</p>
<p>数据流通常但不一定比块设备慢，提供间歇性输入。大多数操作系统允许在非阻塞模式下工作。允许一个进程检查数据流的输入是否可用，不必在不可用时发生阻塞。这种管理允许进程在输入到达时进行处理，在输入流空闲时可以执行其他功能。</p>
<p>比非阻塞模式更进一步的是有条件的选择（readiness selection）。它类似于非阻塞模式（并且通常建立在非阻塞模式基础上），但是减轻了操作系统检查流是否就绪准的负担。操作系统可以被告知观察流集合，并向进程返回哪个流准备好的指令。这种能力允许进程通过利用操作系统返回 的准备信息，使用通用代码和单个线程复用多个活动流。这种方式被广泛用于网络服务器，以便处理大量的网络连接。准备选择对于大容量扩展是至关重要的。</p>
<p>到此为止，对这个非常复杂的话题有一大堆技术术语。</p>
<p>如果你有想法和疑问，请给给我发评论。</p>
<p>学习快乐！！</p>
<p>原文链接： howtodoinjava 翻译： ImportNew.com - liken<br>译文链接： <a href="http://www.importnew.com/14111.html" target="_blank" rel="noopener">http://www.importnew.com/14111.html</a><br>[ 转载请保留原文出处、译者和译文链接。]</p>
<h2 id="Java-I-O-操作及优化建议"><a href="#Java-I-O-操作及优化建议" class="headerlink" title="Java I/O 操作及优化建议"></a>Java I/O 操作及优化建议</h2><p>原文出处： <a href="http://www.importnew.com/16481.html" target="_blank" rel="noopener">IBM － 周明耀</a></p>
<p>Java I/O</p>
<p>I/O，即 Input/Output(输入/输出) 的简称。就 I/O 而言，概念上有 5 种模型：blocking I/O，nonblocking I/O，I/O multiplexing (select and poll)，signal driven I/O (SIGIO)，asynchronous I/O (the POSIX aio_functions)。不同的操作系统对上述模型支持不同，UNIX 支持 IO 多路复用。不同系统叫法不同，freebsd 里面叫 kqueue，Linux 叫 epoll。而 Windows2000 的时候就诞生了 IOCP 用以支持 asynchronous I/O。</p>
<p>Java 是一种跨平台语言，为了支持异步 I/O，诞生了 NIO，Java1.4 引入的 NIO1.0 是基于 I/O 复用的，它在各个平台上会选择不同的复用方式。Linux 用的 epoll，BSD 上用 kqueue，Windows 上是重叠 I/O。</p>
<p>Java I/O 的相关方法如下所述：</p>
<p>同步并阻塞 (I/O 方法)：服务器实现模式为一个连接启动一个线程，每个线程亲自处理 I/O 并且一直等待 I/O 直到完成，即客户端有连接请求时服务器端就需要启动一个线程进行处理。但是如果这个连接不做任何事情就会造成不必要的线程开销，当然可以通过线程池机制改善这个缺点。I/O 的局限是它是面向流的、阻塞式的、串行的一个过程。对每一个客户端的 Socket 连接 I/O 都需要一个线程来处理，而且在此期间，这个线程一直被占用，直到 Socket 关闭。在这期间，TCP 的连接、数据的读取、数据的返回都是被阻塞的。也就是说这期间大量浪费了 CPU 的时间片和线程占用的内存资源。此外，每建立一个 Socket 连接时，同时创建一个新线程对该 Socket 进行单独通信 (采用阻塞的方式通信)。这种方式具有很快的响应速度，并且控制起来也很简单。在连接数较少的时候非常有效，但是如果对每一个连接都产生一个线程无疑是对系统资源的一种浪费，如果连接数较多将会出现资源不足的情况；<br>同步非阻塞 (NIO 方法)：服务器实现模式为一个请求启动一个线程，每个线程亲自处理 I/O，但是另外的线程轮询检查是否 I/O 准备完毕，不必等待 I/O 完成，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求时才启动一个线程进行处理。NIO 则是面向缓冲区，非阻塞式的，基于选择器的，用一个线程来轮询监控多个数据传输通道，哪个通道准备好了 (即有一组可以处理的数据) 就处理哪个通道。服务器端保存一个 Socket 连接列表，然后对这个列表进行轮询，如果发现某个 Socket 端口上有数据可读时，则调用该 Socket 连接的相应读操作；如果发现某个 Socket 端口上有数据可写时，则调用该 Socket 连接的相应写操作；如果某个端口的 Socket 连接已经中断，则调用相应的析构方法关闭该端口。这样能充分利用服务器资源，效率得到大幅度提高；<br>异步非阻塞 (AIO 方法，JDK7 发布)：服务器实现模式为一个有效请求启动一个线程，客户端的 I/O 请求都是由操作系统先完成了再通知服务器应用去启动线程进行处理，每个线程不必亲自处理 I/O，而是委派操作系统来处理，并且也不需要等待 I/O 完成，如果完成了操作系统会另行通知的。该模式采用了 Linux 的 epoll 模型。<br>在连接数不多的情况下，传统 I/O 模式编写较为容易，使用上也较为简单。但是随着连接数的不断增多，传统 I/O 处理每个连接都需要消耗一个线程，而程序的效率，当线程数不多时是随着线程数的增加而增加，但是到一定的数量之后，是随着线程数的增加而减少的。所以传统阻塞式 I/O 的瓶颈在于不能处理过多的连接。非阻塞式 I/O 出现的目的就是为了解决这个瓶颈。非阻塞 IO 处理连接的线程数和连接数没有联系，例如系统处理 10000 个连接，非阻塞 I/O 不需要启动 10000 个线程，你可以用 1000 个，也可以用 2000 个线程来处理。因为非阻塞 IO 处理连接是异步的，当某个连接发送请求到服务器，服务器把这个连接请求当作一个请求“事件”，并把这个“事件”分配给相应的函数处理。我们可以把这个处理函数放到线程中去执行，执行完就把线程归还，这样一个线程就可以异步的处理多个事件。而阻塞式 I/O 的线程的大部分时间都被浪费在等待请求上了。</p>
<p>Java NIO</p>
<p>Java.nio 包是 Java 在 1.4 版本之后新增加的包，专门用来提高 I/O 操作的效率。</p>
<p>表 1 所示是 I/O 与 NIO 之间的对比内容。</p>
<p>表 1. I/O VS NIO</p>
<p>I/O    NIO<br>面向流    面向缓冲<br>阻塞 IO    非阻塞 IO<br>无    选择器<br>NIO 是基于块 (Block) 的，它以块为基本单位处理数据。在 NIO 中，最为重要的两个组件是缓冲 Buffer 和通道 Channel。缓冲是一块连续的内存块，是 NIO 读写数据的中转地。通道标识缓冲数据的源头或者目的地，它用于向缓冲读取或者写入数据，是访问缓冲的接口。Channel 是一个双向通道，即可读，也可写。Stream 是单向的。应用程序不能直接对 Channel 进行读写操作，而必须通过 Buffer 来进行，即 Channel 是通过 Buffer 来读写数据的。</p>
<p>使用 Buffer 读写数据一般遵循以下四个步骤：</p>
<p>写入数据到 Buffer；<br>调用 flip() 方法；<br>从 Buffer 中读取数据；<br>调用 clear() 方法或者 compact() 方法。<br>当向 Buffer 写入数据时，Buffer 会记录下写了多少数据。一旦要读取数据，需要通过 flip() 方法将 Buffer 从写模式切换到读模式。在读模式下，可以读取之前写入到 Buffer 的所有数据。</p>
<p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用 clear() 或 compact() 方法。clear() 方法会清空整个缓冲区。compact() 方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p>
<p>Buffer 有多种类型，不同的 Buffer 提供不同的方式操作 Buffer 中的数据。</p>
<p>图 1 Buffer 接口层次图</p>
<p><img alt data-src="http://ww3.sinaimg.cn/mw690/b254dc71gw1euwt5ygfecj208606jaa2.jpg"></p>
<p>Buffer 写数据有两种情况：</p>
<p>从 Channel 写到 Buffer，如例子中 Channel 从文件中读取数据，写到 Channel；<br>直接调用 put 方法，往里面写数据。<br>从 Buffer 中读取数据有两种方式：</p>
<p>从 Buffer 读取数据到 Channel；<br>使用 get() 方法从 Buffer 中读取数据。<br>Buffer 的 rewin 方法将 position 设回 0，所以你可以重读 Buffer 中的所有数据。limit 保持不变，仍然表示能从 Buffer 中读取多少个元素（byte、char 等）。</p>
<p>clear() 和 compact() 方法</p>
<p>一旦读完 Buffer 中的数据，需要让 Buffer 准备好再次被写入。可以通过 clear() 或 compact() 方法来完成。</p>
<p>如果调用的是 clear() 方法，position 将被设回 0，limit 被设置成 capacity 的值。换句话说，Buffer 被清空了。Buffer 中的数据并未清除，只是这些标记告诉我们可以从哪里开始往 Buffer 里写数据。</p>
<p>如果 Buffer 中有一些未读的数据，调用 clear() 方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。如果 Buffer 中仍有未读的数据，且后续还需要这些数据，但是此时想要先写些数据，那么使用 compact() 方法。compact() 方法将所有未读的数据拷贝到 Buffer 起始处。然后将 position 设到最后一个未读元素正后面。limit 属性依然像 clear() 方法一样，设置成 capacity。现在 Buffer 准备好写数据了，但是不会覆盖未读的数据。</p>
<p>Buffer 参数</p>
<p>Buffer 有 3 个重要的参数：位置 (position)、容量 (capacity) 和上限 (limit)。</p>
<p>capacity 是指 Buffer 的大小，在 Buffer 建立的时候已经确定。</p>
<p>limit 当 Buffer 处于写模式，指还可以写入多少数据；处于读模式，指还有多少数据可以读。</p>
<p>position 当 Buffer 处于写模式，指下一个写数据的位置；处于读模式，当前将要读取的数据的位置。每读写一个数据，position+1，也就是 limit 和 position 在 Buffer 的读/写时的含义不一样。当调用 Buffer 的 flip 方法，由写模式变为读模式时，limit(读)=position(写)，position(读) =0。</p>
<p>散射&amp;聚集</p>
<p>NIO 提供了处理结构化数据的方法，称之为散射 (Scattering) 和聚集 (Gathering)。散射是指将数据读入一组 Buffer 中，而不仅仅是一个。聚集与之相反，指将数据写入一组 Buffer 中。散射和聚集的基本使用方法和对单个 Buffer 操作时的使用方法相当类似。在散射读取中，通道依次填充每个缓冲区。填满一个缓冲区后，它就开始填充下一个，在某种意义上，缓冲区数组就像一个大缓冲区。在已知文件具体结构的情况下，可以构造若干个符合文件结构的 Buffer，使得各个 Buffer 的大小恰好符合文件各段结构的大小。此时，通过散射读的方式可以一次将内容装配到各个对应的 Buffer 中，从而简化操作。如果需要创建指定格式的文件，只要先构造好大小合适的 Buffer 对象，使用聚集写的方式，便可以很快地创建出文件。清单 1 以 FileChannel 为例，展示如何使用散射和聚集读写结构化文件。</p>
<p>清单 1. 使用散射和聚集读写结构化文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.UnsupportedEncodingException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line">public class NIOScatteringandGathering &#123;</span><br><span class="line"> public void createFiles(String TPATH)&#123;</span><br><span class="line"> try &#123;</span><br><span class="line"> ByteBuffer bookBuf = ByteBuffer.wrap(&quot;java 性能优化技巧&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">ByteBuffer autBuf = ByteBuffer.wrap(&quot;test&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">int booklen = bookBuf.limit();</span><br><span class="line">int autlen = autBuf.limit();</span><br><span class="line">ByteBuffer[] bufs = new ByteBuffer[]&#123;bookBuf,autBuf&#125;;</span><br><span class="line">File file = new File(TPATH);</span><br><span class="line">if(!file.exists())&#123;</span><br><span class="line">try &#123;</span><br><span class="line">file.createNewFile();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">FileOutputStream fos = new FileOutputStream(file);</span><br><span class="line">FileChannel fc = fos.getChannel();</span><br><span class="line">fc.write(bufs);</span><br><span class="line">fos.close();</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ByteBuffer b1 = ByteBuffer.allocate(booklen);</span><br><span class="line">ByteBuffer b2 = ByteBuffer.allocate(autlen);</span><br><span class="line">ByteBuffer[] bufs1 = new ByteBuffer[]&#123;b1,b2&#125;;</span><br><span class="line">File file1 = new File(TPATH);</span><br><span class="line">try &#123;</span><br><span class="line">FileInputStream fis = new FileInputStream(file);</span><br><span class="line">FileChannel fc = fis.getChannel();</span><br><span class="line">fc.read(bufs1);</span><br><span class="line">String bookname = new String(bufs1[0].array(),&quot;utf-8&quot;);</span><br><span class="line">String autname = new String(bufs1[1].array(),&quot;utf-8&quot;);</span><br><span class="line">System.out.println(bookname+&quot; &quot;+autname);</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line"> NIOScatteringandGathering nio = new NIOScatteringandGathering();</span><br><span class="line"> nio.createFiles(&quot;C:\\1.TXT&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出如下清单 2 所示。</p>
<p>清单 2. 运行结果</p>
<blockquote>
<p>java 性能优化技巧 test</p>
</blockquote>
<p>清单 3 所示代码对传统 I/O、基于 Byte 的 NIO、基于内存映射的 NIO 三种方式进行了性能上的对比，使用一个有 400 万数据的文件的读、写操作耗时作为评测依据。</p>
<p>清单 3. I/O 的三种方式对比试验<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedInputStream;</span><br><span class="line">import java.io.BufferedOutputStream;</span><br><span class="line">import java.io.DataInputStream;</span><br><span class="line">import java.io.DataOutputStream;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.IntBuffer;</span><br><span class="line">import java.nio.MappedByteBuffer;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line">public class NIOComparator &#123;</span><br><span class="line"> public void IOMethod(String TPATH)&#123;</span><br><span class="line"> long start = System.currentTimeMillis();</span><br><span class="line"> try &#123;</span><br><span class="line">DataOutputStream dos = new DataOutputStream(</span><br><span class="line"> new BufferedOutputStream(new FileOutputStream(new File(TPATH))));</span><br><span class="line">for(int i=0;i&lt;4000000;i++)&#123;</span><br><span class="line">dos.writeInt(i);//写入 4000000 个整数</span><br><span class="line">&#125;</span><br><span class="line">if(dos!=null)&#123;</span><br><span class="line">dos.close();</span><br><span class="line">&#125;</span><br><span class="line"> &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line"> &#125; catch (IOException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> long end = System.currentTimeMillis();</span><br><span class="line"> System.out.println(end - start);</span><br><span class="line"> start = System.currentTimeMillis();</span><br><span class="line"> try &#123;</span><br><span class="line">DataInputStream dis = new DataInputStream(</span><br><span class="line"> new BufferedInputStream(new FileInputStream(new File(TPATH))));</span><br><span class="line">for(int i=0;i&lt;4000000;i++)&#123;</span><br><span class="line">dis.readInt();</span><br><span class="line">&#125;</span><br><span class="line">if(dis!=null)&#123;</span><br><span class="line">dis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> end = System.currentTimeMillis();</span><br><span class="line"> System.out.println(end - start);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public void ByteMethod(String TPATH)&#123;</span><br><span class="line"> long start = System.currentTimeMillis();</span><br><span class="line"> try &#123;</span><br><span class="line">FileOutputStream fout = new FileOutputStream(new File(TPATH));</span><br><span class="line">FileChannel fc = fout.getChannel();//得到文件通道</span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(4000000*4);//分配 Buffer</span><br><span class="line">for(int i=0;i&lt;4000000;i++)&#123;</span><br><span class="line">byteBuffer.put(int2byte(i));//将整数转为数组</span><br><span class="line">&#125;</span><br><span class="line">byteBuffer.flip();//准备写</span><br><span class="line">fc.write(byteBuffer);</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"> long end = System.currentTimeMillis();</span><br><span class="line"> System.out.println(end - start);</span><br><span class="line"></span><br><span class="line"> start = System.currentTimeMillis();</span><br><span class="line"> FileInputStream fin;</span><br><span class="line">try &#123;</span><br><span class="line">fin = new FileInputStream(new File(TPATH));</span><br><span class="line">FileChannel fc = fin.getChannel();//取得文件通道</span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(4000000*4);//分配 Buffer</span><br><span class="line">fc.read(byteBuffer);//读取文件数据</span><br><span class="line">fc.close();</span><br><span class="line">byteBuffer.flip();//准备读取数据</span><br><span class="line">while(byteBuffer.hasRemaining())&#123;</span><br><span class="line">byte2int(byteBuffer.get(),byteBuffer.get(),byteBuffer.get(),byteBuffer.get());//将 byte 转为整数</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"> end = System.currentTimeMillis();</span><br><span class="line"> System.out.println(end - start);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public void mapMethod(String TPATH)&#123;</span><br><span class="line"> long start = System.currentTimeMillis();</span><br><span class="line"> //将文件直接映射到内存的方法</span><br><span class="line"> try &#123;</span><br><span class="line">FileChannel fc = new RandomAccessFile(TPATH,&quot;rw&quot;).getChannel();</span><br><span class="line">IntBuffer ib = fc.map(FileChannel.MapMode.READ_WRITE, 0, 4000000*4).asIntBuffer();</span><br><span class="line">for(int i=0;i&lt;4000000;i++)&#123;</span><br><span class="line">ib.put(i);</span><br><span class="line">&#125;</span><br><span class="line">if(fc!=null)&#123;</span><br><span class="line">fc.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"> long end = System.currentTimeMillis();</span><br><span class="line"> System.out.println(end - start);</span><br><span class="line"></span><br><span class="line"> start = System.currentTimeMillis();</span><br><span class="line"> try &#123;</span><br><span class="line">FileChannel fc = new FileInputStream(TPATH).getChannel();</span><br><span class="line">MappedByteBuffer lib = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());</span><br><span class="line">lib.asIntBuffer();</span><br><span class="line">while(lib.hasRemaining())&#123;</span><br><span class="line">lib.get();</span><br><span class="line">&#125;</span><br><span class="line">if(fc!=null)&#123;</span><br><span class="line">fc.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"> end = System.currentTimeMillis();</span><br><span class="line"> System.out.println(end - start);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static byte[] int2byte(int res)&#123;</span><br><span class="line"> byte[] targets = new byte[4];</span><br><span class="line"> targets[3] = (byte)(res &amp; 0xff);//最低位</span><br><span class="line"> targets[2] = (byte)((res&gt;&gt;8)&amp;0xff);//次低位</span><br><span class="line"> targets[1] = (byte)((res&gt;&gt;16)&amp;0xff);//次高位</span><br><span class="line"> targets[0] = (byte)((res&gt;&gt;&gt;24));//最高位，无符号右移</span><br><span class="line"> return targets;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static int byte2int(byte b1,byte b2,byte b3,byte b4)&#123;</span><br><span class="line"> return ((b1 &amp; 0xff)&lt;&lt;24)|((b2 &amp; 0xff)&lt;&lt;16)|((b3 &amp; 0xff)&lt;&lt;8)|(b4 &amp; 0xff);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line"> NIOComparator nio = new NIOComparator();</span><br><span class="line"> nio.IOMethod(&quot;c:\\1.txt&quot;);</span><br><span class="line"> nio.ByteMethod(&quot;c:\\2.txt&quot;);</span><br><span class="line"> nio.ByteMethod(&quot;c:\\3.txt&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>清单 3 运行输出如清单 4 所示。</p>
<p>清单 4. 运行输出</p>
<blockquote>
<p>1139<br>906<br>296<br>157<br>234<br>125</p>
</blockquote>
<p>除上述描述及清单 3 所示代码以外，NIO 的 Buffer 还提供了一个可以直接访问系统物理内存的类 DirectBuffer。DirectBuffer 继承自 ByteBuffer，但和普通的 ByteBuffer 不同。普通的 ByteBuffer 仍然在 JVM 堆上分配空间，其最大内存受到最大堆的限制，而 DirectBuffer 直接分配在物理内存上，并不占用堆空间。在对普通的 ByteBuffer 访问时，系统总是会使用一个“内核缓冲区”进行间接的操作。而 DirectrBuffer 所处的位置，相当于这个“内核缓冲区”。因此，使用 DirectBuffer 是一种更加接近系统底层的方法，所以，它的速度比普通的 ByteBuffer 更快。DirectBuffer 相对于 ByteBuffer 而言，读写访问速度快很多，但是创建和销毁 DirectrBuffer 的花费却比 ByteBuffer 高。DirectBuffer 与 ByteBuffer 相比较的代码如清单 5 所示。</p>
<p>清单 5. DirectBuffer VS ByteBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line">public class DirectBuffervsByteBuffer &#123;</span><br><span class="line"> public void DirectBufferPerform()&#123;</span><br><span class="line"> long start = System.currentTimeMillis();</span><br><span class="line"> ByteBuffer bb = ByteBuffer.allocateDirect(500);//分配 DirectBuffer</span><br><span class="line"> for(int i=0;i&lt;100000;i++)&#123;</span><br><span class="line"> for(int j=0;j&lt;99;j++)&#123;</span><br><span class="line"> bb.putInt(j);</span><br><span class="line"> &#125;</span><br><span class="line"> bb.flip();</span><br><span class="line"> for(int j=0;j&lt;99;j++)&#123;</span><br><span class="line"> bb.getInt(j);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> bb.clear();</span><br><span class="line"> long end = System.currentTimeMillis();</span><br><span class="line"> System.out.println(end-start);</span><br><span class="line"> start = System.currentTimeMillis();</span><br><span class="line"> for(int i=0;i&lt;20000;i++)&#123;</span><br><span class="line"> ByteBuffer b = ByteBuffer.allocateDirect(10000);//创建 DirectBuffer</span><br><span class="line"> &#125;</span><br><span class="line"> end = System.currentTimeMillis();</span><br><span class="line"> System.out.println(end-start);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public void ByteBufferPerform()&#123;</span><br><span class="line"> long start = System.currentTimeMillis();</span><br><span class="line"> ByteBuffer bb = ByteBuffer.allocate(500);//分配 DirectBuffer</span><br><span class="line"> for(int i=0;i&lt;100000;i++)&#123;</span><br><span class="line"> for(int j=0;j&lt;99;j++)&#123;</span><br><span class="line"> bb.putInt(j);</span><br><span class="line"> &#125;</span><br><span class="line"> bb.flip();</span><br><span class="line"> for(int j=0;j&lt;99;j++)&#123;</span><br><span class="line"> bb.getInt(j);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> bb.clear();</span><br><span class="line"> long end = System.currentTimeMillis();</span><br><span class="line"> System.out.println(end-start);</span><br><span class="line"> start = System.currentTimeMillis();</span><br><span class="line"> for(int i=0;i&lt;20000;i++)&#123;</span><br><span class="line"> ByteBuffer b = ByteBuffer.allocate(10000);//创建 ByteBuffer</span><br><span class="line"> &#125;</span><br><span class="line"> end = System.currentTimeMillis();</span><br><span class="line"> System.out.println(end-start);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line"> DirectBuffervsByteBuffer db = new DirectBuffervsByteBuffer();</span><br><span class="line"> db.ByteBufferPerform();</span><br><span class="line"> db.DirectBufferPerform();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行输出如清单 6 所示。</p>
<p>清单 6. 运行输出</p>
<blockquote>
<p>920<br>110<br>531<br>390<br>由清单 6 可知，频繁创建和销毁 DirectBuffer 的代价远远大于在堆上分配内存空间。使用参数-XX:MaxDirectMemorySize=200M –Xmx200M 在 VM Arguments 里面配置最大 DirectBuffer 和最大堆空间，代码中分别请求了 200M 的空间，如果设置的堆空间过小，例如设置 1M，会抛出错误如清单 7 所示。</p>
</blockquote>
<p>清单 7. 运行错误</p>
<blockquote>
<p>Error occurred during initialization of VM<br>Too small initial heap for new size specified</p>
</blockquote>
<p>DirectBuffer 的信息不会打印在 GC 里面，因为 GC 只记录了堆空间的内存回收。可以看到，由于 ByteBuffer 在堆上分配空间，因此其 GC 数组相对非常频繁，在需要频繁创建 Buffer 的场合，由于创建和销毁 DirectBuffer 的代码比较高昂，不宜使用 DirectBuffer。但是如果能将 DirectBuffer 进行复用，可以大幅改善系统性能。清单 8 是一段对 DirectBuffer 进行监控代码。</p>
<p>清单 8. 对 DirectBuffer 监控代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class monDirectBuffer &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">Class c = Class.forName(&quot;java.nio.Bits&quot;);//通过反射取得私有数据</span><br><span class="line">Field maxMemory = c.getDeclaredField(&quot;maxMemory&quot;);</span><br><span class="line">maxMemory.setAccessible(true);</span><br><span class="line">Field reservedMemory = c.getDeclaredField(&quot;reservedMemory&quot;);</span><br><span class="line">reservedMemory.setAccessible(true);</span><br><span class="line">synchronized(c)&#123;</span><br><span class="line">Long maxMemoryValue = (Long)maxMemory.get(null);</span><br><span class="line">Long reservedMemoryValue = (Long)reservedMemory.get(null);</span><br><span class="line">System.out.println(&quot;maxMemoryValue=&quot;+maxMemoryValue);</span><br><span class="line">System.out.println(&quot;reservedMemoryValue=&quot;+reservedMemoryValue);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (SecurityException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (NoSuchFieldException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行输出如清单 9 所示。</p>
<p>清单 9. 运行输出</p>
<blockquote>
<p>maxMemoryValue=67108864<br>reservedMemoryValue=0</p>
</blockquote>
<p>由于 NIO 使用起来较为困难，所以许多公司推出了自己封装 JDK NIO 的框架，例如 Apache 的 Mina，JBoss 的 Netty，Sun 的 Grizzly 等等，这些框架都直接封装了传输层的 TCP 或 UDP 协议，其中 Netty 只是一个 NIO 框架，它不需要 Web 容器的额外支持，也就是说不限定 Web 容器。</p>
<p>Java AIO</p>
<p>AIO 相关的类和接口：</p>
<p>java.nio.channels.AsynchronousChannel：标记一个 Channel 支持异步 IO 操作；<br>java.nio.channels.AsynchronousServerSocketChannel：ServerSocket 的 AIO 版本，创建 TCP 服务端，绑定地址，监听端口等；<br>java.nio.channels.AsynchronousSocketChannel：面向流的异步 Socket Channel，表示一个连接；<br>java.nio.channels.AsynchronousChannelGroup：异步 Channel 的分组管理，目的是为了资源共享。一个 AsynchronousChannelGroup 绑定一个线程池，这个线程池执行两个任务：处理 IO 事件和派发 CompletionHandler。AsynchronousServerSocketChannel 创建的时候可以传入一个 AsynchronousChannelGroup，那么通过 AsynchronousServerSocketChannel 创建的 AsynchronousSocketChannel 将同属于一个组，共享资源；<br>java.nio.channels.CompletionHandler：异步 IO 操作结果的回调接口，用于定义在 IO 操作完成后所作的回调工作。AIO 的 API 允许两种方式来处理异步操作的结果：返回的 Future 模式或者注册 CompletionHandler，推荐用 CompletionHandler 的方式，这些 handler 的调用是由 AsynchronousChannelGroup 的线程池派发的。这里线程池的大小是性能的关键因素。<br>这里举一个程序范例，简单介绍一下 AIO 如何运作。</p>
<p>清单 10. 服务端程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line">import java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line">import java.nio.channels.CompletionHandler;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line">public class SimpleServer &#123;</span><br><span class="line">public SimpleServer(int port) throws IOException &#123;</span><br><span class="line">final AsynchronousServerSocketChannel listener =</span><br><span class="line"> AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(port));</span><br><span class="line">//监听消息，收到后启动 Handle 处理模块</span><br><span class="line">listener.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() &#123;</span><br><span class="line">public void completed(AsynchronousSocketChannel ch, Void att) &#123;</span><br><span class="line">listener.accept(null, this);// 接受下一个连接</span><br><span class="line">handle(ch);// 处理当前连接</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void failed(Throwable exc, Void attachment) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void handle(AsynchronousSocketChannel ch) &#123;</span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(32);//开一个 Buffer</span><br><span class="line">try &#123;</span><br><span class="line"> ch.read(byteBuffer).get();//读取输入</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"> // TODO Auto-generated catch block</span><br><span class="line"> e.printStackTrace();</span><br><span class="line">&#125; catch (ExecutionException e) &#123;</span><br><span class="line"> // TODO Auto-generated catch block</span><br><span class="line"> e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">byteBuffer.flip();</span><br><span class="line">System.out.println(byteBuffer.get());</span><br><span class="line">// Do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>清单 11. 客户端程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line">public class SimpleClientClass &#123;</span><br><span class="line">private AsynchronousSocketChannel client;</span><br><span class="line">public SimpleClientClass(String host, int port) throws IOException,</span><br><span class="line">                                    InterruptedException, ExecutionException &#123;</span><br><span class="line"> this.client = AsynchronousSocketChannel.open();</span><br><span class="line"> Future&lt;?&gt; future = client.connect(new InetSocketAddress(host, port));</span><br><span class="line"> future.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void write(byte b) &#123;</span><br><span class="line"> ByteBuffer byteBuffer = ByteBuffer.allocate(32);</span><br><span class="line"> System.out.println(&quot;byteBuffer=&quot;+byteBuffer);</span><br><span class="line"> byteBuffer.put(b);//向 buffer 写入读取到的字符</span><br><span class="line"> byteBuffer.flip();</span><br><span class="line"> System.out.println(&quot;byteBuffer=&quot;+byteBuffer);</span><br><span class="line"> client.write(byteBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>清单 12.Main 函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class AIODemoTest &#123;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testServer() throws IOException, InterruptedException &#123;</span><br><span class="line"> SimpleServer server = new SimpleServer(9021);</span><br><span class="line"> Thread.sleep(10000);//由于是异步操作，所以睡眠一定时间，以免程序很快结束</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testClient() throws IOException, InterruptedException, ExecutionException &#123;</span><br><span class="line">SimpleClientClass client = new SimpleClientClass(&quot;localhost&quot;, 9021);</span><br><span class="line"> client.write((byte) 11);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">AIODemoTest demoTest = new AIODemoTest();</span><br><span class="line">try &#123;</span><br><span class="line">demoTest.testServer();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">demoTest.testClient();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (ExecutionException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后续会专门出文章具体深入介绍 AIO 的源代码、设计理念、设计模式等等。</p>
<p>结束语</p>
<p>I/O 与 NIO 一个比较重要的区别是我们使用 I/O 的时候往往会引入多线程，每个连接使用一个单独的线程，而 NIO 则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。而由于 NIO 的非阻塞需要一直轮询，比较消耗系统资源，所以异步非阻塞模式 AIO 就诞生了。本文对 I/O、NIO、AIO 等三种输入输出操作方式进行一一介绍，力求通过简单的描述和实例让读者能够掌握基本的操作、优化方法。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/IO/" rel="tag"><i class="fa fa-tag"></i> IO</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/Java/IPCreator/Technology/Program/Java/improper-code-of-chinese-in-java/" rel="next" title="The Way of Solving Charset Problem in Java.">
                  <i class="fa fa-chevron-left"></i> The Way of Solving Charset Problem in Java.
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/Java/IPCreator/Technology/Program/Java/ram-of-java/" rel="prev" title="Things about JVM Memory">
                  Things about JVM Memory <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-I-O-操作示例"><span class="nav-number">1.</span> <span class="nav-text">Java I/O 操作示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-I-O底层是如何工作的？"><span class="nav-number">2.</span> <span class="nav-text">Java I/O底层是如何工作的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-I-O-操作及优化建议"><span class="nav-number">3.</span> <span class="nav-text">Java I/O 操作及优化建议</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="IPCreator"
    src="/img/logo.jpg">
  <p class="site-author-name" itemprop="name">IPCreator</p>
  <div class="site-description" itemprop="description">Life is a journey.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">1505</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1441</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://blog.163.com/zhuxuanlv@126/" title="http://blog.163.com/zhuxuanlv@126/" rel="noopener" target="_blank">163 Blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">IPCreator</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">26.6m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">402:43</span>
</div>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.5.0
  </div>


<!-- 在网页底部添加网站运行时间 -->
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/24/2019 00:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = " "+dnum+" D ";
        document.getElementById("times").innerHTML = hnum + " H " + mnum + " M " + snum + " S";
    }
setInterval("createtime()",250);
</script>
        
<div class="busuanzi-count">
  <script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  



  <script pjax>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id: 11184,
      el: 'wpac-rating',
      color: 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'C75jI23HEPhTehiFhCvUSbJY-gzGzoHsz',
    appKey: 'qy3Id9srq8HBxwKg3CVSdNNq',
    placeholder: "Just go go",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

    </div>

</body>
</html>
