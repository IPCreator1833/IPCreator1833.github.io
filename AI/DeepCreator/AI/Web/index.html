<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="生命之旅" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-corner-indicator.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: true,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},
    path: 'search.json',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="WWW是环球信息网的缩写，（亦作“Web”、“WWW”、“’W3’”，英文全称为“World Wide Web”），中文名字为“万维网”，”环球网”等，常简称为Web。 分为Web客户端和Web服务器程序。 WWW可以让Web客户端（常用浏览器）访问浏览Web服务器上的页面。 是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局">
<meta name="keywords" content="Web,Net">
<meta property="og:type" content="article">
<meta property="og:title" content="Web">
<meta property="og:url" content="https://hazyman.com/AI/DeepCreator/AI/Web/index.html">
<meta property="og:site_name" content="生命之旅">
<meta property="og:description" content="WWW是环球信息网的缩写，（亦作“Web”、“WWW”、“’W3’”，英文全称为“World Wide Web”），中文名字为“万维网”，”环球网”等，常简称为Web。 分为Web客户端和Web服务器程序。 WWW可以让Web客户端（常用浏览器）访问浏览Web服务器上的页面。 是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-08-28T04:37:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Web">
<meta name="twitter:description" content="WWW是环球信息网的缩写，（亦作“Web”、“WWW”、“’W3’”，英文全称为“World Wide Web”），中文名字为“万维网”，”环球网”等，常简称为Web。 分为Web客户端和Web服务器程序。 WWW可以让Web客户端（常用浏览器）访问浏览Web服务器上的页面。 是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局">

<link rel="canonical" href="https://hazyman.com/AI/DeepCreator/AI/Web/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Web | 生命之旅</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">生命之旅</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">常识、专业和价值。</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/IPCreator1833" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hazyman.com/AI/DeepCreator/AI/Web/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/logo.jpg">
      <meta itemprop="name" content="IPCreator">
      <meta itemprop="description" content="Life is a journey.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="生命之旅">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Web
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AI/" itemprop="url" rel="index">
                    <span itemprop="name">AI</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/AI/DeepCreator/AI/Web/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/AI/DeepCreator/AI/Web/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img alt="web20180726.jpg" data-src="http://p53s4d2qk.bkt.clouddn.com/web20180726.jpg?imageMogr2/thumbnail/!75p"></p>
<blockquote>
<p><a href="https://baike.baidu.com/item/www/109924?fr=aladdin&amp;fromid=215515&amp;fromtitle=%E4%B8%87%E7%BB%B4%E7%BD%91" target="_blank" rel="noopener">WWW是环球信息网的缩写，（亦作“Web”、“WWW”、“’W3’”，英文全称为“World Wide Web”），中文名字为“万维网”，”环球网”等，常简称为Web</a>。 分为Web客户端和Web服务器程序。 WWW可以让Web客户端（常用浏览器）访问浏览Web服务器上的页面。 是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。</p>
</blockquote>
<a id="more"></a>
<script src="//code.jquery.com/jquery-3.2.1.min.js"></script>

<p><link href="/path/to/jquery.fancybox.min.css" rel="stylesheet"></p>
<script src="/path/to/jquery.fancybox.min.js"></script>

<p><a data-fancybox="gallery" href="big_1.jpg"><br>    <img data-src="http://pd4vb8220.bkt.clouddn.com/raydalio-5step-process-1024x878.jpg"><br>    <img data-src="http://pd4vb8220.bkt.clouddn.com/elephant20180808.jpg"><br></a></p>
<h2 id="HTML基础自学作业"><a href="#HTML基础自学作业" class="headerlink" title="HTML基础自学作业"></a><a href="http://hukui-blog.logdown.com/posts/2017/01/23/html-based-learning-jobs" target="_blank" rel="noopener">HTML基础自学作业</a></h2><p>主要结构一览表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">标签	描述</span><br><span class="line">&lt;html&gt;	定义 HTML 文档。</span><br><span class="line">&lt;body&gt;	定义文档的主体。</span><br><span class="line">&lt;h1&gt;to&lt;h6&gt;	定义 HTML 标题</span><br><span class="line">&lt;hr&gt;	定义水平线。</span><br><span class="line">&lt;p&gt;	定义段落</span><br><span class="line">&lt;a href=url&gt;&lt;/a&gt;	定义链接</span><br><span class="line">&lt;img src=&quot;url&quot; alt=&quot;message&quot;&gt;	定义图片 alt 是替换文本，在图像无法显示的时候代替显示。</span><br><span class="line">&lt;br&gt;	换行</span><br><span class="line">&lt;!-- &gt;	定义注释。(commod+？)</span><br><span class="line">&lt;table&gt;	定义表格</span><br><span class="line">&lt;caption&gt;	定义表格标题。</span><br><span class="line">&lt;th&gt;	定义表格的表头。</span><br><span class="line">&lt;tr&gt;	定义表格的行。</span><br><span class="line">&lt;td&gt;	定义表格单元。</span><br><span class="line">&lt;thead&gt;	定义表格的页眉。</span><br><span class="line">&lt;tbody&gt;	定义表格的主体。</span><br><span class="line">&lt;tfoot&gt;	定义表格的页脚。</span><br><span class="line">&lt;div&gt;	定义块，块里面可以包含很多元素</span><br><span class="line">&lt;span&gt;	定义行内的小元素</span><br></pre></td></tr></table></figure></p>
<p>理解的部分<br>html 标签要有头有尾，只有个别标签比如<br>、<hr>是单独出现的以后规范的写法是<br><hr>。<br>html 的样式建议都用 css 来确定，这样分工明确，不会乱，html 只负责内容</p>
<div> 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。特别是结合 bootstrap 的 grid 系统，即便可以做到么满足所有排版需求。<br><br>准问答部分：<br>div / span 的不同<br>div 是定义块，可以包含许多内容，标题，表哥，图片，链接等等都可以，主要的作用可以用来统一设定样式。块级元素在浏览器显示时，通常会以新行来开始（和结束）。一个比较主要的用途是文档布局。<br><br>span可以理解为行内的小块，范围要小很多。显示时通常不会以新行开始。在行内突出某些文字或者图标样式的时候使用。<br><br>div 和 span 的本质是没有区别的，区别主要在于是否换行。<br><br>class 与 id 的不同<br>class 是类别，在 CSS 中的定义方法是用.来开头，如 .css{属性：属性值}。使用方法为 class=”<em>“，可以反复使用。<br><br>id是一个标识，在 CSS 中的定义方法是用#来开头，如 #css{属性：属性值}。使用方法为id=”</em>“在一个页面中仅能被使用一次。<br><br>p 与 br 的不同<br>p 是段落的标记，包裹的内容为段落正文，如果没有 br 的话，是不会自动换行的，br 的作用就是换行。<br><br>如何使用 table 排版<br>使用 table 排版貌似不推荐了，bootstrap 的 Grid （格栅系统）貌似更好用。<br><br>新增内容<br>无序列表<ul><br>The<ul> tag defines an unordered (bulleted) list.<br>Use the<ul> tag together with the <li>tag to create unordered lists.<br><br>## <a href="http://hukui-blog.logdown.com/posts/2017/01/23/css-learning" target="_blank" rel="noopener">CSS 学习总结</a><br><br>我理解的CSS<br><br>CSS 可以理解为装潢，HTML可以理解为毛胚房，如果只有 HTML，不加 CSS 的话，虽然也能住，但是不美观。CSS 的左右就是根据不同的 HTML 区块进行装修，比如地面铺地板，墙面贴墙纸，卫生间贴瓷砖等等。<br><br>两者的关系也和装修毛胚房类似，开发商负责盖好毛胚房，装修队负责装潢。HTML（负责内容） 和 CSS（负责样式） 的关系也差不多是如此，两者是互相分离的。<br><br>CSS的基础知识<br><br>1. css 的语法结构<br>首先有一个名称（selector，用于查找对应的 css 样式的，比如这个h1，以后只要是h1格式的，都会套用这个设定好的样式），然后才是里面的装饰，装饰的表达方法为装饰类型和具体值property:value，不同类型的装饰用;隔开。<br><br><img alt data-src="http://7xqmjb.com1.z0.glb.clouddn.com/20170113148429351371869.jpg?imageView2/0/format/jpg"><br><br><br>2. seletor 可以用3种方式来命名：<br>网页的基本元素来命名：比如h1,h2,p,等等，这样对应的样式就会发生变化<br>用 id 来命名，用#开头，id 首字母不能是数字。如段落1样式。注意 id 只可以引用一次<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> #para1&#123;…&#125;</span><br><span class="line">&lt;p id=&quot;para1&quot;&gt;Hello World!&lt;/p&gt;</span><br></pre></td></tr></table></figure><br><br>用 class 来命名，用.开头。如居中样式。类可以应用多次<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> .center&#123;...&#125;</span><br><span class="line">&lt;h1 class=&quot;center&quot;&gt;Red and center-aligned heading&lt;/h1&gt;</span><br></pre></td></tr></table></figure><br><br>还可以结合起来使用，比如定义center 这个样式只能在<p>中使用。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> p.center&#123;...&#125;</span><br><span class="line">&lt;p class=&quot;center large&quot;&gt;This paragraph refers to two classes.&lt;/p&gt;</span><br></pre></td></tr></table></figure><br><br>如果用统一的样式，可以合起来写以简化代码，比如 h1,h2和 p 都是居中，红色字体。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> h1, h2, p &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>3. CSS注释<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">注释方法以/* comment */，注释还可以分成多行：快捷键是commod+？</span><br><span class="line"></span><br><span class="line"> p &#123;</span><br><span class="line">    color: red;</span><br><span class="line">    /* This is a single-line comment */</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* This is</span><br><span class="line">a multi-line</span><br><span class="line">comment */</span><br></pre></td></tr></table></figure><br><br>4. Box Model<br>The CSS Box Model有四个部分组成，示意图如下，需要注意的是两个透明的缓冲区，padding 可以理解为内容和边界之间的缓冲区，margin 是表格边界和页面中其他内容的缓冲区。<br><br><img alt data-src="http://7xqmjb.com1.z0.glb.clouddn.com/20170113148429082995340.jpg?imageView2/0/format/jpg"><br><br>代码示例：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> div &#123;</span><br><span class="line">  background-color: orange; #背景颜色为橙色</span><br><span class="line">  width: 500px; #表格宽度为500像素</span><br><span class="line">  border: 25px solid green;# 边界为绿色，宽度为25像素</span><br><span class="line">  padding: 25px; #内容和边界之间的距离为25像素</span><br><span class="line">  margin: 25px; # 表格边界与页面其他内容距离为25像素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>标准问答<br><br>1.margin 与 padding 的差异<br>首先，两者都是透明的，这个要注意，第二，margin 是表格边界和页面中其他内容的距离（外边距），padding 可以理解为内容和边界之间的内边距。<br><br>2.box model 见前文<br>3.为何要使用 em 而非 px 来定义字的大小<br>em 是相对单位长度，px 是绝对单位长度。用 em 的好处就是对 ie 浏览器也能很好的支持。<br><br>4. h1 {margin : 10px 0px 15px 5px;} 的边距<br>margin-top:10px<br>margin-right:0px<br>margin-left:5px<br>margin-bottom:15px<br>注意边距的界定是顺时针，即上右下左<br><br><br>## <a href="http://hukui-blog.logdown.com/posts/2017/03/17/refactor" target="_blank" rel="noopener">为什么要将 CSS 放在最顶层，将 JavaScript 放在最底层？</a><br><br>因为HTML 的运作原理是：<br><br>先下载 HTML 本身。<br>然后浏览器根据 CSS 绘制网页<br>JavaScript 的特效不少都是页面绘制完成后执行<br><br>按照这个顺序，JavaScript 放在最底层有两个好处：<br><br>不影响网页的执行效果<br>JavaScript 比较肥大，放在顶层会影响网页加载速度，放在底层就不会影响网页的显示。<br><br>&gt;如何尽可能减少HTTP Requests?<br><br>为了减少请求次数，就应该吧需要 HTTP Request 请求的文件尽量减少，比如把多个 CSS和JavaScript 合并成一支 CSS / JS。这样只请求一次， Rails 已经帮我们自动处理了。<br><br>其实可以用打电话来类比，比如你现在要去参加一个会议，你需要电话联系会务组询问会议地点、会议时间、是否接送站、是否需要带什么材料等相关的情况。我们打电话到会务组，询问相关情况并得到回复，算一个Request。<br><br>有两种方式：<br><br>每次打电话只问一件事情，比如第一次打电话只问地点。第二次打电话只问时间。第三次打电话只问是否接送站。<br>只打一次电话，但是把所有情况都问清楚。<br>你觉得哪种方式好呢？显然是第二种对吧。嗯，HTTP Request 也是一样的。合并 CSS/JS的目的就是只打一次电话，问清楚所有的事情。<br><br>CDN 是什么<br><br>CDN 用我自己的话来理解就是，在不同的服务器上创建多个网站素材的备份。然后根据访问网站主机的远近，自动选择临近的服务器提供素材，这样 Request 时间会较短。能提升效能。<br><br>可能不恰当的类比：<br><br>&gt;假如我们要买花王的尿不湿，我们把原始主机比作总代理（假设是日本亚马逊），CDN 比作是分销商（国内的天猫、京东等）。<br><br>那么不用 CDN的情况：直接从日本亚马逊上够买，运输挺长时间才能到中国。<br>使用 CDN 的情况：由于京东和天猫上也有一样的产品，我就可以直接从这里买，一两天就到。 那么显然用 CDN 可以大幅度提高效率。<br><br>如何提升自己的网站加载速度？<br><br>&gt;把 CSS 保留在最顶层，JavaScript 移到最底层；<br>使用 CDN 来存储图片素材；<br>利用同一个主机多个域名来突破 HTTP1.1一个域名只有2条连线的限制。<br><br><br>## <a href="http://lixiaolai.com/2016/06/25/makecs-html-css/" target="_blank" rel="noopener">快速学习 HTML 和 CSS</a><br><br>无论什么东西，快速了解都是有可能的，之后就要通过反复使用、反复操作获得并磨炼熟练程度。很多人被误导，总是以为“一定要学到一定程度才算学会，才可以拿出手……” 这是肤浅的。要尽快掌握“最少必要知识”（MAKE），然后就开始行动、开始践行…… 真正的熟练，只能在践行之中通过试错、改进、总结、纠正等必要的环节才能获得。<br><br>1. HTML/CSS 都是了解一句话之后就可以开始写的<br><br>HTML 是什么东西呢？一句话就够了 —— 真用不着非得读完一本书才能开始行动。<br><br>&gt;HTML 是用来在纯文本内添加各种标记（用尖括号括起来的标记，叫做“TAG”），以便让浏览器能以正确的格式显示那些内容的“语言”。<br><br>所以，假设你在 HTML 里写的是这样的：<br><br></p><p> This is the first paragraph.</p><br><p> This is the second paragraph.</p><br><p> This is a <strong>word</strong> marked as strong.</p><br><p> This is a <em>word</em> marked as emphasized.</p><br><br>然后浏览器会将其显示成这样子：<br><br>This is the first paragraph.<br>This is the second paragraph.<br>This is a word marked as strong.<br>This is a word marked as emphasized.<br><br>格式（Format），通常很简陋，只包括字体大小、字体加重、倾斜、删除线、下划线等等；另外一个词叫样式（Style），除了最基本的格式之外，还可以包括更多的细节，行间距、字间距、背景色等等……<br><br>那么，CSS 是什么呢？<br><br>CSS 就是用来批量指定标签内容样式的方法。<br><br>你只要在 HTML 文件里加上这么一句：<br><br><style>strong {color: blue;}</style><br><br>那么整个文档里的所有被标记为“加重”的文字（<strong>）就都显示为蓝色（blue）了…… 当然你还可以为所有加重的文字加上更多的样式：<br><br><style><br>strong {<br>font-family: “Courier New”;<br>font-size: 20px;<br>border: yellow solid 1px;<br>padding: 3px;<br>margin: 5px;<br>}<br></style><br><br>其实很直观的，不是吗？<br><br>2. 快速体验<br><br>打开 Safari，输入以下网址（将来还是推荐使用 Firefox 或者 Chrome 的，只不过，现在先用 Safari 玩玩……）：<br><br><a href="http://www.catb.org/esr/faqs/smart-questions.html" target="_blank" rel="noopener">http://www.catb.org/esr/faqs/smart-questions.html</a><br><br>这是篇工程师必须熟读、牢记的文章 —— 事实上，你读过之后就知道了，无论是谁，不管哪一个行业，其实都应该深入了解这篇文章的。<br><br>网页打开之后，打开之后，你会看到一个相对格式、样式都极端朴素的文档。<br><br>基本上，任意一个浏览器，无论是 Safari, 还是 Chrome, Firefox, Opera, 它们的一些基础快捷键都是一样的，比如，都可以用 ⌥-⌘-I 呼出一个“Developer Tools Pane”…… 即便在 Atom 里，也一样可以用这个快捷键 —— 因为 Atom 本身也是个基于 Chromium 的浏览器。<br><br>如果你没有安装 Safari 以外的浏览器，建议你把几个常用的浏览器全都安装好，反正以后都用得着……<br><br>brew cask install chrome<br>brew cask install firefox<br>brew cask install opera<br><br>以下我们先用 Safari 体验一下 HTML 和 CSS 的基本功能…… 请注意：在这个过程中不要刷新浏览器，否则你刚刚做过的改动就都不见了…… 当然，若是你想重新来过，就刷新一下浏览器好了。<br><br>在 Safari 上按下快捷键 ⌥-⌘-I 之后，底部会出现一个工具台，工具台左侧，是当前文档的 HTML 源码，右侧是样式编辑器…… 上面还有一些标签，等你以后再熟悉。<br><br>工具台最低部的左侧，&gt; 标记右边，其实是个命令行输入框，在那里可以输入一些 javascript 命令，比如，你可以输入以下代码试试：<br><br>alert(‘hello’);<br><br>在工具台的左侧，你可以看到 HTML 源码，随时可以点击鼠标右键，再点击 Edit as Html 之后做任意的修改 —— 别怕，你玩不坏它的。随便搞，胡搞瞎搞才好玩……<br><br>在工具台最低部的右侧，有一个 + —— 那是个按钮…… 边上还有个输入框，在里面输入 body，于是，样式编辑器里面就聚焦于 body 这个元素了；这时候，再点一下那个 + 按钮……<br><br>你会看到多了一个 body 的字样，在这一行的下方输入：<br><br>font-family: ‘Courier New’;<br>font-size: large;<br>max-width: 1024px;<br>margin: auto 100px;<br>background-color: #eee;<br><br>当然，冒号后面的值，你都可以（也应该）随便写写多试试…… 比如，max-width: 1024px; 你可以试试 max-width: 768px; …… 在输入的过程中，你会发现 Safari 提供了列表选择功能和自动补全功能 —— 非常方便 —— 甚至，行末的分号是不用输入的……<br><br>好玩吧？你刚刚是重新定义了 body 这个元素里的内容的显示样式。<br><br>文章开头，有一个 Revision History 部分，里面是作者多次修改更新过的记录。在那个暗色的边框上点鼠标右键，选择 Inspect Element ……<br><br>你可以看到，这里面的所有内容都被包在一个<br>的区块里。在右下角的输入框里输入 revhistory，你会看到这个 class 并没有被定义样式。在输入框里已经输入了 revhistory 的情况下，再点一下那个 + 按钮…… 输入：<br><br>display: none;<br><br>…… 那一整块内容“不见了”！是呀，你刚刚要求的麽！<br><br>当我们用浏览器打开一个网页的时候，看到的那些内容是浏览器将从服务器那里获得的 HTML、CSS、JAVASCRIPT 等文件的内容，组合起来解析之后，“渲染”（Render）出来的…… 由于这个原理，Firefox 有一个插件，Greasemonkey，可以编制一些 JAVASCRIPT 脚本，用来改变任意网站的显示样式…… 在以下网站上，可以找到很多别人写好的用户脚本：<br><br>    <a href="https://openuserjs.org/" target="_blank" rel="noopener">https://openuserjs.org/</a><br>    <a href="https://greasyfork.org/en/scripts" target="_blank" rel="noopener">https://greasyfork.org/en/scripts</a><br>    <a href="http://userscripts-mirror.org/" target="_blank" rel="noopener">http://userscripts-mirror.org/</a><br><br>注意：去看看体验一下就好，千万别玩过头了…… 给自己定个闹钟，15 分钟之后要回来干正事儿！ 很多人都是这样，一不小心就被各种东西分散了注意力。<br><br>3. 系统了解 HTML 和 CSS<br><br>行了！尝鲜之后，就需要快速系统了解 HTML 和 CSS 了。先去这个地方：<br><br>    <strong>HTML</strong> <a href="http://www.w3schools.com/html/default.asp" target="_blank" rel="noopener">http://www.w3schools.com/html/default.asp</a><br>    <strong>CSS</strong> <a href="http://www.w3schools.com/css/default.asp" target="_blank" rel="noopener">http://www.w3schools.com/css/default.asp</a><br><br>天了个噜，这个全球访问量最大的网页开发教程网站竟然是用微软的 asp 写的…… 可这背后有个特别重要的道理：<br><br>用的技术是否时髦或者是否过时，在另外一个因素面前完全没有意义：做的事情有没有价值。w3schools 做的事情明显价值很大…… 所以说，在很多的时候，“做对的事情”（do right things），远“比把事情做对”（do things right）重要得多…… 再进一步，技术是用来实现思想的…… 所以，思想更重要。只钻研技术，没有思想，其实很可怜的…… 当然，有丰富的思想却没有技术，那更可怜。<br><br>把 w3schools 上的这两个教程反复看个两三遍，对不止一遍 —— 当然，光看完不够，要每个要素都要逐一实验过。别觉得自己记不住，记不住的原因只有一个，就是用的次数不够多而已。<br><br>4. 读不止一个教程<br><br>一般来说，Documentation，只要看 Official Documentation 一个就够了，把一个 OD 读透就行。很多的时候，所谓的读透，只不过是把结构弄清楚，以便将来随便查询…… 真的不难。<br><br>可若是读教程，那有个好建议就是：<br><br>读一个以上的教程。同一个话题的书，可以读很多本 —— 这绝对是最好的学习习惯之一。<br><br>除了 w3schools 之外，有关 HTML/CSS 的教程，其实很多，你不妨搜索一下：<br><br>    Google Web Fundamentals<br>    MDN Learning web Developement<br><br>也一定有所收获。<br><br>5. 先学范儿，某种意义上也是对的<br><br>第一遍读完 w3schools 上的 HTML Tutorial 之后，要看的是这个：<br><br>HTML(5) Style Guide and Coding Conventions<br><br>凡事儿都需要做得有模有样…… 我一直认为所谓真正的专家，其实是那些真正用专家的标准要求自己的人，而不一定是那些被别人称为专家的人。<br><br>不管学什么，先认真观察那些专家的“范儿”，是有益处的，虽然有很多细节目前做不到，但目标就是将来要做到，所以要提前观察，提前模仿，提前准备…… 以后学各种语言的时候，都要这样，先去看看 Style Guide 和 Coding Conventions……<br><br>6. 学会就能用一辈子：总结、整理、提炼重点<br><br>HTML5 的学习难度，确实比之前的 HTML3 高了一些，因为标签的数量明显增加了很多，并且还有各种浏览器不完全兼容的情况需要注意……<br><br>然而，最终，有些人跨越不过去的原因很简单：<br><br>基本的总结概括能力差而导致的任务量过大……<br><br>上学的时候，学习能力强的同学，经常做各种总结整理，并分享出来…… 殊不知，那些喜欢等别人整理好了再用的人，常常因为缺失了自己动脑总结整理的过程而使得这方面能力逐步下降直至退化为零…… 观察一下生活吧，学习能力差的人，其实说穿了都有统一的局限：<br><br>    总结整理能力差<br>    提炼重点能力差<br><br>其中的第二条，基本上与第一条是互为因果的关系。<br><br>所以，<strong>总结、整理、提炼重点</strong>，这类事情一定要自己动手做。别嫌麻烦，这种事情不是麻烦，是修炼。怕麻烦的人，就是这样在每一个重要的环节上都吃亏却觉得自己占了便宜，乃至于有一天发现自己吃了亏，却完全不知道哪儿吃了亏…… 而上一章中提到的 “Atom 的 Snippets 最好自己动手写” 其实也是一样的道理。<br><br>在 w3schools 上把 HTML Tutorial 反复看两三遍的过程中，要不断地想：<br><br>我有什么办法把这些 Tag 分类，以便在脑子里形成一个清晰的框架呢？重点究竟是什么呢？<br><br>分类的一个基本技巧，虽然简单，很多人却并不知道：<br><br>总是有一些元素最终无法精确分类…… 于是只好放到“其它”这么个无奈而必须的类别中去。<br><br>说实话，“其它”这个无奈的类别，也是很多人总结整理的功夫总也练不成的主要原因，因为他们不知道那个“其它”是最终对谁来说都是因无奈而必要的类别，所以总是觉得自己做得不够好，或者干脆不会做…… 于是因为只好等别人的所以自己的能力不断退化；又由于他们确实不知道这个事实，所以，当他们在别人的分类中看到“其它”类别的时候，竟然反应不过来“那是最终对谁来说都是因无奈而必要的类别”…… 听起来有点绕，但仔细琢磨一下吧，看看是不是这么回事儿？<br><br>如果自己没把握，不妨还是“故技重演”，去网上搜索一下 HTML5 CheatSheet，看看别人是怎么总结、怎么整理、如何分类、如何提炼重点的…… 然后自己再试试。<br><br>甚至为了锻炼自己的总结整理、提炼重点的能力，可以尝试很多种分类方法，比如，随便举个分类方法的例子：<br><br>    隐含的：像 <head><meta name="generator" content="Hexo 3.9.0">、<link>、<meta> 标签所标记的内容，是不会在浏览器上直接显示的……<br>    显示的：大多数 Tag 都是标记内容格式的，所以当然是属于“显示的”……<br><br>“显示的标签中”，也可以继续分类：<br><br>    事关布局的（比如 <header>、<section>、<aside>、<footer> 等等）<br>    事关内容的（比如 <p>、<table>、<blockquote> 等等）<br>    事关提交的（比如 <form>、<input> 等等）<br><br>这种看起来耗时费力的事情，都不要偷懒不去做，因为这是一种虽然简单，但必然有积累效应的能力获取，以后你的总结整理能力会越来越强的，然后基本上最终就是遇到这种情况，“随手一做”就比别人弄得好 —— 当然，显然会学得更快、应用得更好…… 就好像你真的像他们说的那样“更聪明似的”…… 说实话，最终也确实是的。<br><br>可这么简单的东西居然是很大的窍门，那些笨蛋们怎么可能相信呢？<br><br>总结<br><br>HTML 和 CSS 其实都不难，但以后你会知道，真的要足够深入，确实还是挺难的 —— 可之所以难，只不过是因为深入了解需要时间，而大多数人总是舍不得花自己的时间在正地方而已，他们一方面舍不得自己的时间花在正地儿，却又在另一方面把大量的时间浪费在自己都不知道是哪儿的地方 —— 说来也怪。<br><br>HTML 和 CSS 肯定是未来你一定会反复回来研究的东西。到了 2016 年，有一个趋势越来越明显：<br><br>未来一切都是 Web Application……<br><br>现在，无论是网站，还是 APP，还是 PC/Mac 上程序，都可以用 HTML 写了（Github 为了打造一个 Atom 编辑器，甚至之前先写了一个跨平台程序开发框架：Electron…… 早晚你也要学会的）。<br><br>另外，还有一个刻意练习 —— 就是自己动手写 HTML 和 CSS 的<br><br>Atom Snippets…… 对自己认真一点的话，就边练边写罢。<br><br>顺带给大家看个在学习上“洁身自好”的实例：<br><br><a href="http://ricostacruz.com/cheatsheets/" target="_blank" rel="noopener">http://ricostacruz.com/cheatsheets/</a><br><br>看看人家这些年写了多少个 Cheatsheets 给自己……<br><br>…… 另外，细心如我 —— 我特意请王渊源同学把这篇长文朗读了一遍，给大家练听力和口语用，接近 70 分钟的音频，请认真收听、跟读、朗读很多遍。这篇文章会洁净你的心灵，给你一双慧眼，分辨出身边哪些是自力更生的人，哪些是伸手党，这对你的生活品质提高有很大的帮助，因为一切的品质，都来自于选择。<br><br><a href="https://pan.baidu.com/s/1i4QUp1r" target="_blank" rel="noopener">https://pan.baidu.com/s/1i4QUp1r</a><br><br><br>## <a href="http://lixiaolai.com/2016/07/31/makecs-simplest-js-dev-environment/" target="_blank" rel="noopener">最简单直接的 Javascript 开发环境</a><br><br><br>无论学习哪一种编程语言，“搭建开发环境”都是第一步 —— 通常都还比较繁琐。学习 Javascript 就稍微不大一样：<br><br>    只要你的电脑上有浏览器，你就已经有了一个最简的开发环境。<br><br>在这里，我们拿 Google Chrome 作为示例（微软的 IE 就算了罢）。<br><br>        打开 Google Chrome；<br>        用快捷键 Option + Command + i 呼出 Developer’s Panel；<br>        选择 Source 标签；<br>        在左侧边栏选择 Snippets 标签；<br>        创建 .js 文件，比如，test.js；<br>        在中间的代码书写区域编写代码；<br>        使用 Command + Enter 执行代码……<br><br><img alt data-src="http://lixiaolai.com/images/chrome-js-dev.png"><br>很简单吧？<br><br>有了这样的运行环境，就可以开始学习了……<br><br>学什么？怎么学？先从最经典的教材开始呗，<br><br>        硬着头皮一章一章地读完，<br>        每个代码示例都要自己动手敲，直到获得正确结果；<br>        读不懂的地方先放下，接着读下去；<br>        反复回头重新阅读读不懂的地方，实在搞不定再放在一边；<br>        把这本书反复阅读很多遍……<br>        不断整理其中的重要概念，以及重要概念之间的必要联系……<br><br>教材的地址在这里：<br><br>    <a href="http://eloquentjavascript.net/" target="_blank" rel="noopener">http://eloquentjavascript.net/</a><br><br>当然，更为完整的开发环境，你早就搭建过，不是吗？<br><br><br>## <a href="https://book.douban.com/subject/26941639/" target="_blank" rel="noopener">网络是怎样连接的</a><br><br>### 内容简介<br><br>本书以探索之旅的形式，从在浏览器中输入网址开始，一路追踪了到显示出网页内容为止的整个过程，以图配文，讲解了网络的全貌，并重点介绍了实际的网络设备和软件是如何工作的。目的是帮助读者理解网络的本质意义，理解实际的设备和软件，进而熟练运用网络技术。同时，专设了“网络术语其实很简单”专栏，以对话的形式介绍了一些网络术语的词源，颇为生动有趣。<br><br>### 目录<br><br>第1章　浏览器生成消息　　1<br>——探索浏览器内部<br>1.1 生成HTTP请求消息　　5<br>1.1.1 探索之旅从输入网址开始　　5<br>1.1.2 浏览器先要解析URL　　7<br>1.1.3 省略文件名的情况　　9<br>1.1.4 HTTP的基本思路　　10<br>1.1.5 生成HTTP请求消息　　14<br>1.1.6 发送请求后会收到响应　　20<br>1.2 向DNS服务器查询Web服务器的IP地址　　24<br>1.2.1 IP地址的基本知识　　24<br>1.2.2 域名和IP地址并用的理由　　28<br>1.2.3 Socket库提供查询IP地址的功能　　30<br>1.2.4 通过解析器向DNS服务器发出查询　　31<br>1.2.5 解析器的内部原理　　32<br>1.3 全世界DNS服务器的大接力　　35<br>1.3.1 DNS服务器的基本工作　　35<br>1.3.2 域名的层次结构　　38<br>1.3.3 寻找相应的DNS服务器并获取IP地址　　40<br>1.3.4 通过缓存加快DNS服务器的响应　　44<br>1.4 委托协议栈发送消息　　45<br>1.4.1 数据收发操作概览　　45<br>1.4.2 创建套接字阶段　　48<br>1.4.3 连接阶段：把管道接上去　　50<br>1.4.4 通信阶段：传递消息　　52<br>1.4.5 断开阶段：收发数据结束　　53<br>怪杰Resolver　　55<br>第2章　用电信号传输TCP/IP数据　　57<br>——探索协议栈和网卡<br>2.1 创建套接字　　61<br>2.1.1　协议栈的内部结构　　61<br>2.1.2 套接字的实体就是通信控制信息　　63<br>2.1.3 调用socket时的操作　　66<br>2.2 连接服务器　　68<br>2.2.1 连接是什么意思　　68<br>2.2.2 负责保存控制信息的头部　　70<br>2.2.3 连接操作的实际过程　　73<br>2.3 收发数据　　75<br>2.3.1 将HTTP请求消息交给协议栈　　75<br>2.3.2 对较大的数据进行拆分　　78<br>2.3.3 使用ACK号确认网络包已收到　　79<br>2.3.4 根据网络包平均往返时间调整ACK号等待时间　　83<br>2.3.5 使用窗口有效管理ACK号　　84<br>2.3.6 ACK与窗口的合并　　87<br>2.3.7 接收HTTP响应消息　　89<br>2.4 从服务器断开并删除套接字　　90<br>2.4.1 数据发送完毕后断开连接　　90<br>2.4.2 删除套接字　　92<br>2.4.3 数据收发操作小结　　93<br>2.5 IP与以太网的包收发操作　　95<br>2.5.1 包的基本知识　　95<br>2.5.2 包收发操作概览　　99<br>2.5.3 生成包含接收方IP地址的IP头部　　102<br>2.5.4 生成以太网用的MAC头部　　106<br>2.5.5 通过ARP查询目标路由器的MAC地址　　108<br>2.5.6 以太网的基本知识　　111<br>2.5.7 将IP包转换成电或光信号发送出去　　114<br>2.5.8 给网络包再加3个控制数据　　116<br>2.5.9 向集线器发送网络包　　120<br>2.5.10 接收返回包　　123<br>2.5.11 将服务器的响应包从IP传递给TCP　　125<br>2.6 UDP协议的收发操作　　128<br>2.6.1 不需要重发的数据用UDP发送更高效　　128<br>2.6.2 控制用的短数据　　129<br>2.6.3 音频和视频数据　　130<br>插进Socket里的是灯泡还是程序　　132<br>第3章　从网线到网络设备　　135<br>——探索集线器、交换机和路由器<br>3.1 信号在网线和集线器中传输　　139<br>3.1.1 每个包都是独立传输的　　139<br>3.1.2 防止网线中的信号衰减很重要　　140<br>3.1.3 “双绞”是为了抑制噪声　　141<br>3.1.4 集线器将信号发往所有线路　　146<br>3.2 交换机的包转发操作　　149<br>3.2.1 交换机根据地址表进行转发　　149<br>3.2.2 MAC地址表的维护　　153<br>3.2.3 特殊操作　　154<br>3.2.4 全双工模式可以同时进行发送和接收　　155<br>3.2.5 自动协商：确定最优的传输速率　　156<br>3.2.6 交换机可同时执行多个转发操作　　159<br>3.3 路由器的包转发操作　　159<br>3.3.1 路由器的基本知识　　159<br>3.3.2 路由表中的信息　　162<br>3.3.3 路由器的包接收操作　　166<br>3.3.4 查询路由表确定输出端口　　166<br>3.3.5 找不到匹配路由时选择默认路由　　168<br>3.3.6 包的有效期　　169<br>3.3.7 通过分片功能拆分大网络包　　170<br>3.3.8 路由器的发送操作和计算机相同　　172<br>3.3.9 路由器与交换机的关系　　173<br>3.4 路由器的附加功能　　176<br>3.4.1 通过地址转换有效利用IP地址　　176<br>3.4.2 地址转换的基本原理　　178<br>3.4.3 改写端口号的原因　　180<br>3.4.4 从互联网访问公司内网　　181<br>3.4.5 路由器的包过滤功能　　182<br>集线器和路由器，换个名字身价翻倍？　　184<br>第4章　通过接入网进入互联网内部　　187<br>——探索接入网和网络运营商<br>4.1 ADSL接入网的结构和工作方式　　191<br>4.1.1 互联网的基本结构和家庭、公司网络是相同的　　191<br>4.1.2 连接用户与互联网的接入网　　192<br>4.1.3 ADSL Modem将包拆分成信元　　193<br>4.1.4 ADSL将信元“调制”成信号　　197<br>4.1.5 ADSL通过使用多个波来提高速率　　200<br>4.1.6 分离器的作用　　201<br>4.1.7 从用户到电话局　　203<br>4.1.8 噪声的干扰　　204<br>4.1.9 通过DSLAM到达BAS　　205<br>4.2 光纤接入网（FTTH）　　206<br>4.2.1 光纤的基本知识　　206<br>4.2.2 单模与多模　　208<br>4.2.3 通过光纤分路来降低成本　　213<br>4.3 接入网中使用的PPP和隧道　　217<br>4.3.1 用户认证和配置下发　　217<br>4.3.2 在以太网上传输PPP消息　　219<br>4.3.3 通过隧道将网络包发送给运营商　　223<br>4.3.4 接入网的整体工作过程　　225<br>4.3.5 不分配IP地址的无编号端口　　228<br>4.3.6 互联网接入路由器将私有地址转换成公有地址　　228<br>4.3.7 除PPPoE之外的其他方式　　230<br>4.4 网络运营商的内部　　233<br>4.4.1 POP和NOC　　233<br>4.4.2 室外通信线路的连接　　236<br>4.5 跨越运营商的网络包　　238<br>4.5.1 运营商之间的连接　　238<br>4.5.2 运营商之间的路由信息交换　　239<br>4.5.3 与公司网络中自动更新路由表机制的区别　　241<br>4.5.4 IX的必要性　　242<br>4.5.5 运营商如何通过IX互相连接　　243<br>名字叫服务器，其实是路由器　　246<br>第5章　服务器端的局域网中有什么玄机　　249<br>5.1 Web服务器的部署地点　　253<br>5.1.1 在公司里部署Web服务器　　253<br>5.1.2 将Web服务器部署在数据中心　　255<br>5.2 防火墙的结构和原理　　256<br>5.2.1 主流的包过滤方式　　256<br>5.2.2 如何设置包过滤的规则　　256<br>5.2.3 通过端口号限定应用程序　　260<br>5.2.4 通过控制位判断连接方向　　260<br>5.2.5 从公司内网访问公开区域的规则　　262<br>5.2.6 从外部无法访问公司内网　　262<br>5.2.7 通过防火墙　　263<br>5.2.8 防火墙无法抵御的攻击　　264<br>5.3 通过将请求平均分配给多台服务器来平衡负载　　265<br>5.3.1 性能不足时需要负载均衡　　265<br>5.3.2 使用负载均衡器分配访问　　266<br>5.4 使用缓存服务器分担负载　　270<br>5.4.1 如何使用缓存服务器　　270<br>5.4.2 缓存服务器通过更新时间管理内容　　271<br>5.4.3 最原始的代理——正向代理　　276<br>5.4.4 正向代理的改良版——反向代理　　278<br>5.4.5 透明代理　　279<br>5.5 内容分发服务　　280<br>5.5.1 利用内容分发服务分担负载　　280<br>5.5.2 如何找到最近的缓存服务器　　282<br>5.5.3 通过重定向服务器分配访问目标　　285<br>5.5.4 缓存的更新方法会影响性能　　287<br>当通信线路变成局域网　　291<br>第6章　请求到达Web服务器，响应返回浏览器　　293<br>——短短几秒的“漫长旅程”迎来终点<br>6.1 服务器概览　　297<br>6.1.1 客户端与服务器的区别　　297<br>6.1.2 服务器程序的结构　　297<br>6.1.3 服务器端的套接字和端口号　　299<br>6.2 服务器的接收操作　　305<br>6.2.1 网卡将接收到的信号转换成数字信息　　305<br>6.2.2 IP模块的接收操作　　308<br>6.2.3 TCP模块如何处理连接包　　309<br>6.2.4 TCP模块如何处理数据包　　311<br>6.2.5 TCP模块的断开操作　　312<br>6.3 Web服务器程序解释请求消息并作出响应　　313<br>6.3.1 将请求的URI转换为实际的文件名　　313<br>6.3.2 运行CGI程序　　316<br>6.3.3 Web服务器的访问控制　　319<br>6.3.4 返回响应消息　　323<br>6.4 浏览器接收响应消息并显示内容　　323<br>6.4.1 通过响应的数据类型判断其中的内容　　323<br>6.4.2 浏览器显示网页内容！访问完成！　　326<br>Gateway是通往异世界的入口　　328<br>附录　　330<br>后记　　334<br>致谢　　334<br>作者简介　　335<br><br><br><br>### <a href="https://book.douban.com/review/8935054/" target="_blank" rel="noopener">Notes</a><br><br>非常不错易读的书籍。工作和生活中陆陆续续接触到网络相关的。如大学时候对为什么上不了网（宿舍楼层交换机，电脑配置DHCP，子网掩码等），工作后的面试，TCP/IP的连接创建握手过程，关闭过程等，CDN网络加速回源，高性能服务器开发（epoll，socket，连接复用等），NAT和内网服务暴露到互联网，甚至翻墙等等诸多方面，如果早一点读这类书籍，可能对工作生活驾轻就熟而不是just work不求甚解。但对更复杂的 SDN（软件定义网络），VxLAN，甚至容器的overlay网络，还需要其他书籍等帮助<br>未完待续： 网桥/二层交换机 路由器/三层交换机 VLAN VPN 专线 BGP P2P ipsec TLS/SSL<br><br><br><br>以探索之旅的形式，从在浏览器中输入网址开始，一路追踪了到显示出网页内容为止的整个过程，以图配文，讲解了网络的全貌，并重点介绍了实际的网络设备和软件是如何工作的。目的是帮助读者理解网络的本质意义，理解实际的设备和软件，进而熟练运用网络技术<br><br><a href="https://book.douban.com/subject/26941639/" target="_blank" rel="noopener">https://book.douban.com/subject/26941639/</a><br><br>比如书中第 176 页讲到的地址转换，我们完全可以在家里配置一下试试。又比如书里第 79 页讲到了用 ACK 来确认网络包，我们可以装个 Wireshark，然后抓些包来看看 ACK 究竟是什么样的。<br>1 浏览器生成消息 - 探索浏览器内部<br>2 用电信号传输 TCP/IP 数据 - 探索协议栈和网卡<br>3 从网线到网络设备 - 探索集线器，交换机和路由器<br>4 通过接入网进入互联网内部 - 探索接入网和网络运营商<br>5 服务器端的局域网有什么玄机<br>6 请求到达web服务器，响应返回浏览器 - 短短<br>附录 - 网络包的旅程<br><br><br>1 浏览器生成消息 - 探索浏览器内部<br><br>ip 地址，要根据子网掩码来区分哪些部分是网络号哪些是机器号，子网掩码为 1 的部分表示网络号，子网掩码为 0 的部分表示主机号<br>主机号部分的比特全部为 0 或者全部为 1 时代表两种特殊的含义（整个子网和对子网上所有设备的广播）<br>Socket 库是用于调用网络功能的程序组件集合。gethostbyname<br>不同操作系统有设置ip（ip地址或自动获取dhcp，子网掩码和默认网关的），也有设置dns服务器的<br>域名的层次结构和缓存：<br><br>域名（服务器和邮件服务器如@后面的部分），class（IN）和记录类型（ A 时，表示域名对应的是 IP 地址；当类型为 MX 时，表示域名对应的是邮件服务器<br>对于一个邮件地址 <a href="mailto:tone@glasscom.com" target="_blank" rel="noopener">tone@glasscom.com</a>，当需要知道这个地址对应的邮件服务器时、当记录类型为 MX 时，DNS 服务器会在记录中保存两种信息，分别是邮件服务器的域名和优先级<br>例如根据 IP 地址反查域名的 PTR 类型，查询域名相关别名的 CNAME 类型，查询 DNS 服务器 IP 地址的 NS 类型，以及查询域名属性信息的 SOA 类型等<br><br>分配给根域 DNS 服务器的 IP 地址在全世界仅有 13 个（但背后的其实服务器的数量是很多的）根域 DNS 服务器的相关信息已经包含在 DNS 服务器程序的配置文件中了<br>似乎 com、jp 这些域（称为顶级域），根域的 DNS 服务器中保管着 com、jp 等的 DNS 服务器的信息。由于上级 DNS 服务器保管着所有下级 DNS 服务器的信息，所以我们可以从根域开始一路往下顺藤摸瓜找到任意一个域的 DNS 服务器。<br>查询域名是先问最近的dns服务器（配置的如8.8.8.8）然后查不到就问根域，根域到顶级域，在往下。<br>但其实各种优化缓存（不需要从最上级的根域开始查找，因为 DNS 服务器有一个缓存。DNS 服务器中保存的信息都设置有一个有效期，当缓存中的信息超过有效期后<br><br>服务器一方先创建套接字，然后等待客户端向该套接字连接管道 56 。当服务器进入等待状态时，客户端就可以连接管道了。具体来说，客户端也会先创建一个套接字，然后从该套接字延伸出管道，最后管道连接到服务器端的套接字上。当双方的套接字连接起来之后，通信准备就完成了。<br>管道在连接时是由客户端发起的，但在断开时可以由客户端或服务器任意一方发起 。管道断开，套机字也会被消除<br>浏览器等应用程序并不会自己去做连接管道、放入数据这些工作，而是委托协议栈来代劳。<br>创建套接字， socket，协议栈会返回一个描述符（多个套接字时的区分<br>connect连接，调用 connect 时，需要指定描述符、服务器 IP 地址和端口号这 3 个参数I（客户端在创建套接字时，协议栈会为这个套接字随便分配一个端口号 66 。接下来，当协议栈执行连接操作时，会将这个随便分配的端口号通知给服务器<br>write传递消息：<br>read：当服务器返回响应消息时，read 就会负责将接收到的响应消息存放到接收缓冲区中。由于接收缓冲区是一块位于应用程序内部的内存空间，因此当消息被存放到接收缓冲区中时，就相当于已经转交给了应用程序。<br>close： HTTP 协议规定，当 Web 服务器发送完响应消息之后，应该主动执行断开操作。<br><br>对于同一台服务器来说，重复连接和断开显然是效率很低的，因此后来人们又设计出了能够在一次连接中收发多个请求和响应的方法。在 HTTP 版本 1.1 中就可以使用这种方法<br><br>2<br>操作系统中的网络控制软件（协议栈）和网络硬件（网卡）是如何将浏览器的消息发送给服务器的<br>协议栈的上半部分有两块。<br>上部分TCP/UDP收发数据，一般的应用程序都是使用 TCP 收发数据的，而像 DNS 查询等收发较短的控制数据的时候则使用 UDP。<br>下部分：用 IP 协议控制网络包packet收发操作，IP 中还包括 ICMP协议和 ARP协议。 ICMP 用于告知网络包传送过程中产生的错误以及各种控制消息，ARP 用于根据 IP 地址查询相应的以太网 MAC 地址<br>协议栈内部存放控制信息的内存空间如通信对象的ip端口号通信的进行状态等，来实施断开超时连接，丢失完整性检查等<br>netstat 每一行都显示一个套接字的控制信息)<br>socket, connect, write, read, close<br>保存控制信息的头部：作 TCP 头部(20个字节，收发放端口号，序号，ack号，数据偏移量（头部长度），保留，控制位，窗口，校验和，紧急指针，可选字段)、以太网/Mac头部、IP 头部。<br>控制位如 ACK,PSH,RST, SYN,FIN<br>序号：发送方告知接收方该网络包发送的数据相当于所有发送数据的第几个字节<br>ACK号：接收方告知发送方接收方已经收到了所有数据的第几个字节<br>窗口，接收方告知发送方窗口大小（即无需等待确认可一起发送的数据量）<br><br>connect:<br>1 client 将头部中的控制位的 SYN 比特设置为 1,需要设置适当的序号和窗口大小<br>2 server, 从处于等待连接状态的套接字中找到与 TCP 头部中记录的端口号相同的套接字,写入相应控制信息，把套接字状态改为正在连接，返回响应，需要在 TCP 头部中设置发送方和接收方端口号以及 SYN 比特（由于某些原因不接受连接，那么将不设置 SYN，而是将 RST 比特设置为 1）。此外，在返回响应时还需要将 ACK 控制位设为 1<br>3 Client，通过 TCP 头部的信息确认连接服务器的操作是否成功。如果 SYN 为 1 则表示连接成功，将套接字状态改为连接完毕。客户端也需要将 ACK 比特设置为 1 并发回服务器<br>4 当这个服务器收到这个返回包之后，连接操作才算全部完成(session/connection<br><br>当控制流程从 connect 回到应用程序之后，接下来就进入数据收发阶段了。数据收发操作是从应用程序调用 write 将要发送的数据交给协议栈开始的<br>协议栈并不是一收到数据就马上发送出去，而是会将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据(有些程序会一次性传递所有的数据，有些程序则会逐字节或者逐行传递数据。如果一收到数据就马上发送出去，就可能会发送大量的小包，导致网络效率下降，因此需要在数据积累到一定量时再发送出去（或时间，协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去 - 给应用程序保留了控制发送时机的余地）<br><br>分片<br>头部中，“序号”字段就是派在这个用场上的（发送数据的长度也需要告知接收方，不过这个并不是放在 TCP 头部里面的，因为用整个网络包的长度减去头部的长度就可以得到数据的长度）<br>MTU(maximum transmission unit)表示一个网络包的最大长度，在以太网中一般是 1500 字节 - 调节它的意义，譬如特定程序发送的数据都类似（这时候可以设置MTU大小，特定数量的packet）<br>MSS：Maximum Segment Size，最大分段大小。 TCP 和 IP 的头部加起来一般是 40 字节，因此 MTU 减去这个长度就是 MSS<br><br>ack确认<br>返回 ACK 号时，除了要设置 ACK 号的值以外，还需要将控制位中的 ACK 比特设为 1，这代表 ACK 号字段有效，接收方也就可以知道这个网络包是用来告知 ACK 号的。<br>发送方说的是“现在发送的是从第 ×× 字节开始（发包的序号）的部分，一共有 ×× 字节哦！”而接收方则回复说，“到第 ×× 字节（回包的ack号）之前的数据我已经都收到了哦！”<br>这是因为如果序号都从 1 开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击。但是如果初始值是随机的，那么对方就搞不清楚序号到底是从多少开始计算的<br>TCP 会在尝试几次重传无效之后强制结束通信，并向应用程序报错。<br><br>网络繁忙拥塞 - TCP 会在发送数据的过程中持续测量 ACK 号的返回时间，如果 ACK 号返回变慢，则相应延长等待时间；相对地，如果 ACK 号马上就能返回，则相应缩短等待时间（否则一味等待或早早重传)<br><br>2.3.5 使用窗口有效管理 ACK 号发送一个包就等待一个 ACK 号的方式是最简单也最容易理解的，但在等待 ACK 号的这段时间中，如果什么都不做那实在太浪费了。为了减少这样的浪费，滑动窗口,在发送一个包之后，不等待 ACK 号返回，而是直接发送后续的一系列包。处理不过来，当接收方的 TCP 收到包后，会先将数据存放到接收缓冲区中。然后，接收方需要计算 ACK 号，将数据块组装起来还原成原本的数据并传递给应用程序，如果这些操作还没完成下一个包就到了也不用担心，因为下一个包也会被暂存在接收缓冲区中。如果数据到达的速率比处理这些数据并传递给应用程序的速率还要快，那么接收缓冲区中的数据就会越堆越多，最后就会溢出。 接收方需要告诉发送方自己最多能接收多少数据，然后发送方根据这个值对数据发送操作进行控制，这就是滑动窗口方式的基本思路能够接收的最大数据量称为窗口大小38，它是 TCP 调优参数中非常有名的一个。<br>ack 和窗口合并： 在等待发送 ACK 号的时候正好需要更新窗口，这时就可以把 ACK 号和窗口更新放在一个包里发送，从而减少包的数量。并且在等待过程可省略发送，只要发送最终的结果就可以了。<br><br>客户端断开： （1）客户端发送 FIN （2）服务器返回 ACK 号 （3）服务器发送 FIN （4）客户端返回 ACK 号 客户端等待一会在删除套接字。 <a href="https://app.yinxiang.com/shard/s2/nl/959004983/23c26cda-ddbd-4ec2-8948-e5e5f184c277/TIME_WAIT和CLOSE_WAIT" target="_blank" rel="noopener">https://app.yinxiang.com/shard/s2/nl/959004983/23c26cda-ddbd-4ec2-8948-e5e5f184c277/TIME_WAIT和CLOSE_WAIT</a> 和 recycle, reuse 最后客户端返回的 ACK 号丢失了，结果会如何呢？这时，服务器没有接收到 ACK 号，可能会重发一次 FIN。如果这时客户端的套接字已经删除了，会发生什么事呢？套接字被删除，那么套接字中保存的控制信息也就跟着消失了，套接字对应的端口号就会被释放出来。这时，如果别的应用程序要创建套接字，新套接字碰巧又被分配了同一个端口号48，而服务器重发的 FIN 正好到达，会怎么样呢？本来这个 FIN 是要发给刚刚删除的那个套接字的，但新套接字具有相同的端口号，于是这个 FIN 就会错误地跑到新套接字里面，新套接字就开始执行断开操作了。之所以不马上删除套接字，就是为了防止这样的误操作。<br><br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1054293.jpg"><br><br><br>2.5 包的基础<br><br><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1054288.jpg"><br><br><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1054289.jpg"><br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1054290.jpg"><br><br>网络包在传输过程中会经过集线器，集线器是根据以太网协议工作的设备。为了判断包接下来应该向什么地方传输，集线器里有一张表（用于以太网协议的表），可根据以太网头部中记录的目的地信息查出相应的传输方向。包会到达下一个路由器（图 2.16 ②）。路由器中有一张 IP 协议的表，可根据这张表以及 IP 头部中记录的目的地信息查出接下来应该发往哪个路由器。为了将包发到下一个路由器，我们还需要查出下一个路由器的 MAC 地址，并记录到 MAC 头部中，大家可以理解为改写了 MAC 头部ARP地址解析协议:在以太网中，有一种叫作广播的方法，可以把包发给连接在同一以太网中的所有设备。ARP 就是利用广播对所有设备提问：“×× 这个 IP 地址是谁的？请把你的 MAC 地址告诉我。<br><br><br><br>3从网线到网络设备——探索集线器、交换机和路由器<br>从客户端计算机发送的网络包通过家庭和公司局域网中的集线器和路由器前往目的地的过程。<br><br>交换机工作于数据链路层，用来隔离冲突域，连接的所有设备同属于一个广播域（子网），负责子网内部通信。<br><br>路由器工作于网络层，用来隔离广播域（子网），连接的设备分属不同子网，工作范围是多个子网之间，负责网络与网络之间通信。<br>——————————————————<br>举个例子：<br>家用宽带路由器，其实是交换机和路由器的结合体，有两个网络层接口，一个连接运营商网络，物理上也就是wan口，IP地址由运营商分配。另一个连接家庭网络，没有物理接口，IP地址由自己通过路由器管理界面配置，一般默认是192.168.1.1<br>那另外几个Lan口干什么用的？这就是交换机接口，和家庭网络接口相连，负责家庭网络内部通信。<br><br><br>3.2 交换机MAC地址表的维护：交换机在转发包的过程中，还需要对 MAC 地址表的内容进行维护.(删除地址表中某条记录的操作如移动设备断开)<br><br>路由器和交换机的关系路由器是基于 IP 设计的，而交换机是基于以太网设计的。IP（路由器）负责将包送达通信对象这一整体过程，而其中将包传输到下一个路由器的过程则是由以太网（交换机）来负责的在“查表判断转发目标”这一点上，路由器和交换机的大体思路是类似的，不过具体的工作过程有所不同。交换机是通过 MAC 头部中的接收方 MAC 地址来判断转发目标的，而路由器则是根据 IP 头部中的 IP 地址来判断的。由于使用的地址不同，记录转发目标的表的内容也会不同。<br>路由器根据“IP 地址”判断转发目标。路由器会忽略主机号，只匹配网络号。路由表的子网掩码列只表示在匹配网络包目标地址时需要对比的比特数量。默认路由/网关，本不需要匹配。只要将子网掩码设置为 0.0.0.0，那么无论任何地址都能匹配到这一条记录，这样就不会发生不知道要转发到哪里的问题了。<br>路由器的扩展功能：包过滤和地址转换公网和私网隔离。地址转换的基本原理是在转发网络包时对 IP 头部中的 IP 地址和端口号进行改写。首先，TCP 连接操作（如家里内网的iPad设备）的第一个包被转发到互联网时，会像图 3.18 这样，将发送方 IP 地址从私有地址改写成公有地址。这里使用的公有地址是地址转换设备52的互联网接入端口的地址。与此同时，端口号也需要进行改写，地址转换设备会随机选择一个空闲的端口。然后，改写前的私有地址和端口号，以及改写后的公有地址和端口号，会作为一组相对应的记录保存在地址转换设备内部的一张表中。互联网服务器返回的包的接收方就是改写后的公有地址和端口号。地址转换设备会从地址对应表中通过公有地址和端口号找到相对应的私有地址和端口号，并改写接收方信息，然后将包发给公司内网，这样包就能够到达原始的发送方了。实现从互联网访问家里/公司内网的：有时候我们希望能够从互联网访问公司内网，这需要进行一些设置才能实现。之所以无法从互联网访问内网，是因为对应表里没有相应的记录，那么我们只要事先手动添加这样的记录就可以了<br>包过滤就是在对包进行转发时，根据 MAC 头部、IP 头部、TCP 头部的内容55，按照事先设置好的规则决定是转发这个包，还是丢弃这个包。我们通常说的防火墙设备或软件，大多数都是利用这一机制来防止非法入侵的<br><br><br><br><br><br><br>PPP隧道<br>接入网分片大包<br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1054291.jpg"><br><br>4 接入网<br>将互联网理解为家庭、公司网络的一个放大版。<br><br>1）ADSL 接入网的结构和工作方式<br><br>家庭和公司的内网是通过接入网连接到网络运营商的。接入网有很多类型，这里我们将介绍 ADSL 接入网的知识，重点包括 ADSL 接入网的结构、电话线中传输的信号以及与电话共用的方式。<br><br>（2）光纤接入网（FTTH）<br><br>我们还会介绍另一种常用的接入网技术——与 ADSL 技术的利用率不相上下的光纤技术，重点包括光纤结构、单模和多模的区别之类的光纤性质，以及光纤用作接入网时的工作方式。<br><br>（3）接入网中使用的 PPP 和隧道<br><br>接入网需要通过用户名和密码验证用户的身份，然后由网络运营商向用户分配公有地址。此外，从接入网向网络运营商传输网络包时还使用了隧道技术，这些都是本章的看点。<br><br>（4）网络运营商的内部接入网后面连接着网络运营商的网络，运营商网络也是以路由器为核心组成的，这<br><br>一点和家庭、公司网络是一样的，包转发的工作原理也没有区别。不过，运营商网络也使用了一些和家庭、公司网络不同的技术，比如运营商之间可以自动交换路由信息和更新路由表，这些都是本章的看点。<br><br>（5）跨越运营商的网络包互联网是由多个运营商网络相互连接形成的巨大网络，而多个运营商之间相互连接的部分可以说就是互联网的核心部分，这里也是本章的看点。<br><br><br><br>4.3 接入网中使用的PPP和隧道另一种基于封装（encapsulation）的隧道实现方式，这种方式是将包含头部在内的整个包装入另一个包中传输到隧道的另一端。在<br><br><br>5服务器端的局域网中有什么玄机 (CDN，服务器端/内网防火墙）<br>防火墙的结构和原理一般在 Web 服务器前面都会部署防火墙，那么防火墙是通过怎样的机制保护服务器的呢？这是我们的第二个看点。<br>内容分发服务是从缓存服务器发展而来的，它在互联网中部署很多缓存服务器，并将用户的访问引导到最近的缓存服务器上。那么如何才能找到离用户最近的缓存服务器呢？如何将用户的访问引导到这台服务器上呢？内容分发服务的结构还是非常耐人寻味的。<br>厂商称为 CDSP（content delivery service provider） ，他们会与主要的供应商签约，并部署很多台缓存服务器 。另一方面，CDSP 会与 Web 服务器运营者签约，使得 CDSP 的缓存服务器配合 Web 服务器工作、 互联网中有很多缓存服务器，如何才能从这些服务器中找到离客户端最近的一个（边缘的接近用户的），并让客户端去访问那台服务器呢？Web 服务器的域名只对应一个 IP 地址的情况，如果一个域名对应多个 IP 地址，则按照前面图 5.3 的轮询方式按顺序返回所有的 IP 地址。<br>DNS 就近：DNS服务器，作为准备，需要事先从缓存服务器部署地点的路由器收集路由信息。DNS服务器根据路由表查询自己和客户端 DNS 服务器的路由信息（知道先通过运营商 X，然后通过运营商 Y，最后到达运营商 Z 这样的信息，通过这样的信息可以大致估算出距离）<br>还有另一个让客户端访问最近的缓存服务器的方法。HTTP 规格中定义了很多头部字段，其中有一个叫作 Location 的字段重定向。先需要将重定向服务器注册到 Web 服务器端的 DNS 服务器上。收集了来自各个路由器的路由信息，并根据这些信息找到最近的缓存服务器，然后将缓存服务器的地址放到 Location 字段中返回响应。<br><br><br>6 服务器概览<br>服务器的套接字和端口号<br>bind讲端口号写入套接字，listen向套接字写入等待状态这一控制信息。调用accept来接受连接，<br>当再次调用 accept，客户端连接包到达时，它又可以再次执行接受连接操作。接受新的连接之后，和刚才一样，协议栈会为这个等待连接的套接字复制一个新的副本，然后让客户端连接到这个新的副本套接字上。像这样每次为新的连接创建新的套接字就是这一步操作的一个关键点。如果不创建新副本，而是直接让客户端连接到等待连接的套接字上，那么就没有套接字在等待连接了，这时如果有其他客户端发起连接就会遇到问题。为了避免出现这样的情况，协议栈采用了这种创建套接字的新副本，并让客户端连接到这个新副本上的方法<br><br>端口号是用来识别套接字的，如果一个端口号对应多个套接字，就无法通过端口号来定位到某一个套接字了.<br>服务器上可能存在多个端口号相同的套接字，但客户端的套接字都是对应不同端口号的，因此我们可以通过客户端的端口号来确定服务器上的某个套接字。在套接字刚刚创建好，还没有建立连接的状态下，这 4 种信息是不全的,描述符还是简便<br><br>服务器端：<br>协议栈的 IP 模块会检查 IP 头部，（1） 判断是不是发给自己的（ 服务器操作系统中内置了可实现路由器功能的软件，只要启用这一功能，服务器就可以像路由器一样工作）；（2） 判断网络包是否经过分片；（如果是分片的包，则将包暂时存放在内存中，等所有分片全部到达之后将分片组装起来还原成原始包；）（3） 将包转交给TCP 模块或UDP模块。（检查 IP 头部的协议号字段。06-十六进制）<br><br>如果收到的是发起连接的包，则 TCP 模块会（1） 确认 TCP 头部的控制位SYN；（2） 检查接收方端口号；（3） 为相应的等待连接套接字复制一个新的副本；（4） 记录发送方 IP 地址和端口号等信息。<br><br>收到数据包时，TCP 模块会（1） 根据收到的包的发送方 IP 地址、发送方端口号、接收方 IP 地址、接收方端口号找到相对应的套接字；（2） 将数据块拼合起来并保存在接收缓冲区中；（根据套接字中保存的上一个序号和数据长度计算下一个序号，并检查与收到的包的 TCP 头部中的序号是否一致 。然后存放到接收缓冲区中，与上次收到的数据块连接起来）（3） 向客户端返回ACK。<br><br>断开操作：<br>服务器程序会调用 Socket 库的 close，TCP 模块会生成一个控制位 FIN 为 1 的 TCP 头部，并委托 IP 模块发送给客户端。当客户端收到这个包之后，会返回一个 ACK 号。接下来客户端调用 close，生成一个 FIN 为 1 的 TCP 头部发给服务器，服务器再返回 ACK 号，这时断开操作就完成了。HTTP1.1 中，是客户端先发起断开操作，这种情况下只要将客户端和服务器的操作颠倒一下就可以了。<br>套接字再此后会被删除（或者复用？！<br><br><br><br>### <a href="https://book.douban.com/review/8871118/" target="_blank" rel="noopener">网络是怎样连接的–如图</a><br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p987860.jpg"><br>网络是怎样连接的<br><br>网络是怎样连接的–如图<br>客户端：<br>web客户端<br>dns解析<br>tcp/ip 数据传送<br>客户端局域网<br>互联网—<br><br>服务器端：<br>–互联网–<br>云数据中心<br>防火墙<br>负载均衡（分布式架构，多台web服务器，减少每台的访问量）<br>缓存服务器<br>web服务器–内网访问，对外开放端口<br>数据库服务器<br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p987870.jpg"><br><br><br>缓存服务器的3种方式<br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p987910.jpg"><br><br>## <a href="https://book.douban.com/subject/25919428/" target="_blank" rel="noopener">图解网络硬件</a><br><br><img alt data-src="https://img3.doubanio.com/view/subject/l/public/s27316002.jpg"><br><br>### 目录<br>第1章　网络硬件通用基础知识　　1<br>01.01 网络的构成要素　　2<br>01.01.01 网络有哪些构成要素　　2<br>01.01.02 OSI参考模型复习　　4<br>01.02 LAN和以太网　　7<br>01.02.01 LAN的标准　　7<br>01.02.02 以太网　　10<br>01.03 以太网标准的数据处理　　15<br>01.03.01 以太网上的数据　　15<br>01.03.02 10BASE-T　　16<br>01.03.03 100BASE-TX　　17<br>01.03.04 1000BASE-T/1000BASE-TX　　19<br>01.03.05 1000BASE-SX/LX　　21<br>01.04 网络设备的构成要素　　22<br>01.04.01 通用服务器与专用设备　　22<br>01.04.02 分门别类的网络设备　　23<br>01.04.03 CPU　　24<br>01.04.04 存储设备　　24<br>01.04.05 存储器　　25<br>01.04.06 HDD/SSD　　26<br>01.04.07 硬件芯片　　28<br>01.04.08 接口　　30<br>01.04.09 信号转换器　　36<br>01.04.10 LED指示灯　　38<br>01.04.11 操作系统（内核）　　39<br>01.04.12 电源　　40<br>01.04.13 PSE（电气用品安全法）　　46<br>01.04.14 UPS　　47<br>01.04.15 风扇　　47<br>01.05 线缆与周边设备　　50<br>01.05.01 双绞线缆　　50<br>01.05.02 STP与UTP　　50<br>01.05.03 光纤　　51<br>01.05.04 机架　　56<br>第2章 彻底理解L2交换机　　61<br>02.01 中继器和网桥的不同点　　62<br>02.01.01 什么是中继器　　62<br>02.01.02 什么是网桥　　62<br>02.01.03 共享式集线器　　64<br>02.01.04 交换式集线器　　65<br>02.01.05 学习MAC地址　　66<br>02.01.06 使用交换机的优点　　67<br>02.02 交换机是如何诞生的　　68<br>02.02.01 以太网的历史　　68<br>02.02.02 世界上最早的交换机　　69<br>02.03 交换机中使用的数据帧及其传输方式　　71<br>02.03.01 以太网数据帧的种类　　71<br>02.03.02 交换机数据帧的传输方式　　71<br>02.03.03 自适应交换　　73<br>02.04 全双工和半双工　　74<br>02.05 如何描述交换机的处理能力　　76<br>02.06 交换机如何分类　　77<br>02.06.01 按照交换机的功能分类　　77<br>02.06.02 按照设备外形分类　　78<br>02.06.03 根据用途分类　　82<br>02.07 成为交换机性能指标的端口种类与数量　　83<br>02.07.01 快速以太网（10/100）端口　　84<br>02.07.02 千兆以太网端口（10/100/1000）端口　　84<br>02.07.03 光纤专用端口（SFP/SFP+）　　84<br>02.07.04 PoE端口　　84<br>02.07.05 上行链路端口数　　86<br>02.07.06 下行链路端口数　　86<br>02.07.07 交换机堆叠　　87<br>02.08 交换机搭载的其他功能　　88<br>02.08.01 MAC地址数　　88<br>02.08.02 巨型帧　　88<br>02.08.03 生成树功能　　89<br>02.08.04 链路聚合　　96<br>02.08.05 VLAN　　97<br>02.08.06 端口镜像　　97<br>02.08.07 QoS优先级队列 　　98<br>02.08.08 MAC地址过滤　　99<br>02.08.09 基于端口的认证　　100<br>02.08.10 网络管理　　102<br>02.09 交换机架构　　112<br>02.09.01 网络控制器（LAN控制器）　　113<br>02.09.02 PHY模块　　113<br>02.09.03 MAC模块　　115<br>02.09.04 AUI与MII　　116<br>第3章 路由器和它庞大的功能　　119<br>03.01 何为路由器　　120<br>03.01.01 路由器的必要性　　120<br>03.01.02 什么是路由选择　　120<br>03.01.03 转发　　121<br>03.01.04 路由器的功能　　122<br>03.02 路由器是如何诞生的　　123<br>03.02.01 世界上最早的商用路由器　　124<br>03.02.02 路由器性能的进化　　127<br>03.03 路由器的分类　　128<br>03.03.01 路由器设备　　128<br>03.03.02 根据性能分类　　129<br>03.03.03 面向电信运营商的路由器产品分类　　132<br>03.03.04 面向企业的路由器产品分类　　133<br>03.04 路由器产品目录说明　　137<br>03.05 IP路由选择的基础知识　　139<br>03.05.01 IP地址管理　　139<br>03.05.02 IP路由选择　　144<br>03.05.03 路由表　　145<br>03.05.04 最长匹配与默认网关　　145<br>03.05.05 静态路由选择　　147<br>03.05.06 动态路由选择　　147<br>03.05.07 IP隧道与VPN 　　154<br>03.05.08 IP多播　　158<br>03.06 了解路由器搭载的各种附加功能　　161<br>03.06.01 路由器功能的分类　　161<br>03.06.02 支持TCP/IP以外的协议簇　　161<br>03.06.03 LAN交换　　162<br>03.06.04 支持LAN以外的物理层和数据链路层协议　　163<br>03.06.05 拨号接入　　168<br>03.06.06 冗余　　169<br>03.06.07 认证　　174<br>03.06.08 QoS　　175<br>03.06.09 虚拟路由器　　180<br>03.07 用于管理路由器的各种功能　　181<br>03.07.01 用户界面　　181<br>03.07.02 日志　　182<br>03.07.03 确认CPU使用率　　183<br>03.07.04 告警　　183<br>03.07.05 设置时间　　184<br>03.07.06 故障排查　　184<br>03.07.07 文件传输控制　　185<br>03.07.08 其他工具包　　185<br>03.08 路由器的架构　　186<br>03.08.01 路由器的构成要素　　186<br>03.08.02 启动路由器的流程　　191<br>03.08.03 路由器的一般架构　　192<br>03.08.04 路由器的内部冗余　　198<br>03.09 设置操作系统时使用的命令和模式　　201<br>03.09.01 初始化　　201<br>03.09.02 通过CLI设置　　202<br>03.09.03 保存设置的方法　　204<br>03.09.04 恢复出厂设置的重置方法　　204<br>第4章 理解L3交换机的性能与功能　　207<br>04.01 何为L3交换机　　208<br>04.01.01 L3交换机与路由器的不同　　209<br>04.01.02 多层交换　　213<br>04.02 L3交换机是如何诞生的　　217<br>04.03 L3交换机的分类　　219<br>04.03.01 根据形状和用途分类　　219<br>04.03.02 根据性能分类　　219<br>04.04 L3交换机搭载的特殊功能　　221<br>04.04.01 L3交换机功能的分类　　221<br>04.04.02 VLAN 　　222<br>04.04.03 VLAN环境中的数据流向　　230<br>04.04.04 VLAN之间的路由选择　　231<br>第5章 防火墙功能与防范威胁的对策　　233<br>05.01 防火墙是怎样的网络硬件　　234<br>05.02 防火墙是如何诞生的　　235<br>05.03 防火墙如何分类　　238<br>05.03.01 软件型防火墙　　238<br>05.03.02 硬件型防火墙　　241<br>05.04 防火墙技术类型　　242<br>05.05 什么是防火墙的网络接口模式　　244<br>05.06 防火墙能够预防的威胁　　245<br>05.07 防火墙中搭载的各种功能　　247<br>05.07.01 会话管理　　247<br>05.07.02 分组结构解析　　254<br>05.07.03 安全区域　　256<br>05.07.04 安全策略　　258<br>05.07.05 NAT　　262<br>05.07.06 VPN　　266<br>05.07.07 DoS防御　　278<br>05.07.08 防范基于分组的攻击　　281<br>05.07.09 基于内容的扫描　　282<br>05.07.10 监视、报告功能　　289<br>05.07.11 分组捕获　　290<br>05.07.12 虚拟路由器　　290<br>05.07.13 虚拟防火墙　　291<br>05.08 决定防火墙性能的要素　　291<br>05.08.01 同时在线会话数　　291<br>05.08.02 NAT表数目　　291<br>05.08.03 每秒新建的会话数目　　292<br>05.09 同信息安全范畴相关的标准　　292<br>05.09.01 ISCA　　292<br>05.09.02 FIPS　　293<br>05.09.03 ISO/IEC 15408（公共标准） 　　293<br>第6章 高速普及的无线LAN及其基础知识　　295<br>06.01 无线LAN是如何诞生的？　　296<br>06.02 理解无线LAN所需的基础知识　　298<br>06.02.01 CSMA/CA　　298<br>06.02.02 无线LAN的架构　　298<br>06.02.03 无线LAN的拓扑结构　　299<br>06.03 各种各样的无线LAN标准　　301<br>06.03.01 IEEE 802.11　　303<br>06.03.02 IEEE 802.11a　　303<br>06.03.03 IEEE 802.11b　　304<br>06.03.04 IEEE 802.11g　　304<br>06.03.05 IEEE 802.11n　　304<br>06.03.06 IEEE 802.11ac　　305<br>06.03.07 IEEE 802.11ad　　305<br>06.03.08 Wi-Fi　　305<br>06.04 无线LAN搭载的各种功能　　306<br>06.04.01 关联　　306<br>06.04.02 接入点的接入控制　　307<br>06.04.03 接入点的认证　　309<br>06.04.04 无线LAN通信的加密　　310<br>06.04.05 自治型接入点　　313<br>06.04.06 集中管理型接入点　　313<br>06.04.07 无线LAN的桥接　　314<br>06.04.08 中继器连接　　314<br>06.05 无线LAN通信速率与覆盖范围的要点　　315<br>06.05.01 无线LAN的最大通信速率　　315<br>06.05.02 覆盖范围　　315<br>06.05.03 干涉　　320<br>06.05.04 无线LAN信道　　321<br>06.05.05 接入点的最大通信范围　　324<br>06.06 无线LAN的接入点产品　　326<br>06.06.01 产品规格书的阅读方法　　326<br>06.06.02 无线LAN硬件的制造厂商　　327<br>第7章 网络硬件设备的选购要点　　329<br>07.01 选择产品的类别　　330<br>07.02 基于功能需求汇总备选设备型号　　331<br>07.03 网络硬件的采购流程　　332<br>07.03.01 RFI与RFP　　332<br>07.03.02 RFQ　　334<br>07.04 根据性能选择产品的型号　　335<br>07.04.01 收集同网络延迟相关的信息　　335<br>07.04.02 网络设备产品性能的测量方法　　338<br>07.04.03 交换机性能的考量方法　　341<br>07.04.04 路由器性能的考量方法　　344<br>07.04.05 防火墙性能的考量方法　　344<br>07.04.06 无线LAN性能的考量方法　　347<br>07.05 根据物理需求选择产品　　349<br>07.05.01 交换机的选择　　349<br>07.05.02 路由器的选择　　352<br>07.05.03 防火墙产品的选择　　353<br>07.06 确认网络设备的互操作性　　353<br>07.07 高可用性的考量方法　　354<br>07.08 价格相关的考量方法　　355<br>07.08.01 端口单价　　355<br>07.08.02 比特单价　　356<br>07.08.03 学习成本　　356<br>07.08.04 支持的费用　　358<br>07.09 达到采购条件　　359<br>07.09.01 绿色采购　　359<br>07.09.02 符合RoHS要求　　359<br>07.09.03 加密出口管理相关　　360<br>07.10 售后支持相关的基础知识　　360<br>07.10.01 网络硬件的维护　　360<br>07.10.02 厂商保修　　361<br>插图 参考/引用文献　　363<br>照片出处和提供方　　364<br><br><br>### <a href="https://book.douban.com/review/9354640/" target="_blank" rel="noopener">《图解网络硬件》笔记</a><br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491945.jpg"><br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491946.jpg"><br><br><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491947.jpg"><br><br><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491948.jpg"><br><br>RJ-45 DB-9<br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491950.jpg"><br><br><br>1、L2交换机<br><br>中继器：信号增强<br><br><br><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491949.jpg"><br><br>交换机学习MAC地址<br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491952.jpg"><br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491951.jpg"><br><br><br>交换机接收到数据：直通转发、碎片隔离、存储转发<br><br>通信种类<br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491953.jpg"><br><br><br>核心、汇聚、接入<br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491954.jpg"><br><br><br>桥接环<br><br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491955.jpg"><br><br>生成树协议<br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491956.jpg"><br><br><br>链路聚合<br><br><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491958.jpg"><br><br><br>端口镜像<br><br><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491957.jpg"><br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491960.jpg"><br><br><br><br>高端路由器：<br><br><br><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491959.jpg"><br><br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491963.jpg"><br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491962.jpg"><br><br>主要IGP协议<br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491965.jpg"><br><br><br>RIP<br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491964.jpg"><br><br><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491967.jpg"><br><br><br>BGP：边缘网关协议<br><br>pptp不安全<br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491966.jpg"><br><br><br>L2TP<br><br><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491969.jpg"><br><br><br>NSF<br><br><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491968.jpg"><br><br><br>L3交换机结构：<br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491970.jpg"><br><br><br>负载均衡算法：RR，LC，WRR,WLC，IPSH，URLsh<br><br>L3交换机：7XXX,4XXX，<br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491971.jpg"><br><br><br>信息安全:CIA<br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491972.jpg"><br><br>DMZ<br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491973.jpg"><br><br><br>IPSEC-VPN    SSL-VPN<br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491974.jpg"><br><br><br>IDS，IPS<br><br><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491975.jpg"><br><br><br><br>亚马逊Alexa前高管、LivePerson首席技术官埃里克斯·斯皮内利本周表示，我们目前通过网站和特定品牌应用所从事的许多活动很快都将通过iMessage、WhatsApp和Alexa等消息和语音平台来完成。万维网已不再是<a href="https://deepcreator.com/Business/Business.html" target="_blank" rel="noopener">商业</a>的未来。（BI中文站）<br><br><br>## <a href="https://book.douban.com/subject/26369253/" target="_blank" rel="noopener">图解服务器端网络架构</a><br><br><img alt data-src="https://img1.doubanio.com/view/subject/l/public/s28051118.jpg"><br><br>### 目录<br><br>第0章　本书的用法　　1<br>0.1　 网络架构的流程　　2<br>0.1.1　网络架构分为六个阶段　　2<br>0.1.1.1　需求定义　　2<br>0.1.1.2　基础设计　　2<br>0.1.1.3　详细设计　　2<br>0.1.1.4　架构　　3<br>0.1.1.5　测试　　3<br>0.1.1.6　运行　　3<br>0.1.2　网络架构的重点是基础设计　　4<br>0.1.2.1　物理设计　　5<br>0.1.2.2　逻辑设计　　6<br>0.1.2.3　安全设计与负载均衡设计　　7<br>0.1.2.4　高可用性设计　　8<br>0.1.2.5　管理设计　　9<br><br>第1章　物理设计　　11<br>1.1　 物理层的技术　　12<br>1.1.1　物理层里有多种规格　　12<br>1.1.1.1　规格整理好后物理层就会水落石出　　13<br>1.1.1.2　双绞线电缆有两大要素——类和传输距离　　15<br>1.1.1.3　光纤光缆是用玻璃制成的　　25<br>1.2　 物理设计　　31<br>1.2.1　服务器端有两种结构类型　　31<br>1.2.1.1　采用串联式结构管理起来更方便　　32<br>1.2.1.2　采用单路并联式结构更容易扩展　　33<br>1.2.2　选用设备时应参考考查项的最大值　　36<br>1.2.2.1　应用程序不同吞吐率也就不同　　37<br>1.2.2.2　新增连接数和并发连接数都要考虑　　38<br>1.2.3　选择稳定可靠的 OS版本　　39<br>不懂就问是捷径　　39<br>1.2.4　根据实际配置和使用目的选择线缆　　40<br>1.2.4.1　远距离传输选择光纤光缆　　40<br>1.2.4.2　追求宽频带和高可靠性时选择光纤　　41<br>1.2.4.3　通过大小分类决定使用哪种双绞线电缆　　42<br>1.2.4.4　预先决定好使用线缆的颜色　　43<br>1.2.5　端口的物理设计出乎意料地重要　　44<br>1.2.5.1　必须统一规划连接到哪里　　44<br>1.2.5.2　速率和双工、Auto MDI/MDI-X 的设置也要统一规划　　44<br>1.2.6　巧妙地配置设备　　45<br>1.2.6.1　将核心交换机和汇聚交换机置于中央部位　　45<br>1.2.6.2　要考虑设备中空气吸入和排出的方向　　48<br>1.2.6.3　从两套系统获取电源　　49<br>1.2.6.4　切莫超过最大承重　　51<br><br>第2章　逻辑设计　　53<br>2.1　 数据链路层的技术　　54<br>2.1.1　数据链路层是物理层的帮手　　54<br>用以太网标准进行成帧处理　　55<br>2.1.2　数据链路层的关键在于 L2交换机的运作　　61<br>2.1.2.1　交换 MAC地址　　62<br>2.1.2.2　通过 VLAN将广播域分隔开　　67<br>2.1.3　ARP 将逻辑和物理关联到一起　　74<br>2.1.3.1　ARP 通过IP地址查询MAC地址　　75<br>2.1.3.2　抓取 ARP包，观察它的写法　　81<br>2.1.3.3　有几个特殊的 ARP　　82<br>2.2　 网络层的技术　　85<br>2.2.1　网络是由网络层拼接起来的　　85<br>2.2.1.1　添加 IP报头，进行分组化处理　　86<br>2.2.1.2　IP 地址由32位构成　　91<br>2.2.2　将网段连接起来　　99<br>2.2.2.1　利用 IP地址进行路由选择　　100<br>2.2.2.2　建立路由表　　104<br>2.2.2.3　整理路由表　　114<br>2.2.3　转换 IP地址　　118<br>2.2.3.1　转换 IP地址　　118<br>2.2.3.2　私网 IP地址　　122<br>2.2.4　自动设置 IP地址的DHCP　　123<br>2.2.4.1　DHCP 的消息部分中包含着诸多的信息　　123<br>2.2.4.2　DHCP 的原理非常简单　　125<br>2.2.4.3　对 DHCP报文作中继处理　　126<br>2.2.5　用于故障排除的 ICMP　　127<br>2.2.5.1　ICMP 的关键在于类型和代码　　127<br>2.2.5.2　常见的类型和代码有四种组合　　128<br>2.2.5.3　出现问题时先尝试用 ping去排除故障　　130<br>2.3　 逻辑设计　　132<br>2.3.1　整理出所需的 VLAN　　132<br>2.3.1.1　实际所需的 VLAN会因为诸多因素而变化　　132<br>2.3.1.2　规定 VLAN的ID　　138<br>2.3.2　在考虑数量增减的基础上分配 IP地址　　140<br>2.3.2.1　IP 地址的估算数量应高于当前所需数量　　140<br>2.3.2.2　按顺序排列网段，使之更容易汇总　　142<br>2.3.2.3　必须统一规定从何处开始分配 IP地址　　145<br>2.3.3　路由选择以简为上　　145<br>2.3.3.1　考虑在路由选择中使用哪些协议　　145<br>2.3.3.2　考虑采用哪种路由选择方法　　146<br>2.3.3.3　将路径汇总以减少路径数量　　150<br>2.3.4　NAT 要按入站和出站分别考虑　　152<br>2.3.4.1　NAT 是在系统边界进行的　　152<br>2.3.4.2　通过入站通信转换地址　　152<br>2.3.4.3　通过出站通信转换地址　　153<br><br>第3章　数据安全设计和负载均衡设计　　155<br>3.1.1　通过端口号划分服务器进程　　156<br>3.1.1.1　传输层使用 TCP和UDP两种协议　　157<br>3.1.1.2　TCP 的工作原理比较复杂　　164<br>3.1.1.3　MTU 和MSS的差异在于对象层不同　　170<br>3.1.2　用防火墙守卫系统　　173<br>3.1.2.1　基于连接进行控制　　174<br>3.1.2.2　状态检测和包过滤之间的区别　　177<br>3.1.2.3　防火墙在不断进步　　179<br>3.1.3　通过负载均衡器分散服务器的负荷　　184<br>3.1.3.1　目的 NAT是服务器负载均衡技术的基础　　185<br>3.1.3.2　通过健康检查监控服务器的状态　　189<br>3.1.3.3　熟练掌握可选功能　　200<br>3.2　 从会话层到应用层的技术　　204<br>3.2.1　HTTP 支撑着互联网　　204<br>3.2.1.1　HTTP/1.0 和HTTP/1.1的TCP连接用法大相径庭　　204<br>3.2.1.2　HTTP 因请求和响应而得以成立　　206<br>3.2.2　用 SSL保护数据　　211<br>3.2.2.1　防止窃听、篡改和冒充　　212<br>3.2.2.2　通过 SSL可以给各种各样的应用程序协议加密　　215<br>3.2.2.3　SSL 使用混合加密方式进行加密　　216<br>3.2.2.4　消息摘要是消息的概要　　219<br>3.2.2.5　SSL 中执行着大量的处理　　222<br>3.2.2.6　用客户端证书对客户端进行认证　　230<br>3.2.3　用 FTP传输文件　　233<br>3.2.3.1　主动模式使用特定的端口　　234<br>3.2.3.2　被动模式改变使用的端口　　236<br>3.2.3.3　FTP 就应该当作FTP去处理　　239<br>3.2.4　用 DNS解析名称　　240<br>3.2.4.1　用 UDP进行名称解析　　241<br>3.2.4.2　用 TCP进行区域传输　　242<br>3.3　 数据安全设计与负载均衡设计　　246<br>3.3.1　数据安全设计　　246<br>3.3.1.1　整理出真正需要的通信　　246<br>3.3.1.2　通过多级防御提高安全系数　　250<br>3.3.1.3　默认启动的服务应控制在最小范围内　　251<br>3.3.2　负载均衡设计　　251<br>3.3.2.1　要高效地均衡负载　　252<br>3.3.2.2　启用哪些可选功能　　255<br><br>第4章　高可用性设计　　257<br>4.1　 冗余技术　　258<br>4.1.1　物理层的冗余技术　　258<br>4.1.1.1　将多条物理链路集结成一条逻辑链路　　258<br>4.1.1.2　将多个物理网卡集结成一个逻辑网卡　　263<br>4.1.1.3　将多台物理设备集结成一台逻辑设备　　269<br>4.1.1.4　当上行链路中断时，让下行链路也随之中断　　278<br>4.1.2　数据链路层的冗余技术　　279<br>4.1.2.1　STP 的关键在于根网桥和阻塞端口　　279<br>4.1.2.2　STP 有三种　　286<br>4.1.2.3　同时启用多项可选功能　　289<br>4.1.2.4　利用 BPDU切断桥接环路　　290<br>4.1.3　网络层的冗余技术　　292<br>4.1.3.1　FHRP　　292<br>4.1.3.2　利用路由协议确保通往上层设备的路径　　302<br>4.1.4　从传输层到应用层的冗余技术　　304<br>4.1.4.1　防火墙的冗余技术　　304<br>4.1.4.2　负载均衡器的冗余技术　　310<br>4.2　 高可用性设计　　312<br>4.2.1　高可用性设计　　312<br>4.2.1.1　串联式结构　　312<br>4.2.1.2　单路并联式结构　　316<br>4.2.2　理清通信流　　320<br>4.2.2.1　串联式结构　　320<br>4.2.2.2　单路并联式结构　　332<br><br>第5章　管理设计　　339<br>5.1　 管理技术　　340<br>5.1.1　用 NTP同步时间　　340<br>NTP 的工作原理非常简单　　340<br>5.1.2　用 SNMP检测故障　　346<br>5.1.2.1　通过 SNMP管理器和SNMP代理交换信息　　346<br>5.1.2.2　熟练掌握三种运作模式　　347<br>5.1.2.3　限制源 IP地址　　351<br>5.1.3　用 Syslog检测故障　　352<br>Syslog 的工作原理非常简单　　352<br>5.1.4　传递设备信息　　355<br>5.1.4.1　CDP　　355<br>5.1.4.2　LLDP　　356<br>5.1.4.3　注意 CDP和LLDP的数据安全问题　　357<br>5.2　 管理设计　　358<br>5.2.1　确定主机名　　358<br>5.2.2　通过标签管理连接　　358<br>5.2.2.1　线缆标签　　358<br>5.2.2.2　本体标签　　359<br>5.2.3　设计密码　　359<br>5.2.4　管理设置信息　　360<br>5.2.4.1　在备份设计中应定义时机、方式和保存地点　　360<br>5.2.4.2　发生故障时执行恢复处理　　361<br><br><br>## <a href="https://coolshell.cn/articles/9666.html" target="_blank" rel="noopener">浏览器的渲染原理简介</a><br><br>看到这个标题大家一定会想到这篇神文《<a href="https://coolshell.cn/articles/9666.html" target="_blank" rel="noopener">How Browsers Work</a>》，这篇文章把浏览器的很多细节讲得很细，而且也被翻译成了中文。<br><br>浏览器工作大流程，先来看个图：<br><img alt data-src="https://coolshell.cn/wp-content/uploads/2013/05/Render-Process.jpg"><br><br><br>从上面这个图中，我们可以看到那么几个事：<br><br><br>1）浏览器会解析三个东西：<br><br>一个是HTML/SVG/XHTML，事实上，Webkit有三个C++的类对应这三类文档。解析这三种文件会产生一个DOM Tree。<br>CSS，解析CSS会产生CSS规则树。<br>Javascript，脚本，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree.<br><br>2）解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。注意：<br><br>Rendering Tree 渲染树并不等同于DOM树，因为一些像Header或display:none的东西就没必要放在渲染树中了。<br>CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element。也就是DOM结点。也就是所谓的Frame。<br>然后，计算每个Frame（也就是每个Element）的位置，这又叫layout和reflow过程。<br><br>3）最后通过调用操作系统Native GUI的API绘制。<br><br>&gt;DOM解析<br><br>HTML的DOM Tree解析如下：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Web page parsing&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h1&gt;Web page parsing&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;This is an example Web page.&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br><br>上面这段HTML会解析成这样：<br><img alt data-src="https://coolshell.cn/wp-content/uploads/2013/05/DOM-Tree-01.jpg"><br><br><br>下面是另一个有SVG标签的情况。<br><img alt data-src="https://coolshell.cn/wp-content/uploads/2013/05/DOM-Tree-02.jpg"><br><br><br>&gt;CSS解析<br><br>CSS的解析大概是下面这个样子（下面主要说的是Gecko也就是Firefox的玩法），假设我们有下面的HTML文档：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;doc&gt;</span><br><span class="line">&lt;title&gt;A few quotes&lt;/title&gt;</span><br><span class="line">&lt;para&gt;</span><br><span class="line">Franklin said that &lt;quote&gt;&quot;A penny saved is a penny earned.&quot;&lt;/quote&gt;</span><br><span class="line">&lt;/para&gt;</span><br><span class="line">&lt;para&gt;</span><br><span class="line">FDR said &lt;quote&gt;&quot;We have nothing to fear but &lt;span&gt;fear itself.&lt;/span&gt;&quot;&lt;/quote&gt;</span><br><span class="line">&lt;/para&gt;</span><br><span class="line">&lt;/doc&gt;</span><br></pre></td></tr></table></figure><br><br>于是DOM Tree是这个样子：<br><img alt data-src="https://coolshell.cn/wp-content/uploads/2013/05/DOM-Tree-Example.jpg"><br><br><br>然后我们的CSS文档是这样的：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* rule 1 */ doc &#123; display: block; text-indent: 1em; &#125;</span><br><span class="line">/* rule 2 */ title &#123; display: block; font-size: 3em; &#125;</span><br><span class="line">/* rule 3 */ para &#123; display: block; &#125;</span><br><span class="line">/* rule 4 */ [class=&quot;emph&quot;] &#123; font-style: italic; &#125;</span><br></pre></td></tr></table></figure><br><br>于是我们的CSS Rule Tree会是这个样子：<br><img alt data-src="https://coolshell.cn/wp-content/uploads/2013/05/CSS-Rule-Tree-Example.jpg"><br><br><br>注意，图中的第4条规则出现了两次，一次是独立的，一次是在规则3的子结点。所以，我们可以知道，建立CSS Rule Tree是需要比照着DOM Tree来的。CSS匹配DOM Tree主要是从右到左解析CSS的Selector，好多人以为这个事会比较快，其实并不一定。关键还看我们的CSS的Selector怎么写了。<br><br>注意：CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，你就会在N多地方看到很多人都告诉你，<strong>DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去</strong>，……<br><br>通过这两个树，我们可以得到一个叫Style Context Tree，也就是下面这样（把CSS Rule结点Attach到DOM Tree上）：<br><img alt data-src="https://coolshell.cn/wp-content/uploads/2013/05/CSS-Content-Tree-Example.jpg"><br><br><br>所以，Firefox基本上来说是通过CSS 解析 生成 CSS Rule Tree，然后，通过比对DOM生成Style Context Tree，然后Firefox通过把Style Context Tree和其Render Tree（Frame Tree）关联上，就完成了。注意：Render Tree会把一些不可见的结点去除掉。而Firefox中所谓的Frame就是一个DOM结点，不要被其名字所迷惑了。<br><br><img alt data-src="https://coolshell.cn/wp-content/uploads/2013/05/Firefox-style-context-tree.png"><br><br>注：Webkit不像Firefox要用两个树来干这个，Webkit也有Style对象，它直接把这个Style对象存在了相应的DOM结点上了。<br><br>&gt;渲染<br><br>渲染的流程基本上如下（黄色的四个步骤）：<br><br>1. 计算CSS样式<br>2. 构建Render Tree<br>3. Layout – 定位坐标和大小，是否换行，各种position, overflow, z-index属性 ……<br>4. 正式开画<br><img alt data-src="https://coolshell.cn/wp-content/uploads/2013/05/Render-Process-Skipping-1024x282.jpg"><br><br>注意：上图流程中有很多连接线，这表示了Javascript动态修改了DOM属性或是CSS属会导致重新Layout，有些改变不会，就是那些指到天上的箭头，比如，修改后的CSS rule没有被匹配到，等。<br><br>这里重要要说两个概念，一个是Reflow，另一个是Repaint。这两个不是一回事。<br><br>Repaint——屏幕的一部分要重画，比如某个CSS的背景色变了。但是元素的几何尺寸没有变。<br>Reflow——意味着元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。这就是Reflow，或是Layout。（HTML使用的是flow based layout，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫reflow）reflow 会从<html>这个root frame开始递归往下，依次计算所有的结点几何尺寸和位置，在reflow过程中，可能会增加一些frame，比如一个文本字符串必需被包装起来。<br>下面是一个打开Wikipedia时的Layout/reflow的视频（注：HTML在初始化的时候也会做一次reflow，叫 intial reflow），你可以感受一下：<br><br><br>Reflow的成本比Repaint的成本高得多的多。DOM Tree里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。在一些高性能的电脑上也许还没什么，但是如果reflow发生在手机上，那么这个过程是非常痛苦和耗电的。<br>所以，下面这些动作有很大可能会是成本比较高的。<br><br>当你增加、删除、修改DOM结点时，会导致Reflow或Repaint<br>当你移动DOM的位置，或是搞个动画的时候。<br>当你修改CSS样式的时候。<br>当你Resize窗口的时候（移动端没有这个问题），或是滚动的时候。<br>当你修改网页的默认字体时。<br>注：display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发现位置变化。<br><br>多说两句关于滚屏的事，通常来说，如果在滚屏的时候，我们的页面上的所有的像素都会跟着滚动，那么性能上没什么问题，因为我们的显卡对于这种把全屏像素往上往下移的算法是很快。但是如果你有一个fixed的背景图，或是有些Element不跟着滚动，有些Elment是动画，那么这个滚动的动作对于浏览器来说会是相当相当痛苦的一个过程。你可以看到很多这样的网页在滚动的时候性能有多差。因为滚屏也有可能会造成reflow。<br><br>基本上来说，reflow有如下的几个原因：<br><br>Initial。网页初始化的时候。<br>Incremental。一些Javascript在操作DOM Tree时。<br>Resize。其些元件的尺寸变了。<br>StyleChange。如果CSS的属性发生变化了。<br>Dirty。几个Incremental的reflow发生在同一个frame的子树上。<br>好了，我们来看一个示例吧：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var bstyle = document.body.style; // cache</span><br><span class="line"></span><br><span class="line">bstyle.padding = &quot;20px&quot;; // reflow, repaint</span><br><span class="line">bstyle.border = &quot;10px solid red&quot;; //  再一次的 reflow 和 repaint</span><br><span class="line"></span><br><span class="line">bstyle.color = &quot;blue&quot;; // repaint</span><br><span class="line">bstyle.backgroundColor = &quot;#fad&quot;; // repaint</span><br><span class="line"></span><br><span class="line">bstyle.fontSize = &quot;2em&quot;; // reflow, repaint</span><br><span class="line"></span><br><span class="line">// new DOM element - reflow, repaint</span><br><span class="line">document.body.appendChild(document.createTextNode(&apos;dude!&apos;));</span><br></pre></td></tr></table></figure><br><br>当然，我们的浏览器是聪明的，它不会像上面那样，你每改一次样式，它就reflow或repaint一次。一般来说，浏览器会把这样的操作积攒一批，然后做一次reflow，这又叫异步reflow或增量异步reflow。但是有些情况浏览器是不会这么做的，比如：resize窗口，改变了页面默认的字体，等。对于这些操作，浏览器会马上进行reflow。<br><br>但是有些时候，我们的脚本会阻止浏览器这么干，比如：如果我们请求下面的一些DOM值：<br><br>offsetTop, offsetLeft, offsetWidth, offsetHeight<br>scrollTop/Left/Width/Height<br>clientTop/Left/Width/Height<br>IE中的 getComputedStyle(), 或 currentStyle<br><br>因为，如果我们的程序需要这些值，那么浏览器需要返回最新的值，而这样一样会flush出去一些样式的改变，从而造成频繁的reflow/repaint。<br><br>&gt;减少reflow/repaint<br><br>下面是一些Best Practices：<br><br>1）不要一条一条地修改DOM的样式。与其这样，还不如预先定义好css的class，然后修改DOM的className。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">var left = 10,</span><br><span class="line">top = 10;</span><br><span class="line">el.style.left = left + &quot;px&quot;;</span><br><span class="line">el.style.top  = top  + &quot;px&quot;;</span><br><span class="line"></span><br><span class="line">// Good</span><br><span class="line">el.className += &quot; theclassname&quot;;</span><br><span class="line"></span><br><span class="line">// Good</span><br><span class="line">el.style.cssText += &quot;; left: &quot; + left + &quot;px; top: &quot; + top + &quot;px;&quot;;</span><br></pre></td></tr></table></figure><br><br>2）把DOM离线后修改。如：<br><br>使用documentFragment 对象在内存里操作DOM<br>先把DOM给display:none(有一次reflow)，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来。<br>clone一个DOM结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。<br><br>3）不要把DOM结点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。<br><br>4）尽可能的修改层级比较低的DOM。当然，改变层级比较底的DOM有可能会造成大面积的reflow，但是也可能影响范围很小。<br><br>5）为动画的HTML元件使用fixed或absoult的position，那么修改他们的CSS是不会reflow的。<br><br>6）千万不要使用table布局。因为可能很小的一个小改动会造成整个table的重新布局。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In this manner, the user agent can begin to lay out the table once the entire first row has been received. Cells in subsequent rows do not affect column widths. Any cell that has content that overflows uses the ‘overflow’ property to determine whether to clip the overflow content.</span><br><span class="line"></span><br><span class="line">Fixed layout, CSS 2.1 Specification</span><br></pre></td></tr></table></figure><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This algorithm may be inefficient since it requires the user agent to have access to all the content in the table before determining the final layout and may demand more than one pass.</span><br><span class="line"></span><br><span class="line">Automatic layout, CSS 2.1 Specification</span><br></pre></td></tr></table></figure><br><br>&gt;几个工具和几篇文章<br><br>有时候，你会也许会发现在IE下，你不知道你修改了什么东西，结果CPU一下子就上去了到100%，然后过了好几秒钟repaint/reflow才完成，这种事情以IE的年代时经常发生。所以，我们需要一些工具帮我们看看我们的代码里有没有什么不合适的东西。<br><br>Chrome下，Google的SpeedTracer是个非常强悍的工作让你看看你的浏览渲染的成本有多大。其实Safari和Chrome都可以使用开发者工具里的一个Timeline的东东。<br>Firefox下这个基于Firebug的叫Firebug Paint Events的插件也不错。<br>IE下你可以用一个叫dynaTrace的IE扩展。<br>最后，别忘了下面这几篇提高浏览器性能的文章：<br><br><a href="http://code.google.com/speed/page-speed/docs/rules_intro.html" target="_blank" rel="noopener">Google – Web Performance Best Practices</a><br><a href="http://developer.yahoo.com/performance/rules.html" target="_blank" rel="noopener">Yahoo – Best Practices for Speeding Up Your Web Site</a><br><a href="http://stevesouders.com/hpws/rules.php" target="_blank" rel="noopener">Steve Souders – 14 Rules for Faster-Loading Web Sites</a><br><br>&gt;参考<br><br>David Baron的演讲：Fast CSS: How Browsers Lay Out Web Pages：<a href="http://dbaron.org/talks/2012-03-11-sxsw/slide-1.xhtml" target="_blank" rel="noopener">slideshow</a>, all slides, audio (MP3), Session page, Lanyrd page<br>How Browsers Work: <a href="http://taligarsiel.com/Projects/howbrowserswork1.htm" target="_blank" rel="noopener">http://taligarsiel.com/Projects/howbrowserswork1.htm</a><br>Mozilla 的 Style System Overview：<a href="https://developer.mozilla.org/en-US/docs/Style_System_Overview" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Style_System_Overview</a><br>Mozilla 的 Note of reflow： <a href="http://www-archive.mozilla.org/newlayout/doc/reflow.html" target="_blank" rel="noopener">http://www-archive.mozilla.org/newlayout/doc/reflow.html</a><br>Rendering: repaint, reflow/relayout, restyle：<a href="http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/" target="_blank" rel="noopener">http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/</a><br>Effective Rendering CSS：<a href="http://css-tricks.com/efficiently-rendering-css/" target="_blank" rel="noopener">http://css-tricks.com/efficiently-rendering-css/</a><br>Webkit Rendering文档：<a href="http://trac.webkit.org/wiki/WebCoreRendering" target="_blank" rel="noopener">http://trac.webkit.org/wiki/WebCoreRendering</a><br><br>## <a href="http://shenzekun.cn/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E4%BB%8Eurl%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%EF%BC%8C%E8%BF%99%E4%B9%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88.html" target="_blank" rel="noopener">前端面试题：从url到页面展现，这之中发生了什么？</a><br><br>大概是这样的流程：<br><br>&gt;在浏览器的地址栏中敲入了url<br>域名解析<br>服务器处理请求<br>浏览器处理<br>绘制网页<br><br>一、在浏览器的地址栏中敲入了url<br><br>首先，我们要知道url是什么？<br><br>URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上的资源，实际上就是网站网址。url的格式一般为：<br><br>协议类型://&lt;主机名&gt;:&lt;端口&gt;/&lt;路径&gt;/文件名<br><br>其中协议类型可以是http（超文本传输协议）、https、ftp（文件传输协议）、telnet（远程登录协议）、file等等。而http是最常见的网络传输协议，https则是进行加密的网络传输。<br><br>例如，我的简书url为<a href="http://www.jianshu.com/u/b473784d730c，其中，“http”表示与web服务器通讯采用http协议，简书web服务器域名为www.jianshu.com，u/b473784d730c表示所访问的文件存在于web服务器上的路径。" target="_blank" rel="noopener">http://www.jianshu.com/u/b473784d730c，其中，“http”表示与web服务器通讯采用http协议，简书web服务器域名为www.jianshu.com，u/b473784d730c表示所访问的文件存在于web服务器上的路径。</a><br><br>url格式中主机名冒号后面的数字是端口编号，因为一台计算机常常会同时作为Web，FTP等服务器，端口编号用来告诉web服务器所在的主机要将请求交给哪个服务。默认情况下http服务的端口为80，不需要在url中输入，如果web服务器采用的不是这一个默认端口，就需要写明服务所用的端口。常见的协议默认端口如下：<br><br>协议类型    默认端口<br>http    80<br>ftp    21<br>https    443<br>telnet    23<br><br>&gt;IP是什么<br><br>IP是因特网中的每台连接到网络的计算机为实现相互通信而遵循的规则协议。每个处于互联网中的设备都有IP 地址，形如 192.168.0.1，而127.0.0.1代表本机的 IP。IP又分为局域网IP和公网IP。而局域网 IP 和公网 IP 是有差别的。每个网站就是靠IP来定位的。<br><br>为了便于记忆或辨识，人们使用域名来登录网站，每个域名背后有对应的IP地址。<br><br>比如对于 <a href="http://www.jianshu.com的URL，浏览器实际上不知道" target="_blank" rel="noopener">http://www.jianshu.com的URL，浏览器实际上不知道</a> <a href="http://www.jianshu.com到底是什么东西，需要查找www.jianshu.com网站所在服务器的IP地址，才能找到目标，这就是下文要说的域名解析。" target="_blank" rel="noopener">www.jianshu.com到底是什么东西，需要查找www.jianshu.com网站所在服务器的IP地址，才能找到目标，这就是下文要说的域名解析。</a><br><br>二、域名解析<br><br>当用户在浏览器中输入url后,你使用的电脑会发出一个DNS请求到本地DNS服务器。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动,DNS请求到达本地DNS服务器之后会有以下几个步骤：<br><br><br>查找浏览器缓存<br>浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。Chrome浏览器看本身的DNS缓存时间比较方便，在地址栏输入chrome://net-internals/#dns，就可以看到了<br><img alt data-src="http://upload-images.jianshu.io/upload_images/5308475-1edd5a71a8c33fd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><br>查找操作系统缓存<br>如果用户的浏览器缓存中没有，浏览器会从hosts文件查找是否有存储DNS信息，查找是否有目标域名和对应的IP地址<br><br>查找路由器缓存<br>如果系统缓存中也找不到，那么查询请求就会发向路由器，路由器一般会有自己的DNS缓存。<br><br>查找ISP(Internet Service Provider) DNS 缓存<br>如果路由器缓存中也找不到，那么就查询ISP DNS 缓存服务器了。<br>我们都知道在我们的网络配置中都会有”DNS服务器地址”这一项，操作系统会把这个域名发送给这里设置的DNS，比如114.114.114.114,也就是本地区的域名服务器，通常是提供给你接入互联网的应用提供商。而114.114.114.114是国内移动、电信和联通通用的DNS。<br><br>迭代查询<br>如果前面都找不到DNS缓存的话，会有以下几个步骤：<br><br>本地 DNS服务器将该请求转发到互联网上的根域（根域没有名字，在DNS系统中就用一个空字符串来表示。例如<a href="http://www.baidu.com.现在的DNS系统都不会要求域名以.来结束，即www.baidu.com就可以解析了，但是现在很多DNS解析服务商还是会要求在填写DNS记录的时候以.来结尾域名。）" target="_blank" rel="noopener">www.baidu.com.现在的DNS系统都不会要求域名以.来结束，即www.baidu.com就可以解析了，但是现在很多DNS解析服务商还是会要求在填写DNS记录的时候以.来结尾域名。）</a><br>根域将所要查询域名中的顶级域（比如要查询<a href="http://www.baidu,com，该域名的顶级域就是com）的服务器IP地址返回到本地DNS。" target="_blank" rel="noopener">www.baidu,com，该域名的顶级域就是com）的服务器IP地址返回到本地DNS。</a><br>本地DNS根据返回的IP地址，再向顶级域（就是com域）发送请求， com域服务器再将域名中的二级域（即<a href="http://www.baidu.com中的baidu.com）的IP地址返回给本地DNS。" target="_blank" rel="noopener">www.baidu.com中的baidu.com）的IP地址返回给本地DNS。</a><br>本地DNS再向二级域发送请求进行查询。<br>之后不断重复这样的过程，直到本地DNS服务器得到最终的查询结果，并返回到主机。这时候主机才能通过域名访问该网站。<br>下图能很好的说明这个迭代查询:<br><img alt data-src="http://upload-images.jianshu.io/upload_images/5308475-cf58e66c93c1f2ec.gif?imageMogr2/auto-orient/strip"><br>当查找到对应的IP地址之后，通过IP地址查找到对应的服务器，浏览器将用户发起的http请求发送给服务器。例如：GET <a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a> HTTP/1.1<br><br>三、服务器处理请求<br>每台服务器上都会安装处理请求的应用——Web server。常见的web server产品有apache、nginx、IIS、Lighttpd等。<br><br>当web server接收到一个HTTP请求(request)，会返回一个HTTP响应(response)，例如送回一个HTML页面。对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理对应请求的程序进行处理（例如CGI脚本，JSP脚本，servlets，ASP脚本，服务器端JavaScript，或者一些其它的服务器端技术等）。<br><br>无论它们(脚本)的目的如何，这些服务器端(server-side)的程序通常产生一个HTML的响应(response)来让浏览器可以浏览。<br><br>那么如何处理请求？实际上就是后台处理的工作。后台开发现在有很多框架，但大部分都还是按照MVC设计模式进行搭建的。<br><br>处理的过程如下图：<br><img alt data-src="http://upload-images.jianshu.io/upload_images/5308475-d45e8967170041f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><br>MVC的处理过程是这样的：对于每一个用户输入的请求，首先被控制器接收，控制器决定用哪个模型来进行处理，然后模型用业务逻辑来处理用户的请求并返回数据，最后控制器确定用哪个视图模型，用相应的视图格式化模型返回html字符串给浏览器，并通过显示页面呈现给用户。<br><br>四、浏览器处理<br>接下来就是浏览器进行处理， 通过后台处理返回的HTML字符串被浏览器接受后被一句句读取解析，html页面经历加载、解析、渲染。<br><br>加载<br>浏览器对一个html页面的加载顺序是从上而下的。如果加载过程中遇到外部css文件，浏览器另外发出一个请求，来获取css文件。遇到图片资源，浏览器也会另外发出一个请求，来获取图片资源。但是当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。<br><br>解析<br>解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树，也就是DOM树。如下图：<br><img alt data-src="http://upload-images.jianshu.io/upload_images/5308475-3817847173a249ef.gif?imageMogr2/auto-orient/strip"><br>css解析是指将css文件解析为样式表对象。如下图：<br><img alt data-src="http://upload-images.jianshu.io/upload_images/5308475-810853491150d1ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>js解析是文件在加载的同时也进行解析<br>如果想深入如何解析的话可以看<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Parsing_general" target="_blank" rel="noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a>这篇文章<br><br>渲染<br>即为构建渲染树的过程，就是将DOM树进行可视化表示。构建这棵树是为了以正确的顺序绘制文档内容。<br><br>五、绘制网页<br>浏览器根据 HTML 和 CSS 计算得到渲染树，最终绘制到屏幕上<br><br>参考的文章：<br><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">前端经典面试题: 从输入URL到页面加载发生了什么？</a><br><a href="http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/" target="_blank" rel="noopener">What really happens when you navigate to a URL</a><br><a href="http://book.jirengu.com/jrg-team/frontend-knowledge-ppt/www/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8-%E4%BB%8E%20URL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0.html#/" target="_blank" rel="noopener">从URL输入到页面展现</a><br><a href="http://blog.csdn.net/nawuyao/article/details/50386409" target="_blank" rel="noopener">MVC模型结构是什么</a><br><a href="http://weizhifeng.net/talking-about-domain.html" target="_blank" rel="noopener">域名详解</a><br><a href="http://www.jianshu.com/p/e141d1543143" target="_blank" rel="noopener">浏览器~加载，解析，渲染</a><br><br><br><br><br><br>## <a href="http://www.ruanyifeng.com/blog/2015/02/future-of-dom.html" target="_blank" rel="noopener">也许，DOM 不是答案</a><br><br>作者： 阮一峰<br>日期： 2015年2月22日<br><br>有一个词”手机网站”（mobile web），指供手机浏览的网站，但它是不存在的。<br><br>人们提到”移动互联网”的时候，其实专指另外一样东西：手机App。<br><br><img alt data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015022201.jpg"><br><br>一、Web App vs. Native App<br>比起手机App，网站有一些明显的优点。<br><br>跨平台：所有系统都能运行<br>免安装：打开浏览器，就能使用<br>快速部署：升级只需在服务器更新代码<br>超链接：可以与其他网站互连，可以被搜索引擎检索<br>但是，现实是怎样呢？<br><br>（1）体验差。手机App的操作流畅性，远超网站。<br>（2）业界不支持。所有公司的移动端开发重点，几乎都是原生app。<br>（3）用户不在乎。大多数用户都选择使用手机app，而不是网站。<br><br>如果将来有一天，Web app会成为主流，一定有一个前提，那就是它的性能可以赶上Native app。<br><br>二、为什么Web app有性能瓶颈？<br><br><img alt data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015022202.png"><br><br>Web app输给Native app的地方，不是界面（UI），而是操作性能。主要是互动（interaction）和动画（animation）这两方面，会出现卡顿（jank），用户会感觉到明显的时滞，有时简直慢得难以忍受。<br><br>Web app的性能瓶颈，主要有以下原因。<br><br>（1）Web基于DOM，而DOM很慢。浏览器打开网页时，需要解析文档，在内存中生成DOM结构，如果遇到复杂的文档，这个过程是很慢的。可以想象一下，如果网页上有上万个、甚至几十万个形状（不管是图片或CSS），生成DOM需要多久？更不要提与其中某一个形状互动了。<br><br>（2）DOM拖慢JavaScript。所有的DOM操作都是同步的，会堵塞浏览器。JavaScript操作DOM时，必须等前一个操作结束，才能执行后一个操作。只要一个操作有卡顿，整个网页就会短暂失去响应。<strong>浏览器重绘网页的频率是60FPS（即16毫秒/帧），JavaScript做不到在16毫秒内完成DOM操作</strong>，因此产生了跳帧。用户体验上的不流畅、不连贯就源于此。<br><br>（3）<strong>网页是单线程的</strong>。现在的浏览器对于每个网页，只用一个线程处理。所有工作都在这一个线程上完成，包括布局、渲染、JavaScript执行、图像解码等等，怎么可能不慢？<br><br>（4）<strong>网页没有硬件加速。网页都是由CPU处理的，没用GPU进行图形加速。</strong><br><br>上面这些原因，对于PC还不至于造成严重的性能问题，但是手机的硬件资源相对有限，用户互动又相对频繁，结果跟Native app一比，就完全落在了下风。<br><br>三、FlipBoard的解决方案<br><br>FlipBoard原本是一个手机App，最近开始部署Web版本，结果就遇到了上面的问题：Web版的体验不佳。<br><br>上周，他们将解决方案公布在网站上，结果引起了业界轰动，因为这是一个史无前例的解决方案：<br><br>—- 他们没有使用DOM，而是将整个网站用canvas输出！<br><br><img alt data-src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015022204.gif"><br><br>你可以用手机打开flipboard.com，体验一下，看看跟Native app有没有差别。如果你没有帐号，可以直接打开这里或这里。<br><br>这个方案的出发点是这样的：如果将网页变成了一个个canvas，用户就等于在跟图片互动，这样就绕开了DOM，降低了操作时滞。而且，canvas可以被硬件加速，这样就提高了性能。具体的技术细节，可以参考<a href="http://engineering.flipboard.com/2015/02/mobile-web/" target="_blank" rel="noopener">原文</a>。canvas的转化基于React框架实现，FlipBoard 开发了一个专门的库React-canvas，已经开源。<br><br>这个方案引发了很多争议（这里和这里），主要是canvas只是一个位图，本身没有语义，如果要在它上面实现UI，等于HTML语言已有的东西都要再发明一遍，比如如何实现超链接、如何实现CSS效果等等。一些最简单的东西都变得很麻烦，因为canvas不是自适应的（responsive），文字在哪里断行，都要自己计算，而且用户也无法选中文本。另外，怎么让搜索引擎检索网页，解决起来也不是很容易。<br><br>但是不管怎样，这是一个有意义的尝试。<br><br>四、未来的路<br>James Long对FlipBoard的尝试，写了一篇评论《Radical Statements about the Mobile Web》。本文就受到了那篇文章的启发。<br><br>在文中，James Long对未来的Web app提出了几点预测，我认为很值得分享。<br><br>（1）<strong>多线程浏览器</strong>。每个网页应该由多个线程进行处理，主线程只负责布局和渲染，而且应该在16毫秒内完成，JavaScript由worker线程执行，这样就不会发生堵塞了。Mozilla正在开发的Servo就是这样一个项目。<br><br>（2）DOM的异步操作。JavaScript对DOM的操作不再是同步的，而是触发后，交给Event Loop机制进行监听。<br><br>（3）非DOM方案。浏览器不再将网页处理成DOM结构，而是变为其他结构。React的Virtual DOM方案就是这一类的尝试，还有更激进的方案，比如用数据库取代DOM。<br><br>（完）<br><br>## <a href="http://www.ruanyifeng.com/blog/2016/01/website-obesity-crisis.html" target="_blank" rel="noopener">网站的肥胖症危机</a><br><br>作者： 阮一峰<br>日期： 2016年1月3日<br><br>最近，有一篇文章正在疯传。<br><br>它是上个月，Maciej Ceglowski在澳大利亚的一次演讲，名为《网站的肥胖症危机》（文本，视频），反思了互联网开发的现状。<br><br><img alt data-src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016010302.png"><br><br>该文非常值得一读，Hacker News排行榜高居榜首，得到了1000多人的推荐。<br><br>下面就是我的中文节译版。<br><br>===============================<br><br>网站的肥胖症危机（节译版）<br>作者：Maciej Ceglowski<br><br>译者：阮一峰<br><br>原文网址：The Website Obesity Crisis<br><br><img alt data-src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016010301.jpg"><br><br>1.<br><br>大多数网站的主要内容是文本，更准确地说，是简短的文本。<br><br>文本本身并不大，但是展示它们的网页，正变得越来越大。Twitter展示单条评论（140个字符）的页面，超过900KB。Medium的一篇文章大约400个词，页面大小是1.2MB。<br><br>如果这种趋势持续下去，2020年，网页的体积平均将超过5MB，比一本俄罗斯长篇小说还大。比如，陀思妥耶夫斯基的《罪与罚》，文本压缩后不到800KB。<br><br>TechTimes.com有一篇报道，介绍Google正在为大网页做标记。但是，这篇报道的网页，体积为18MB，外加一个3MB的视频。<br><br>2015年5月，Facebook引入了”Instant Articles”，帮助用户快速浏览新闻。但是，介绍这个功能的页面，体积为6.8MB，外加一个41MB的视频。你想了解这个功能的细节，唯一的方法就是去看这个视频。<br><br>2.<br><br>网页真的有必要这么大吗？明明200KB就足够，为什么要做成2MB？<br><br>因为我们要往里面塞很多不需要的东西：广告、高清图片、视频、用户追踪系统、社交媒体的代码……你不塞，公司就可能解雇你。<br><br>如今的时代，你跟雇主说，想做一张体积只有几百KB的网页，就好像跟SUV车主谈论省油的经济型轿车。<br><br>有人会说，这是免费内容的代价。但是，我想问，谁会从海量的互联网广告获利？广告主，还是消费者？真正获得暴利的是网络服务提供商和互联网广告公司，其他人都付出了巨大的成本。<br><br>3.<br><br>我们都忘了健康的网页，应该是什么样子。<br><br>值得阅读的文本，配上结构良好的标签。<br>适度的图片和视觉设计。<br>一层CSS<br>少量的JavaScript，只在必需时使用<br>但是，2015年真实的网页，却是下面这样。<br><br>一层HTML<br>一大堆垃圾<br>顶部还有一层监控代码<br>4.<br><br>宽带和光纤上网并不解决问题，实际上还鼓励了人们往网页上添加更多的东西。<br><br>为了平衡网页体积，工程师想出了很多方法：首屏快速渲染、压缩文件、异步加载、批量HTTP请求、管道发送等等……<br><br>网站开发越来越依赖代码精简、压缩、缓存、服务器配置这些中间步骤，这使得找出错误越来越困难，成本越来越高。<br><br>5.<br><br>复杂性让聪明人上瘾。<br><br>即使我们知道复杂不是好事，但难以抵抗。复杂的东西总是显得很酷，让人情不自禁想继续干下去。<br><br>大多数网站都过度复杂了。<br><br>我们做的每件事，都使得创造网站或编辑网页变得困难。把一篇文章放上网，正在变得需要一个专家团队才能完成。<br><br>新手越来越难通过源码学习。我们抽走了人们学习互联网的梯子。<br><br>6.<br><br>其实只需要两步，就可以大大缩小网页体积，提高性能。<br><br>第一步，确保最重要的内容，首先下载和渲染；<br><br>第二步，就此结束。<br><br>你不需要那些多余的垃圾，对最简主义保持信心就行。<br><br>7.<br><br>&gt;让我们保持互联网是一个超链接构成的媒体，不要把它变成另一种东西。<br><br><br>## 参考资料<br><br>### <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="noopener">JavaScript教程</a><br><br><img alt data-src="https://cdn.liaoxuefeng.com/cdn/files/attachments/0014355670304100cdaa4e7e651474d9672ed73797378bd000/l"><br><br>### <a href="http://www.w3school.com.cn/html5/index.asp" target="_blank" rel="noopener">HTML 5 教程</a><br><br>&gt;HTML5 是如何起步的？<br><br>HTML5 是 W3C 与 WHATWG 合作的结果。<br><br>编者注：W3C 指 World Wide Web Consortium，万维网联盟。<br><br>编者注：WHATWG 指 Web Hypertext Application Technology Working Group。<br><br>WHATWG 致力于 web 表单和应用程序，而 W3C 专注于 XHTML 2.0。在 2006 年，双方决定进行合作，来创建一个新版本的 HTML。<br><br>&gt;为 HTML5 建立的一些规则：<br><br>新特性应该基于 HTML、CSS、DOM 以及 JavaScript。<br>减少对外部插件的需求（比如 Flash）<br>更优秀的错误处理<br>更多取代脚本的标记<br>HTML5 应该独立于设备<br>开发进程应对公众透明<br>新特性<br><br>&gt;HTML5 中的一些有趣的新特性：<br><br>用于绘画的 canvas 元素<br>用于媒介回放的 video 和 audio 元素<br>对本地离线存储的更好的支持<br>新的特殊内容元素，比如 article、footer、header、nav、section<br>新的表单控件，比如 calendar、date、time、email、url、search<br><br><div><br><h2>视频格式</h2><br><br><p>当前，video 元素支持三种视频格式：</p><br><br><table class="dataintable"><br><tr><br><th>格式</th><br><th style="width:16%">IE</th><br><th style="width:16%">Firefox</th><br><th style="width:16%">Opera</th><br><th style="width:16%">Chrome</th><br><th style="width:16%">Safari</th><br></tr><br><br><tr><br><td>Ogg</td><br><td>No</td><br><td>3.5+</td><br><td>10.5+</td><br><td>5.0+</td><br><td>No</td><br></tr><br><br><tr><br><td>MPEG 4</td><br><td>9.0+</td><br><td>No</td><br><td>No</td><br><td>5.0+</td><br><td>3.0+</td><br></tr><br><br><tr><br><td>WebM</td><br><td>No</td><br><td>4.0+</td><br><td>10.6+</td><br><td>6.0+</td><br><td>No</td><br></tr><br></table><br><br><p>Ogg = 带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件</p><br><p>MPEG4 = 带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件</p><br><p>WebM = 带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件</p><br></div>


<h3 id="HTML-参考手册"><a href="#HTML-参考手册" class="headerlink" title="HTML 参考手册"></a><a href="http://www.w3school.com.cn/tags/index.asp" target="_blank" rel="noopener">HTML 参考手册</a></h3><h3 id="CSS-教程"><a href="#CSS-教程" class="headerlink" title="CSS 教程"></a><a href="http://www.w3school.com.cn/css/index.asp" target="_blank" rel="noopener">CSS 教程</a></h3><h3 id="WEB设计的速查卡"><a href="#WEB设计的速查卡" class="headerlink" title="WEB设计的速查卡"></a><a href="https://coolshell.cn/articles/870.html" target="_blank" rel="noopener">WEB设计的速查卡</a></h3><p>速查卡不仅仅可能帮助我们记住一些重要的东西，而且可以放在手边，当我们需要的时候，可以很快地查找。</p>
<p>在本篇文章中，你可以看到28个相当不错的关于Web设计的速查卡，它们分别是关于：Photoshop, Dreamweaver, 颜色, 排版,和 其它Web设计相关的。他们都是一页纸，可以方便你很快地打印出来。</p>
<h3 id="反击爬虫，前端工程师的脑洞可以有多大？"><a href="#反击爬虫，前端工程师的脑洞可以有多大？" class="headerlink" title="反击爬虫，前端工程师的脑洞可以有多大？"></a><a href="http://litten.me/2017/07/09/prevent-spiders/" target="_blank" rel="noopener">反击爬虫，前端工程师的脑洞可以有多大？</a></h3><h3 id="再议减少HTTP请求"><a href="#再议减少HTTP请求" class="headerlink" title="再议减少HTTP请求"></a><a href="http://litten.me/2014/08/14/reduce-http-requests/" target="_blank" rel="noopener">再议减少HTTP请求</a></h3><p>关于web性能，有两个著名论断：</p>
<p>0.1-0.2s 用户认为是即时的；1-5s 用户觉得自己能与信息流畅地交互；5-10s 用户开始转移注意力——Robert Miller</p>
<p>用户所接受的数据，有80~90%的时间都耗在前端上——Steve Souders</p>
<p>前者说明，loading图（以下简称菊花）是必要的。人处于“开始转移注意力”时，这朵菊花就开始挽留你躁动的心。但web工程师的一个使命，就是通过提升性能，不让用户看到菊花。菊花要有，但不能常有，真是一朵磨人的小妖精…</p>
<p>后者说明，资源的加载和渲染可以大做文章。因为一个html文件，几乎是所有资源的承载器，哪些优先加载，怎样加载，都是前端工程师可以控制的。</p>
<p>再议减少HTTP请求：<br>“尽量减少HTTP请求，减少DNS查找”这是Yslow写在最前面的两条规则。而放之实际，可能会遇到挑战。为何？因为我们完成了“降低请求数”的目标，但可能损失了其他方面的指标。</p>
<p>a. 没有浏览器缓存<br>减少HTTP请求，很常用的做法就是把js和css资源inline到html里。这样的做法，自然没有浏览器缓存，重复加载时连静态资源也必须加载。也许有人又说，我可以把整个html文件都缓存啊！的确可以，但以web开发的更新速度，html文件一般都不设或设置很短时间（5 min?）缓存。另外在web2.0时代里，html缓存会带来不必要的问题。比如登录前后，页面资源展示不一样，那么我们就得慎用html缓存。</p>
<p>b. 没有cdn缓存<br>这个很好理解，任何的内联资源，由于依赖于html，都必须从源服务器而不是cdn服务器返回。</p>
<p>c. 不能按需加载<br>为了按需加载，前端工程师可谓想法各异，天马行空。比如图片的lazyload技术，异步加载js脚本，而inline的方式恰恰将一切想法摁回脑中。</p>
<p>d. 浏览器预解析DNS失效<br>现代浏览器有预解析DNS技术。简单来说，就是页面下载到浏览器时，先扫描一遍，在这时发现域名并预解析DNS。这样的前置解析跟dom渲染等操作同步执行，诚然会使浏览器更快。但如果你的html页面因为内联了太多内容（base64图片），大于5M时，浏览器的预解析DNS将会失效。</p>
<p>最佳实践<br>因而，我们时常像那只捡芝麻丢西瓜的熊。如此平衡这两者呢，业界给我们两个很好的案例。</p>
<p>Demo1 必应</p>
<p>首次内联CSS与JS<br>将资源取出，并保存在localStorage中<br>资源名（版本）保存在cookie中<br>后续请求中，服务器检查对应的cookie<br>根据cookie的值，只嵌入新的脚本<br>加载时，从localStorage里载入资源</p>
<p>Demo2 百度(移动端)</p>
<p>首次将静态资源打包，用jsonp统一返回<br>将资源解析并保存在localStorage中<br>再次访问时检查localStorage中资源情况<br>如有缺失再发请求获取资源<br>必应的做法确保了首次的http请求最少，后续充分发挥增量更新（当然粒度还是文件）的优势提高性能，但缺点是cookie并不可靠。百度则是把首次静态资源的http请求降低到一次，非常暴力的把全部css，js打包成字符串，以jsonp返回。宁愿用str转obj的解析时间去换取加载时间。而随V8引擎的强大，这点解析的时间也将越来越不值得提起。总而言之，这两个Demo都把http请求尽可能的降低，而后都利用了本地存储去获得资源。</p>
<h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><p><img alt="jquery20180507.jpg" data-src="http://p53s4d2qk.bkt.clouddn.com/jquery20180507.jpg?imageMogr2/thumbnail/!75p"></p>
<blockquote>
<p><a href="http://jquery.com/" target="_blank" rel="noopener">jQuery</a>是一个轻量级、快速简洁的javaScript库。</p>
</blockquote>
<head><meta name="generator" content="Hexo 3.9.0"><br><script type="text/javascript" src="/js/src/jquery-3.3.1.js"></script><br><script type="text/javascript"><br>$(document).ready(function(){<br>$(“p”).click(function(){<br>$(this).hide();<br>});<br>});<br></script><br><link rel="alternate" href="/atom.xml" title="生命之旅" type="application/atom+xml">
</head>

<body><br><p>If you click on me, I will disappear.</p><br></body>



<h2 id="jQuery参考资料"><a href="#jQuery参考资料" class="headerlink" title="jQuery参考资料"></a>jQuery参考资料</h2><h3 id="jQuery-教程"><a href="#jQuery-教程" class="headerlink" title="jQuery 教程"></a><a href="http://www.w3school.com.cn/jquery/" target="_blank" rel="noopener">jQuery 教程</a></h3><h3 id="jQuery-实例"><a href="#jQuery-实例" class="headerlink" title="jQuery 实例"></a><a href="http://www.w3school.com.cn/jquery/jquery_examples.asp" target="_blank" rel="noopener">jQuery 实例</a></h3><h3 id="jQuery-参考手册"><a href="#jQuery-参考手册" class="headerlink" title="jQuery 参考手册"></a><a href="http://www.w3school.com.cn/jquery/jquery_reference.asp" target="_blank" rel="noopener">jQuery 参考手册</a></h3><h3 id="十分钟玩转-jQuery、实例大全"><a href="#十分钟玩转-jQuery、实例大全" class="headerlink" title="十分钟玩转 jQuery、实例大全"></a><a href="https://www.cnblogs.com/suoning/p/5683047.html" target="_blank" rel="noopener">十分钟玩转 jQuery、实例大全</a></h3><h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p><img alt="markdown-syntax-language.png" data-src="http://p53s4d2qk.bkt.clouddn.com/markdown-syntax-language.png?imageMogr2/thumbnail/!75p"></p>
<blockquote>
<p><a href="https://baike.baidu.com/item/markdown/3245829?fr=aladdin" target="_blank" rel="noopener">Markdown</a>是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
</blockquote>
<p>Markdown 的理念是，能让文档更容易读、写和随意改。</p>
<h2 id="Markdown参考资料"><a href="#Markdown参考资料" class="headerlink" title="Markdown参考资料"></a>Markdown参考资料</h2><h3 id="Mark-Text-下一代所见即所得的Markdown编辑器"><a href="#Mark-Text-下一代所见即所得的Markdown编辑器" class="headerlink" title="Mark Text - 下一代所见即所得的Markdown编辑器"></a><a href="http://www.cnblogs.com/lhb25/p/next-generation-markdown-editor.html" target="_blank" rel="noopener">Mark Text - 下一代所见即所得的Markdown编辑器</a></h3><p>　Mark Text 所输及所见，摒弃了众多 markdown 编辑器左边写作右边预览的写作方式，巧妙的将编辑和预览融为一体。snabbdom 作为 Mark Text 的渲染引擎，保证了极速渲染编辑页面，带来流程的书写体验。支持 CommonMark Spec 和 GitHub Flavored Markdown Spec 语法格式，生成的 Markdown 可以复制到任何支持 markdown 格式的社区、网站。段落及行内样式快捷键提升您的编辑效率。</p>
<p><img alt data-src="https://images2018.cnblogs.com/blog/36987/201804/36987-20180414212726214-1715743546.gif"></p>
<h3 id="Markdown-语法说明-简体中文版"><a href="#Markdown-语法说明-简体中文版" class="headerlink" title="Markdown 语法说明 (简体中文版)"></a><a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">Markdown 语法说明 (简体中文版)</a></h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt; 标签。</span><br></pre></td></tr></table></figure>
<p>请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的<em>强调</em>会没有效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTML 的区段（行内）标签如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;a&gt; 或 &lt;img&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。</span><br></pre></td></tr></table></figure>
<p>和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。</p>
<blockquote>
<p>特殊字符自动转换</p>
</blockquote>
<p>在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &lt; 和 &amp;。</p>
<p>列表<br>Markdown 支持有序列表和无序列表。</p>
<p>无序列表使用星号、加号或是减号作为列表标记：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   Red</span><br><span class="line">*   Green</span><br><span class="line">*   Blue</span><br></pre></td></tr></table></figure>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<p>等同于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+   Red</span><br><span class="line">+   Green</span><br><span class="line">+   Blue</span><br></pre></td></tr></table></figure>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<p>也等同于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-   Red</span><br><span class="line">-   Green</span><br><span class="line">-   Blue</span><br></pre></td></tr></table></figure>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<p>有序列表则使用数字接着一个英文句点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  Bird</span><br><span class="line">2.  McHale</span><br><span class="line">3.  Parish</span><br></pre></td></tr></table></figure>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
<blockquote>
<p>分隔线</p>
</blockquote>
<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<hr>
<hr>
<hr>
<p>强调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*test one*</span><br><span class="line">**test two**</span><br><span class="line">***test three***</span><br><span class="line">****test four****</span><br></pre></td></tr></table></figure>
<p><em>test one</em><br><strong>test two</strong><br><strong><em>test three</em></strong><br><strong><strong>test four</strong></strong></p>
<p>*literal asterisks*</p>
<h2 id="Hexo不渲染-md或者-html"><a href="#Hexo不渲染-md或者-html" class="headerlink" title="Hexo不渲染.md或者.html"></a><a href="https://blog.csdn.net/ganzhilin520/article/details/79057774" target="_blank" rel="noopener">Hexo不渲染.md或者.html</a></h2><p>我们知道，在 source 文件夹下的所有 md 文件或者 html 文件都会被渲染，有时候我们不想这些文件被渲染怎么办？比如很多时候我们想要写一个 README.md 或者一些自定义的页面。比如百度或者谷歌在验证站长权限的时候，通常都会要求在主目录下添加一个 html 文件。</p>
<blockquote>
<p>不渲染 md 文件</p>
</blockquote>
<p>使用上面的办法虽然不会渲染 md 文件，但是还是将 md 文件转化成了 html 文件，如果想保留原 md 文件后缀要怎么做呢？这就需要在 站点配置文件 config.yml 中配置，找到 skip_render 参数，开始匹配的位置是基于你的 source_dir 的，一般来说，是你的 source 文件夹下。下面我分别列举几种常见的情况进行说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">skip_render: test/* 单个文件夹下全部文件</span><br><span class="line">skip_render: test/*.md 单个文件夹下指定类型文件</span><br><span class="line">skip_render: test/** 单个文件夹下全部文件以及子目录</span><br><span class="line"></span><br><span class="line">多个文件夹以及各种复杂情况：</span><br><span class="line">skip_render: README.md</span><br><span class="line">- `test1/*.html`</span><br><span class="line">- `test2/**`</span><br><span class="line"></span><br><span class="line">&gt;不渲染 html 文件</span><br><span class="line"></span><br><span class="line">在不想被渲染的 html 文件最上面添加如下代码</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">layout: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h2 id="在主目录下添加README-md文件或者html文件"><a href="#在主目录下添加README-md文件或者html文件" class="headerlink" title="在主目录下添加README.md文件或者html文件"></a><a href="http://wp.huangshiyang.com/hexo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" target="_blank" rel="noopener">在主目录下添加README.md文件或者html文件</a></h2><p>Hexo3.0以下使用<br>感谢@TimNew提供的思路<br>额，不知道是不是有人跟我一样有一个库没有README.md文件就浑身不舒服的强迫症= =<br>正如大家所知道的，在source文件夹下的所有md文件都会被hexo渲染成html文件，导致README.md文件不能好好的放在里面了，即使是添加了layout: false依然没有用。</p>
<p>不过现在有一个另外的好办法，那就是利用主题的source目录，也就是themes/themes-name/source。因为这个文件夹里面的所有文件都会被复制到网站的根目录中去，也就是说，如果在里面放上README，就可以正常的存在于网站的主目录了。</p>
<p>同样的，对于一些需要在网站下添加html文件的需求也可以这样来达成。比如百度或者谷歌在验证站长权限的时候，通常都会要求在主目录下添加一个html文件。同样的，只要把这个文件放在themes/themes-name/source就可以搞定了。</p>
<p>Hexo3.0以上支持<br>使用_config.yml下的skip_render参数。<br>比如说现在source下有两个文件夹，一个是_post，一个是haha，里面各有一个名为hello-world.md的文档，然后我的skip_render参数为：<br>skip_render: haha/*.md<br>那么，hexo g之后的结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">INFO  Files loaded in 503 ms</span><br><span class="line">INFO  Generated: js/script.js</span><br><span class="line">INFO  Generated: fancybox/jquery.fancybox.pack.js</span><br><span class="line">INFO  Generated: fancybox/jquery.fancybox.js</span><br><span class="line">INFO  Generated: fancybox/jquery.fancybox.css</span><br><span class="line">INFO  Generated: fancybox/helpers/jquery.fancybox-thumbs.js</span><br><span class="line">INFO  Generated: fancybox/helpers/jquery.fancybox-thumbs.css</span><br><span class="line">INFO  Generated: fancybox/helpers/jquery.fancybox-media.js</span><br><span class="line">INFO  Generated: fancybox/helpers/jquery.fancybox-buttons.js</span><br><span class="line">INFO  Generated: fancybox/helpers/jquery.fancybox-buttons.css</span><br><span class="line">INFO  Generated: fancybox/helpers/fancybox_buttons.png</span><br><span class="line">INFO  Generated: fancybox/fancybox_sprite@2x.png</span><br><span class="line">INFO  Generated: fancybox/fancybox_sprite.png</span><br><span class="line">INFO  Generated: fancybox/fancybox_overlay.png</span><br><span class="line">INFO  Generated: fancybox/fancybox_loading@2x.gif</span><br><span class="line">INFO  Generated: fancybox/fancybox_loading.gif</span><br><span class="line">INFO  Generated: fancybox/blank.gif</span><br><span class="line">INFO  Generated: css/style.css</span><br><span class="line">INFO  Generated: css/images/banner.jpg</span><br><span class="line">INFO  Generated: css/fonts/fontawesome-webfont.woff</span><br><span class="line">INFO  Generated: css/fonts/fontawesome-webfont.ttf</span><br><span class="line">INFO  Generated: css/fonts/fontawesome-webfont.svg</span><br><span class="line">INFO  Generated: css/fonts/fontawesome-webfont.eot</span><br><span class="line">INFO  Generated: css/fonts/FontAwesome.otf</span><br><span class="line">INFO  Generated: haha/hello-world.md    //看这里！看这里！</span><br><span class="line">INFO  Generated: 2015/03/26/hello-world/index.html</span><br><span class="line">INFO  Generated: archives/index.html</span><br><span class="line">INFO  Generated: archives/2015/index.html</span><br><span class="line">INFO  Generated: archives/2015/03/index.html</span><br><span class="line">INFO  Generated: index.html</span><br><span class="line">INFO  29 files generatd in 1.28 s</span><br></pre></td></tr></table></figure>
<p>也就是说，skip_render参数的使用需要注意两点：</p>
<p>此处的位置是相对于你的source_dir的位置，一般来说，就是以source为根的位置<br>这里的文件匹配是基于正则的，大致上可以参考这个)，也就是说*.html可以忽略所有html文档，hello-wordl.md的话，就能忽略掉名字为hello-wordl.md的文件。</p>
<h2 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h2><p><img alt="chrome_wallpaper_by_kazvantipov-d4bt2mz.jpg" data-src="http://p53s4d2qk.bkt.clouddn.com/chrome_wallpaper_by_kazvantipov-d4bt2mz.jpg?imageMogr2/thumbnail/!75p"></p>
<blockquote>
<p> <a href="https://baike.baidu.com/item/Google%20Chrome/5638378?fr=aladdin" target="_blank" rel="noopener">Google Chrome</a>是一款由Google公司开发的网页浏览器，该浏览器基于其他开源软件撰写，包括WebKit，目标是提升稳定性、速度和安全性，并创造出简单且有效率的使用者界面。</p>
</blockquote>
<h2 id="Web前端性能优化——如何提高页面加载速度"><a href="#Web前端性能优化——如何提高页面加载速度" class="headerlink" title="Web前端性能优化——如何提高页面加载速度"></a><a href="https://www.cnblogs.com/MarcoHan/p/5295398.html" target="_blank" rel="noopener">Web前端性能优化——如何提高页面加载速度</a></h2><h2 id="浏览器野史-UserAgent列传（上）"><a href="#浏览器野史-UserAgent列传（上）" class="headerlink" title="浏览器野史 UserAgent列传（上）"></a><a href="http://litten.me/2014/09/26/history-of-browser-useragent/" target="_blank" rel="noopener">浏览器野史 UserAgent列传（上）</a></h2><p>1990年: Nexus(WorldWideWeb)诞生<br>1993年1月23日：Mosaic诞生<br>1994年12月：Netscape(Mozilla)诞生<br>1995年4月：Opera诞生<br>1995年8月16日：Internet Explorer诞生<br>2002年9月23日：Firefox诞生<br>2003年1月7日：Safari诞生<br>2008年9月2日：Chrome诞生</p>
<h2 id="浏览器野史-UserAgent列传（下）"><a href="#浏览器野史-UserAgent列传（下）" class="headerlink" title="浏览器野史 UserAgent列传（下）"></a><a href="http://litten.me/2014/10/05/history-of-browser-useragent2/" target="_blank" rel="noopener">浏览器野史 UserAgent列传（下）</a></h2><p>利用Trident（IE的内核），包装一下皮肤，美化一下，就可以说：完美兼容<br>利用Webkit，包装一下皮肤，美化一下，就可以说：极速浏览<br>把两个内核都包起来，就可以说：智能双核</p>
<p>使用Trident内核的，在IE已有UserAgent后添加自己的名称；使用Webkit内核的，就在Chrome的UserAgent后面添加。</p>
<p>前者像QQ浏览器：Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.7.26717.400)。<br>后者像猎豹：Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.137 Safari/537.36 LBBROWSER。<br>当然双核浏览器诚然就是墙头草，切换内核时UserAgent也需要跟着变化。</p>
<p>彩蛋</p>
<p>那么，我们的故事接近尾声。还有一些有趣的小彩蛋。</p>
<p>Chome 28开始，与苹果正式分道扬镳，采用Blink内核，但它的UserAgent并不改变。<br>淘宝封杀微信打开淘宝页面，靠的就是微信内置浏览器UserAgent里的MicroMessenger字样。其实微信也可以像当初360一样把UserAgent去掉，但微信并不这样做。<br>360出招之时留有后招。也许，它一开始就想到了腾讯会告他们对于UserAgent的欺瞒，因而它其实提供了设置项。默认设置是“保持跟IE一样的UserAgent”，但用户也可以不勾选。只是这选项比较隐蔽，而且你重启浏览器后…又会变回默认设置。如果没有这个小小的设置，结果大家可以自行想象。<br>微软又玩新花样了，在泄露版IE 11中，去掉了以往的MSIE字样。初步猜测此举是为了使现有的 CSS hack 失效，避免过去网页设计师对IE差别对待的情况再度发生。但又会引发其他问题啊亲。</p>
<p><a href="https://www.w3.org/TR/UAAG/" target="_blank" rel="noopener">User Agent Accessibility Guidelines 1.0</a></p>
<h2 id="兔子，胡萝卜与OAuth的故事"><a href="#兔子，胡萝卜与OAuth的故事" class="headerlink" title="兔子，胡萝卜与OAuth的故事"></a><a href="http://litten.me/2013/08/20/oauth-rabbit/" target="_blank" rel="noopener">兔子，胡萝卜与OAuth的故事</a></h2><h2 id="谈谈OAuth1-OAuth2异同"><a href="#谈谈OAuth1-OAuth2异同" class="headerlink" title="谈谈OAuth1,OAuth2异同"></a><a href="http://litten.me/2013/08/11/brief-oauth/" target="_blank" rel="noopener">谈谈OAuth1,OAuth2异同</a></h2><h2 id="图解密码技术"><a href="#图解密码技术" class="headerlink" title="图解密码技术"></a><a href="https://book.douban.com/subject/26265544/" target="_blank" rel="noopener">图解密码技术</a></h2><p><img alt data-src="https://img3.doubanio.com/view/subject/l/public/s27844440.jpg"></p>
<h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><p>本书以图配文的形式，详细讲解了6种最重要的密码技术：对称密码、公钥密码、单向散列函数、消息认证码、数字签名和伪随机数生成器。</p>
<p>第一部分讲述了密码技术的历史沿革、对称密码、分组密码模式（包括ECB、CBC、CFB、OFB、CTR）、公钥、混合密码系统。第二部分重点介绍了认证方面的内容，涉及单向散列函数、消息认证码、数字签名、证书等。第三部分讲述了密钥、随机数、PGP、SSL/TLS 以及密码技术在现实生活中的应用。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>第1部分　密码　　1<br>第1章　环游密码世界　　3<br>1.1　本章学习的内容　　4<br>1.2　密码　　4<br>1.2.1　Alice与Bob　　4<br>1.2.2　发送者、接收者和窃听者　　4<br>1.2.3　加密与解密　　6<br>1.2.4　密码保证了消息的机密性　　7<br>1.2.5　破译　　7<br>1.3　对称密码与公钥密码　　8<br>1.3.1　密码算法　　8<br>1.3.2　密钥　　8<br>1.3.3　对称密码与公钥密码　　9<br>1.3.4　混合密码系统　　10<br>1.4　其他密码技术　　10<br>1.4.1　单向散列函数　　10<br>1.4.2　消息认证码　　10<br>1.4.3　数字签名　　11<br>1.4.4　伪随机数生成器　　11<br>1.5　密码学家的工具箱　　12<br>1.6　隐写术与数字水印　　13<br>1.7　密码与信息安全常识　　14<br>1.7.1　不要使用保密的密码算法　　14<br>1.7.2　使用低强度的密码比不进行任何加密更危险　　15<br>1.7.3　任何密码总有一天都会被破解　　15<br>1.7.4　密码只是信息安全的一部分　　16<br>1.8　本章小结　　16<br>1.9　小测验的答案　　17<br>第2章　历史上的密码——写一篇别人看不懂的文章　　19<br>2.1　本章学习的内容　　20<br>2.2　恺撒密码　　20<br>2.2.1　什么是恺撒密码　　21<br>2.2.2　恺撒密码的加密　　21<br>2.2.3　恺撒密码的解密　　22<br>2.2.4　用暴力破解来破译密码　　23<br>2.3　简单替换密码　　24<br>2.3.1　什么是简单替换密码　　24<br>2.3.2　简单替换密码的加密　　25<br>2.3.3　简单替换密码的解密　　26<br>2.3.4　简单替换密码的密钥空间　　26<br>2.3.5　用频率分析来破译密码　　26<br>2.4　Enigma　　31<br>2.4.1　什么是Enigma　　31<br>2.4.2　用Enigma进行加密通信　　31<br>2.4.3　Enigma的构造　　32<br>2.4.4　Enigma的加密　　34<br>2.4.5　每日密码与通信密码　　36<br>2.4.6　避免通信错误　　36<br>2.4.7　Enigma的解密　　36<br>2.4.8　Enigma的弱点　　38<br>2.4.9　Enigma的破译　　38<br>2.5　思考　　40<br>2.5.1　为什么要将密码算法和密钥分开呢　　40<br>2.6　本章小结　　41<br>2.7　小测验的答案　　42<br>第3章　对称密码（共享密钥密码）——用相同的密钥进行加密和解密　　45<br>3.1　炒鸡蛋与对称密码　　46<br>3.2　本章学习的内容　　46<br>3.3　从文字密码到比特序列密码　　46<br>3.3.1　编码　　46<br>3.3.2　XOR　　47<br>3.4　一次性密码本——绝对不会被破译的密码　　50<br>3.4.1　什么是一次性密码本　　50<br>3.4.2　一次性密码本的加密　　50<br>3.4.3　一次性密码本的解密　　51<br>3.4.4　一次性密码本是无法破译的　　51<br>3.4.5　一次性密码本为什么没有被使用　　52<br>3.5　DES　　53<br>3.5.1　什么是DES　　53<br>3.5.2　加密和解密　　54<br>3.5.3　DES的结构（Feistel网络）　　54<br>3.6　三重DES　　60<br>3.6.1　什么是三重DES　　60<br>3.6.2　三重DES的加密　　60<br>3.6.3　三重DES的解密　　63<br>3.6.4　三重DES的现状　　64<br>3.7　AES的选定过程　　64<br>3.7.1　什么是AES　　65<br>3.7.2　AES的选定过程　　65<br>3.7.3　AES最终候选算法的确定与AES的最终确定　　　　65<br>3.8　Rijndael　　66<br>3.8.1　什么是Rijndael　　66<br>3.8.2　Rijndael的加密和解密　　66<br>3.8.3　Rijndael的破译　　68<br>3.8.4　应该使用哪种对称密码呢　　68<br>3.9　本章小结　　70<br>3.10　小测验的答案　　71<br>第4章　分组密码的模式——分组密码是如何迭代的　　73<br>4.1　本章学习的内容　　74<br>4.2　分组密码的模式　　75<br>4.2.1　分组密码与流密码　　75<br>4.2.2　什么是模式　　75<br>4.2.3　明文分组与密文分组　　76<br>4.2.4　主动攻击者Mallory　　76<br>4.3　ECB模式　　77<br>4.3.1　什么是ECB模式　　77<br>4.3.2　ECB模式的特点　　78<br>4.3.3　对ECB模式的攻击　　78<br>4.4　CBC模式　　80<br>4.4.1　什么是CBC模式　　80<br>4.4.2　初始化向量　　81<br>4.4.3　CBC模式的特点　　82<br>4.4.4　对CBC模式的攻击　　82<br>4.4.5　CBC的应用实例　　84<br>4.5　CFB模式　　85<br>4.5.1　什么是CFB模式　　85<br>4.5.2　初始化向量　　86<br>4.5.3　CFB模式与流密码　　86<br>4.5.4　CFB模式的解密　　87<br>4.5.5　对CFB模式的攻击　　87<br>4.6　OFB模式　　88<br>4.6.1　什么是OFB模式　　88<br>4.6.2　初始化向量　　89<br>4.6.3　CFB模式与OFB模式的对比　　89<br>4.7　CTR模式　　90<br>4.7.1　计数器的生成方法　　92<br>4.7.2　OFB模式与CTR模式的对比　　92<br>4.7.3　CTR模式的特点　　92<br>4.7.4　错误与机密性　　93<br>4.8　应该使用哪种模式呢　　93<br>4.9　本章小结　　94<br>4.10　小测验的答案　　95<br>第5章　公钥密码——用公钥加密，用私钥解密　　97<br>5.1　投币寄物柜的使用方法　　98<br>5.2　本章学习的内容　　98<br>5.3　密钥配送问题　　98<br>5.3.1　什么是密钥配送问题　　98<br>5.3.2　通过事先共享密钥来解决　　100<br>5.3.3　通过密钥分配中心来解决　　101<br>5.3.4　通过Diffie-Hellman密钥交换来解决密钥配送问题　　102<br>5.3.5　通过公钥密码来解决密钥配送问题　　102<br>5.4　公钥密码　　103<br>5.4.1　什么是公钥密码　　103<br>5.4.2　公钥密码的历史　　104<br>5.4.3　公钥通信的流程　　104<br>5.4.4　各种术语　　106<br>5.4.5　公钥密码无法解决的问题　　106<br>5.5　时钟运算　　106<br>5.5.1　加法　　107<br>5.5.2　减法　　109<br>5.5.3　乘法　　110<br>5.5.4　除法　　110<br>5.5.5　乘方　　114<br>5.5.6　对数　　114<br>5.5.7　从时钟指针到RSA　　115<br>5.6　RSA　　116<br>5.6.1　什么是RSA　　116<br>5.6.2　RSA加密　　116<br>5.6.3　RSA解密　　117<br>5.6.4　生成密钥对　　118<br>5.6.5　具体实践一下吧　　121<br>5.7　对RSA的攻击　　124<br>5.7.1　通过密文来求得明文　　124<br>5.7.2　通过暴力破解来找出D　　124<br>5.7.3　通过E和N求出D　　125<br>5.7.4　中间人攻击　　126<br>5.8　其他公钥密码　　128<br>5.8.1　ElGamal方式　　128<br>5.8.2　Rabin方式　　128<br>5.8.3　椭圆曲线密码　　128<br>5.9　关于公钥密码的问答　　128<br>5.9.1　公钥密码的机密性　　129<br>5.9.2　公钥密码与对称密码的密钥长度　　129<br>5.9.3　对称密码的未来　　129<br>5.9.4　RSA与质数　　130<br>5.9.5　RSA与质因数分解　　130<br>5.9.6　RSA的长度　　131<br>5.10　本章小结　　132<br>5.11　小测验的答案　　133<br>第6章　混合密码系统——用对称密码提高速度，用公钥密码保护会话密钥　　135<br>6.1　混合动力汽车　　136<br>6.2　本章学习的内容　　136<br>6.3　混合密码系统　　136<br>6.3.1　对称密码与公钥密码　　136<br>6.3.2　混合密码系统　　137<br>6.3.3　加密　　138<br>6.3.4　解密　　140<br>6.3.5　混合密码系统的具体例子　　141<br>6.4　怎样才是高强度的混合密码系统　　141<br>6.4.1　伪随机数生成器　　141<br>6.4.2　对称密码　　142<br>6.4.3　公钥密码　　142<br>6.4.4　密钥长度的平衡　　142<br>6.5　密码技术的组合　　142<br>6.6　本章小结　　143<br>6.7　小测验的答案　　144<br>第2部分　认证　145<br>第7章　单向散列函数——获取消息的“指纹”　　147<br>7.1　本章学习的内容　　148<br>7.2　什么是单向散列函数　　148<br>7.2.1　这个文件是不是真的呢　　148<br>7.2.2　什么是单向散列函数　　151<br>7.2.3　单向散列函数的性质　　153<br>7.2.4　关于术语　　156<br>7.3　单向散列函数的实际应用　　157<br>7.3.1　检测软件是否被篡改　　157<br>7.3.2　基于口令的加密　　159<br>7.3.3　消息认证码　　159<br>7.3.4　数字签名　　159<br>7.3.5　伪随机数生成器　　159<br>7.3.6　一次性口令　　159<br>7.4　单向散列函数的具体例子　　160<br>7.4.1　MD4、MD5　　160<br>7.4.2　SHA-1、SHA-256、SHA-384、SHA-512　　160<br>7.4.3　RIPEMD-160　　160<br>7.4.4　AHS（Advanced　Hash　Standard）与SHA-3　　　　161<br>7.5　单向散列函数SHA-1　　161<br>7.5.1　整体流程　　161<br>7.5.2　(1)　SHA-1：填充　　162<br>7.5.3　(2)　SHA-1：计算W0～W79　　164<br>7.5.4　(3)　SHA-1：分组处理　　165<br>7.5.5　(4)　SHA-1：单步处理　　167<br>7.6　对单向散列函数的攻击　　168<br>7.6.1　暴力破解（攻击故事1）　　168<br>7.6.2　生日攻击（攻击故事2）　　170<br>7.7　单向散列函数无法解决的问题　　172<br>7.8　本章小结　　173<br>7.9　小测验的答案　　173<br>第8章　消息认证码——消息被正确传送了吗　　177<br>8.1　本章学习的内容　　178<br>8.2　消息认证码　　178<br>8.2.1　汇款请求是正确的吗　　178<br>8.2.2　什么是消息认证码　　179<br>8.2.3　消息认证码的使用步骤　　180<br>8.2.4　消息认证码的密钥配送问题　　180<br>8.3　消息认证码的应用实例　　181<br>8.3.1　SWIFT　　181<br>8.3.2　IPsec　　181<br>8.3.3　SSL/TLS　　182<br>8.4　消息认证码的实现方法　　182<br>8.4.1　使用单向散列函数实现　　182<br>8.4.2　使用分组密码实现　　182<br>8.4.3　其他实现方法　　182<br>8.5　HMAC的详细介绍　　182<br>8.5.1　什么是HMAC　　182<br>8.5.2　HMAC的步骤　　183<br>8.6　对消息认证码的攻击　　185<br>8.6.1　重放攻击　　185<br>8.6.2　密钥推测攻击　　187<br>8.7　消息认证码无法解决的问题　　188<br>8.7.1　对第三方证明　　188<br>8.7.2　防止否认　　188<br>8.8　本章小结　　189<br>8.9　小测验的答案　　189<br>第9章　数字签名——消息到底是谁写的　　191<br>9.1　羊妈妈的认证　　192<br>9.2　本章学习的内容　　192<br>9.3　数字签名　　192<br>9.3.1　Alice的借条　　192<br>9.3.2　从消息认证码到数字签名　　193<br>9.3.3　签名的生成和验证　　194<br>9.3.4　公钥密码与数字签名　　195<br>9.4　数字签名的方法　　197<br>9.4.1　直接对消息签名的方法　　197<br>9.4.2　对消息的散列值签名的方法　　199<br>9.5　对数字签名的疑问　　202<br>9.5.1　密文为什么能作为签名使用　　202<br>9.5.2　数字签名不能保证机密性吗　　202<br>9.5.3　这种签名可以随意复制吗　　203<br>9.5.4　消息内容会不会被任意修改　　203<br>9.5.5　签名会不会被重复使用　　204<br>9.5.6　删除签名也无法“作废合同”吗　　204<br>9.5.7　如何防止否认　　205<br>9.5.8　数字签名真的能够代替签名吗　　205<br>9.6　数字签名的应用实例　　206<br>9.6.1　安全信息公告　　206<br>9.6.2　软件下载　　207<br>9.6.3　公钥证书　　208<br>9.6.4　SSL/TLS　　208<br>9.7　通过RSA实现数字签名　　208<br>9.7.1　用RSA生成签名　　208<br>9.7.2　用RSA验证签名　　209<br>9.7.3　具体实践一下吧　　209<br>9.8　其他的数字签名　　210<br>9.8.1　ElGamal方式　　210<br>9.8.2　DSA　　210<br>9.8.3　Rabin方式　　211<br>9.9　对数字签名的攻击　　211<br>9.9.1　中间人攻击　　211<br>9.9.2　对单向散列函数的攻击　　212<br>9.9.3　利用数字签名攻击公钥密码　　212<br>9.9.4　其他攻击　　213<br>9.10　各种密码技术的对比　　213<br>9.10.1　消息认证码与数字签名　　213<br>9.10.2　混合密码系统与对散列值签名　　214<br>9.11　数字签名无法解决的问题　　214<br>9.12　本章小结　　215<br>9.13　小测验的答案　　216<br>第10章　证书——为公钥加上数字签名　　217<br>10.1　本章学习的内容　　218<br>10.2　证书　　218<br>10.2.1　什么是证书　　218<br>10.2.2　证书的应用场景　　218<br>10.3　实际生成一张证书　　221<br>10.3.1　VeriSign的免费试用服务　　221<br>10.3.2　生成证书　　221<br>10.3.3　将证书从Web浏览器中导出　　224<br>10.3.4　证书的内容　　224<br>10.3.5　证书标准规范X.509　　224<br>10.4　公钥基础设施（PKI）　　228<br>10.4.1　什么是公钥基础设施　　228<br>10.4.2　PKI的组成要素　　228<br>10.4.3　认证机构的工作　　230<br>10.4.4　证书的层级结构　　231<br>10.4.5　各种各样的PKI　　233<br>10.5　对证书的攻击　　234<br>10.5.1　在公钥注册之前进行攻击　　234<br>10.5.2　注册相似人名进行攻击　　234<br>10.5.3　窃取认证机构的私钥进行攻击　　235<br>10.5.4　攻击者伪装成认证机构进行攻击　　235<br>10.5.5　钻CRL的空子进行攻击(1)　　236<br>10.5.6　钻CRL的空子进行攻击(2)　　237<br>10.6　关于证书的Q&amp;A　　238<br>10.6.1　为什么需要证书　　238<br>10.6.2　通过自己的方法进行认证是不是更安全　　239<br>10.6.3　为什么要相信认证机构　　240<br>10.7　本章小结　　241<br>10.8　小测验的答案　　242<br>第3部分　密钥、随机数与应用技术　243<br>第11章　密钥——秘密的精华　　245<br>11.1　本章学习的内容　　246<br>11.2　什么是密钥　　246<br>11.2.1　密钥就是一个巨大的数字　　246<br>11.2.2　密钥与明文是等价的　　248<br>11.2.3　密码算法与密钥　　248<br>11.3　各种不同的密钥　　248<br>11.3.1　对称密码的密钥与公钥密码的密钥　　248<br>11.3.2　消息认证码的密钥与数字签名的密钥　　249<br>11.3.3　用于确保机密性的密钥与用于认证的密钥　　250<br>11.3.4　会话密钥与主密钥　　251<br>11.3.5　用于加密内容的密钥与用于加密密钥的密钥　　　　252<br>11.4　密钥的管理　　252<br>11.4.1　生成密钥　　252<br>11.4.2　配送密钥　　253<br>11.4.3　更新密钥　　253<br>11.4.4　保存密钥　　254<br>11.4.5　作废密钥　　256<br>11.5　Diffie-Hellman密钥交换　　256<br>11.5.1　什么是Diffie-Hellman密钥交换　　256<br>11.5.2　Diffie-Hellman密钥交换的步骤　　257<br>11.5.3　Eve能计算出密钥吗　　259<br>11.5.4　生成元的意义　　259<br>11.5.5　具体实践一下　　260<br>11.6　基于口令的密码（PBE）　　262<br>11.6.1　什么是基于口令的密码　　262<br>11.6.2　PBE加密　　263<br>11.6.3　PBE解密　　264<br>11.6.4　盐的作用　　266<br>11.6.5　口令的作用　　266<br>11.6.6　PBE的改良　　267<br>11.7　如何生成安全的口令　　268<br>11.7.1　使用只有自己才能知道的信息　　268<br>11.7.2　将多个不同的口令分开使用　　269<br>11.7.3　有效利用笔记　　269<br>11.7.4　理解口令的局限性　　269<br>11.8　本章小结　　270<br>11.9　小测验的答案　　271<br>第12章　随机数——不可预测性的源泉　　273<br>12.1　骡子的锁匠铺　　274<br>12.2　本章学习的内容　　274<br>12.3　使用随机数的密码技术　　274<br>12.3.1　随机数是干什么用的　　274<br>12.4　随机数的性质　　275<br>12.4.1　对随机数的性质进行分类　　275<br>12.4.2　随机性　　276<br>12.4.3　不可预测性　　277<br>12.4.4　不可重现性　　277<br>12.5　伪随机数生成器　　278<br>12.5.1　伪随机数生成器的结构　　278<br>12.6　具体的伪随机数生成器　　280<br>12.6.1　杂乱的方法　　280<br>12.6.2　线性同余法　　280<br>12.6.3　单向散列函数法　　283<br>12.6.4　密码法　　286<br>12.6.5　ANSI　X9.17　　287<br>12.7　对伪随机数生成器的攻击　　290<br>12.7.1　对种子进行攻击　　290<br>12.7.2　对随机数池进行攻击　　290<br>12.8　本章小结　　290<br>12.9　小测验的答案　　291<br>第13章　PGP　——密码技术的完美组合　　293<br>13.1　本章学习的内容　　294<br>13.2　PGP简介　　294<br>13.2.1　什么是PGP　　294<br>13.2.2　PGP的功能　　295<br>13.3　生成密钥对　　297<br>13.4　加密与解密　　299<br>13.4.1　加密　　299<br>13.4.2　解密　　301<br>13.5　生成和验证数字签名　　304<br>13.5.1　生成数字签名　　304<br>13.5.2　验证数字签名　　306<br>13.6　生成数字签名并加密以及解密并验证数字签名　　　　309<br>13.6.1　生成数字签名并加密　　309<br>13.6.2　解密并验证数字签名　　309<br>13.7　信任网　　313<br>13.7.1　公钥合法性　　313<br>13.7.2　场景1：通过自己的数字签名进行确认　　313<br>13.7.3　场景2：通过自己完全信任的人的数字签名进行确认　　314<br>13.7.4　场景3：通过自己有限信任的多个人的数字签名进行确认　　315<br>13.7.5　公钥合法性与所有者信任是不同的　　316<br>13.7.6　所有者信任级别是因人而异的　　316<br>13.8　本章小结　　318<br>13.9　小测验的答案　　318<br>第14章　SSL/TLS　——为了更安全的通信　　321<br>14.1　本章学习的内容　　322<br>14.2　什么是SSL/TLS　　322<br>14.2.1　Alice在Bob书店买书　　322<br>14.2.2　客户端与服务器　　323<br>14.2.3　用SSL/TLS承载HTTP　　324<br>14.2.4　SSL/TLS的工作　　325<br>14.2.5　SSL/TLS也可以保护其他的协议　　326<br>14.2.6　密码套件　　326<br>14.2.7　SSL与TLS的区别　　327<br>14.3　使用SSL/TLS进行通信　　327<br>14.3.1　层次化的协议　　327<br>14.3.2　1　TLS记录协议　　329<br>14.3.3　2-1　握手协议　　330<br>14.3.4　2-2　密码规格变更协议　　336<br>14.3.5　2-3　警告协议　　337<br>14.3.6　2-4　应用数据协议　　337<br>14.3.7　主密码　　337<br>14.3.8　TLS中使用的密码技术小结　　338<br>14.4　对SSL/TLS的攻击　　339<br>14.4.1　对各个密码技术的攻击　　339<br>14.4.2　对伪随机数生成器的攻击　　339<br>14.4.3　利用证书的时间差进行攻击　　340<br>14.5　SSL/TLS用户的注意事项　　340<br>14.5.1　不要误解证书的含义　　340<br>14.5.2　密码通信之前的数据是不受保护的　　340<br>14.5.3　密码通信之后的数据是不受保护的　　340<br>14.6　本章小结　　341<br>14.7　小测验的答案　　342<br>第15章　密码技术与现实社会——我们生活在不完美的安全中　　.343<br>15.1　本章学习的内容　　344<br>15.2　密码技术小结　　344<br>15.2.1　密码学家的工具箱　　344<br>15.2.2　密码与认证　　346<br>15.2.3　密码技术的框架化　　346<br>15.2.4　密码技术与压缩技术　　346<br>15.3　追寻完美的密码技术　　348<br>15.3.1　量子密码　　349<br>15.3.2　量子计算机　　350<br>15.3.3　哪一种技术会率先进入实用领域　　350<br>15.4　只有完美的密码，没有完美的人　　350<br>15.4.1　理论是完美的，现实是残酷的　　351<br>15.4.2　防御必须天衣无缝，攻击只需突破一点　　351<br>15.4.3　攻击实例1：经过PGP加密的电子邮件　　352<br>15.4.4　攻击实例2：用SSL/TLS加密的信用卡号　　353<br>15.5　本章小结　　354<br>附录　密码技术综合测验　　355<br>参考文献　　365</p>
<h2 id="图解TCP-IP-第5版"><a href="#图解TCP-IP-第5版" class="headerlink" title="图解TCP/IP : 第5版"></a><a href="https://book.douban.com/subject/24737674/" target="_blank" rel="noopener">图解TCP/IP : 第5版</a></h2><p><img alt data-src="https://img1.doubanio.com/view/subject/l/public/s26676928.jpg"></p>
<h3 id="目录-1"><a href="#目录-1" class="headerlink" title="目录"></a>目录</h3><p>第1章 网络基础知识<br>1.1 　计算机网络出现的背景<br>1.1.1 　计算机的普及与多样化<br>1.1.2 　从独立模式到网络互连模式<br>1.1.3 　从计算机通信到信息通信<br>1.1.4 　计算机网络的作用<br>1.2　 计算机与网络发展的7个阶段<br>1.2.1 　批处理<br>1.2.2 　分时系统<br>1.2.3 　计算机之间的通信<br>1.2.4 　计算机网络的产生<br>1.2.5 　互联网的普及<br>1.2.6 　以互联网技术为中心的时代<br>1.2.7 　从“单纯建立连接”到“安全建立连接”<br>1.2.8 　手握金刚钻的tcp/ip<br>1.3 　协议<br>1.3.1　 随处可见的协议<br>1.3.2　 协议的必要性<br>1.3.3　 协议如同人与人的对话<br>1.3.4　 计算机中的协议<br>1.3.5　 分组交换协议<br>1.4 　协议由谁规定<br>1.4.1 　计算机通信的诞生及其标准化<br>1.4.2 　协议的标准化<br>1.5 　协议分层与osi参考模型<br>1.5.1 　协议的分层<br>1.5.2 　通过对话理解分层<br>1.5.3 　osi参考模型<br>1.5.4 　osi参考模型中各个分层的作用<br>1.6 　osi参考模型通信处理举例<br>1.6.1 　7层通信<br>1.6.2　 会话层以上的处理<br>1.6.3　 传输层以下的处理<br>1.7 　传输方式的分类<br>1.7.1 　面向有连接型与面向无连接型<br>1.7.2 　电路交换与分组交换<br>1.7.3 　根据接收端数量分类<br>1.8 　地址<br>1.8.1　 地址的唯一性<br>1.8.2　 地址的层次性<br>1.9 　网络的构成要素<br>1.9.1 　通信媒介与数据链路<br>1.9.2 　网卡<br>1.9.3 　中继器<br>1.9.4 　网桥/2层交换机<br>1.9.5 　路由器/3层交换机<br>1.9.6 　4~7层交换机<br>1.9.7 　网关<br>1.10 　现代网络实态<br>1.10.1 　网络的构成<br>1.10.2　 互联网通信<br>1.10.3　 移动通信<br>1.10.4　 从信息发布者的角度看网络<br>第2章 tcp/ip基础知识<br>2.1 　tcp/ip出现的背景及其历史<br>2.1.1 　从军用技术的应用谈起<br>2.1.2　 arpanet的诞生<br>2.1.3　 tcp/ip的诞生<br>2.1.4　 unix系统的普及与互联网的扩张<br>2.1.5　 商用互联网服务的启蒙<br>2.2 　tcp/ip的标准化<br>2.2.1 　tcp/ip的具体含义<br>2.2.2 　tcp/ip标准化精髓<br>2.2.3　 tcp/ip规范–rfc<br>2.2.4 　tcp/ip的标准化流程<br>2.2.5 　rfc的获取方法<br>2.3　 互联网基础知识<br>2.3.1 　互联网定义<br>2.3.2 　互联网与tcp/ip的关系<br>2.3.3 　互联网的结构<br>2.3.4 　isp和区域网<br>2.4 　tcp/ip协议分层模型<br>2.4.1　 tcp/ip与osi参考模型<br>2.4.2　 硬件（物理层）<br>2.4.3 　网络接口层（数据链路层）<br>2.4.4 　互联网层（网络层）<br>2.4.5　 传输层<br>2.4.6　 应用层（会话层以上的分层）<br>2.5 　tcp/ip分层模型与通信示例<br>2.5.1　 数据包首部<br>2.5.2　 发送数据包<br>2.5.3 　经过数据链路的包<br>2.5.4 　数据包接收处理<br>第3章 数据链路<br>3.1 　数据链路的作用<br>3.2 　数据链路相关技术<br>3.2.1 　mac地址<br>3.2.2　 共享介质型网络<br>3.2.3 　非共享介质网络<br>3.2.4　 根据mac地址转发<br>3.2.5　 环路检测技术<br>3.2.6　 vlan<br>3.3 　以太网<br>3.3.1 　以太网连接形式<br>3.3.2　 以太网的分类<br>3.3.3 　以太网的历史<br>3.3.4 　以太网帧格式<br>3.4 　无线通信<br>3.4.1　 无线通信的种类<br>3.4.2 　ieee802.11<br>3.4.3 　ieee802.11b和ieee802.11g<br>3.4.4 　ieee802.11a<br>3.4.5 　ieee802.11n<br>3.4.6 　使用无线lan时的注意事项<br>3.4.7　 蓝牙<br>3.4.8　 wimax<br>3.4.9 　zigbee<br>3.5 　ppp<br>3.5.1 　ppp定义<br>3.5.2 　lcp与ncp<br>3.5.3　 ppp的帧格式<br>3.5.4 　pppoe<br>3.6 　其他数据链路<br>3.6.1 　atm<br>3.6.2　 pos<br>3.6.3 　fddi<br>3.6.4 　token ring<br>3.6.5 　100vg-anylan<br>3.6.6 　光纤通道<br>3.6.7 　hippi<br>3.6.8　 ieee1394<br>3.6.9　 hdmi<br>3.6.10 　iscsi<br>3.6.11 　infiniband<br>3.6.12 　docsis<br>3.6.13 　高速plc<br>3.7 　公共网络<br>3.7.1 　模拟电话线路<br>3.7.2　 移动通信服务<br>3.7.3 　adsl<br>3.7.4 　ftth<br>3.7.5 　有线电视<br>3.7.6 　专线<br>3.7.7 　vpn<br>3.7.8 　公共无线lan<br>3.7.9 　其他公共无线通信服务<br>第4章 ip协议<br>4.1 　ip即网际协议<br>4.1.1 　ip相当于osi参考模型的第3层<br>4.1.2 　网络层与数据链路层的关系<br>4.2 　ip基础知识<br>4.2.1　 ip地址属于网络层地址<br>4.2.2 　路由控制<br>4.2.3 　数据链路的抽象化<br>4.2.4 　ip属于面向无连接型<br>4.3 　ip地址的基础知识<br>4.3.1 　ip地址的定义<br>4.3.2 　ip地址由网络和主机两部分标识组成<br>4.3.3　 ip地址的分类<br>4.3.4　 广播地址<br>4.3.5　 ip多播<br>4.3.6　 子网掩码<br>4.3.7　 cidr与vlsm<br>4.3.8　 全局地址与私有地址<br>4.3.9 　全局地址由谁决定<br>4.4 　路由控制<br>4.4.1　 ip地址与路由控制<br>4.4.2　 路由控制表的聚合<br>4.5 　ip分割处理与再构成处理<br>4.5.1 　数据链路不同，mtu则相异<br>4.5.2 　ip报文的分片与重组<br>4.5.3　 路径mtu发现<br>4.6 　ipv6<br>4.6.1　 ipv6的必要性<br>4.6.2　 ipv6的特点<br>4.6.3　 ipv6中ip地址的标记方法<br>4.6.4 　ipv6地址的结构<br>4.6.5　 全局单播地址<br>4.6.6　 链路本地单播地址<br>4.6.7　 唯一本地地址<br>4.6.8 　ipv6分段处理<br>4.7 　ipv4首部<br>4.8 　ipv6首部格式<br>第5章 ip协议相关技术<br>5.1 　仅凭ip无法完成通信<br>5.2 　dns<br>5.2.1　 ip地址不便记忆<br>5.2.2　 dns的产生<br>5.2.3　 域名的构成<br>5.2.4　 dns查询<br>5.2.5　 dns如同互联网中的分布式数据库<br>5.3 　arp<br>5.3.1　 arp概要<br>5.3.2　 arp的工作机制<br>5.3.3　 ip地址和mac地址缺一不可？<br>5.3.4 　rarp<br>5.3.5　 代理arp<br>5.4 　icmp<br>5.4.1 　辅助ip的icmp<br>5.4.2 　主要的icmp消息<br>5.4.3 　其他icmp消息<br>5.4.4 　icmpv6<br>5.5　 dhcp<br>5.5.1　 dhcp实现即插即用<br>5.5.2　 dhcp的工作机制<br>5.5.3　 dhcp中继代理<br>5.6　 nat<br>5.6.1　 nat定义<br>5.6.2　 nat的工作机制<br>5.6.3　 nat-pt（napt-pt）<br>5.6.4　 nat的潜在问题<br>5.6.5　 解决nat的潜在问题与nat穿越<br>5.7 　ip隧道<br>5.8 　其他ip相关技术<br>5.8.1 　ip多播相关技术<br>5.8.2 　ip任播<br>5.8.3 　通信质量控制<br>5.8.4 　显式拥塞通知<br>5.8.5 　mobile ip<br>第6章 tcp与udp<br>6.1 　传输层的作用<br>6.1.1　 传输层定义<br>6.1.2　 通信处理<br>6.1.3　 两种传输层协议tcp和udp<br>6.1.4　 tcp与udp区分<br>6.2　 端口号<br>6.2.1　 端口号定义<br>6.2.2　 根据端口号识别应用<br>6.2.3 　通过ip地址、端口号、协议号进行通信识别<br>6.2.4 　端口号如何确定<br>6.2.5 　端口号与协议<br>6.3　 udp<br>6.4　 tcp<br>6.4.1 　tcp的特点及其目的<br>6.4.2 　通过序列号与确认应答提高可靠性<br>6.4.3　 重发超时如何确定<br>6.4.4 　连接管理<br>6.4.5 　tcp以段为单位发送数据<br>6.4.6 　利用窗口控制提高速度<br>6.4.7 　窗口控制与重发控制<br>6.4.8　 流控制<br>6.4.9　 拥塞控制<br>6.4.10　 提高网络利用率的规范<br>6.4.11　 使用tcp的应用<br>6.5　 其他传输层协议<br>6.5.1　 udp-lite<br>6.5.2　 sctp<br>6.5.3 　dccp<br>6.6　 udp首部的格式<br>6.7　 tcp首部格式<br>第7章 路由协议<br>7.1　 路由控制的定义<br>7.1.1　 ip地址与路由控制<br>7.1.2 　静态路由与动态路由<br>7.1.3　 动态路由的基础<br>7.2 　路由控制范围<br>7.2.1 　接入互联网的各种组织机构<br>7.2.2 　自治系统与路由协议<br>7.2.3 　igp与egp<br>7.3 　路由算法<br>7.3.1　 距离向量算法<br>7.3.2　 链路状态算法<br>7.3.3　 主要路由协议<br>7.4　 rip<br>7.4.1 　广播路由控制信息<br>7.4.2 　根据距离向量确定路由<br>7.4.3 　使用子网掩码时的rip处理<br>7.4.4 　rip中路由变更时的处理<br>7.4.5 　rip2<br>7.5　 ospf<br>7.5.1　 ospf是链路状态型路由协议<br>7.5.2　 ospf基础知识<br>7.5.3　 ospf工作原理概述<br>7.5.4　 将区域分层化进行细分管理<br>7.6　 bgp<br>7.6.1　 bgp与as号<br>7.6.2　 bgp是路径向量协议<br>7.7 　mpls<br>7.7.1　 mpls的网络基本动作<br>7.7.2　 mpls的优点<br>第8章 应用协议<br>8.1 　应用层协议概要<br>8.2 　远程登录<br>8.2.1 　telnet<br>8.2.2 　ssh<br>8.3 　文件传输<br>8.4 　电子邮件<br>8.4.1 　电子邮件的工作机制<br>8.4.2 　邮件地址<br>8.4.3 　mime<br>8.4.4 　smtp<br>8.4.5 　pop<br>8.4.6 　imap<br>8.5 　www<br>8.5.1 　互联网的蓬勃发展<br>8.5.2　 www基本概念<br>8.5.3 　uri<br>8.5.4 　html<br>8.5.5　 http<br>8.5.6 　javascript、cgi、cookie<br>8.6 　网络管理<br>8.6.1　 snmp<br>8.6.2　 mib<br>8.6.3　 rmon<br>8.6.4　 snmp应用举例<br>8.7 　其他应用层协议<br>8.7.1 　多媒体通信实现技术<br>8.7.2 　p2p<br>8.7.3　 ldap<br>第9章 网络安全<br>9.1　 tcp/ip与网络安全<br>9.2　 网络安全构成要素<br>9.2.1　 防火墙<br>9.2.2 　ids（入侵检测系统）<br>9.2.3 　反病毒/个人防火墙<br>9.3 　加密技术基础<br>9.3.1　 对称密码体制与公钥密码体制<br>9.3.2　 身份认证技术<br>9.4 　安全协议<br>9.4.1 　ipsec与vpn<br>9.4.2 　tls/ssl与https<br>9.4.3 　ieee802.1x<br>附录<br>附1　 互联网上便捷的资源<br>附1.1 　国际<br>附1.2 　日本<br>附2 　ip地址分类（a、b、c类）相关基础知识<br>附2.1　 a类<br>附2.2　 b类<br>附2.3 　c类<br>附3 　物理层<br>附3.1 　物理层相关基础知识<br>附3.2 　0/1编码<br>附4 　传输介质相关基础知识<br>附4.1 　同轴电缆<br>附4.2 　双绞线<br>附4.3 　光纤电缆<br>附4.4 　无线<br>附5 　插页导图</p>
<h3 id="《图解TCP-IP》笔记"><a href="#《图解TCP-IP》笔记" class="headerlink" title="《图解TCP/IP》笔记"></a><a href="https://book.douban.com/review/9354411/" target="_blank" rel="noopener">《图解TCP/IP》笔记</a></h3><p>1、物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<p>网络层：ARP IPV4 IPV6 ICMP IPSEC</p>
<p>传输层：TCP UDP UDP-LITE SCTP DCCP</p>
<p>应用层：TELNET SSH HTTP SMTP POP SSL/TLS FTP MIME HTML SNMP MIB SIP RTP</p>
<p>2、WAN 广域网 LAN 局域网</p>
<p>3、单播、广播、组播</p>
<p><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491007.jpg"></p>
<p>4、</p>
<p><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491008.jpg"></p>
<p>5、电缆</p>
<p><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491009.jpg"></p>
<p>6、中继器</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491010.jpg"></p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491012.jpg"></p>
<p>7、网桥</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491011.jpg"></p>
<p>8、网络的整体组成</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491014.jpg"></p>
<p>9、数据链路层：以太网、无限局域网、PPP</p>
<p>FDDI：光纤分布式数据接口</p>
<p>ATM：异步传输方式</p>
<p>10、网络拓扑</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491013.jpg"></p>
<p>11、MAC地址：48位，IEEE码、厂商识别码、</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491016.jpg"></p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491015.jpg"></p>
<p>12、共享介质型的访问控制方式：争用方式、令牌传递方式</p>
<p>争用方式：CSMA/CD</p>
<p><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491017.jpg"></p>
<p>13、令牌传递方式</p>
<p><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491018.jpg"></p>
<p>14、半双工和全双工：</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491020.jpg"></p>
<p>15、以太网光纤</p>
<p><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491019.jpg"></p>
<p>16、无线网络</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491021.jpg"></p>
<p>17、PPP协议</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491022.jpg"></p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491024.jpg"></p>
<p>18、ATM发送5字节首部+48字节内容</p>
<p>19、数据链路名称、介质</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491023.jpg"></p>
<p>20、猫</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491025.jpg"></p>
<p>21、ADSL</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491026.jpg"></p>
<p>22、高速光纤</p>
<p><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491027.jpg"></p>
<p>23、VPN</p>
<p><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491028.jpg"></p>
<p>24、网络层协议：DNS、ARP、ICMP</p>
<p>25、MTU分片处理</p>
<p><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491029.jpg"></p>
<p>26、IP表示法</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491030.jpg"></p>
<p>27、IP地址得网络标识、主机标识</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491031.jpg"></p>
<p>28、</p>
<p>A类地址：0.0.0.0~127.0.0.0</p>
<p>B类地址：128.0.0.1~191.255.0.0</p>
<p>C类地址：192.168.0.0~223.255.255.255.0</p>
<p>D类地址：224.0.0.0~239.255.255.255</p>
<p>减去全0，减去全1广播</p>
<p>29、广播地址</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491032.jpg"></p>
<p>30、单播、广播、多播</p>
<p>31、多播地址</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491034.jpg"></p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491033.jpg"></p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491035.jpg"></p>
<p>32、子网掩码</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491036.jpg"></p>
<p>24、CIDR</p>
<p><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491038.jpg"></p>
<p>25、VLSM</p>
<p><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491037.jpg"></p>
<p>26、whois查询IP是谁的</p>
<p>27、环回地址</p>
<p><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491039.jpg"></p>
<p>28、MTU：最大传输单元。分组</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491040.jpg"></p>
<p>29、IPV6：128位、8个16</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491041.jpg"></p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491042.jpg"></p>
<p>30、IP地址首部</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491044.jpg"></p>
<p>31、域名结构</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491043.jpg"></p>
<p>32、DNS记录</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491045.jpg"></p>
<p>33、ARP</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491046.jpg"></p>
<p><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491047.jpg"></p>
<p>33、RARP</p>
<p><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491048.jpg"></p>
<p><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491049.jpg"></p>
<p>34、DHCP中继代理</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491050.jpg"></p>
<p>35、NAT：NAPT 地址伪装</p>
<p>36、NAT-PT：IPV6转IPV4</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491051.jpg"></p>
<p>37、IP任播</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491052.jpg"></p>
<p>38、多播和广播一般用UDP</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491055.jpg"></p>
<p>39、TCP三次握手：SYN X ,ACK X+1,SYN Y，ACK Y+1</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491056.jpg"></p>
<p>40、滑动窗口控制</p>
<p><img alt data-src="https://img1.doubanio.com/view/thing_review/l/public/p1491059.jpg"></p>
<p>41、传输五大要素</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491060.jpg"></p>
<p>42、RIP：路由信息协议</p>
<p>路由信息协议RIP（Routing Information Protocol）是基于距离矢量算法的路由协议，利用跳数来作为计量标准。在带宽、配置和管理方面要求较低，主要适合于规模较小的网络中。</p>
<p>RIP协议是一种内部网关协议（IGP），是一种动态路由选择协议，用于自治系统（AS）内的路由信息的传递。RIP协议基于距离矢量算法（DistanceVectorAlgorithms），使用“跳数”(即metric)来衡量到达目标地址的路由距离。这种协议的路由器只关心自己周围的世界，只与自己相邻的路由器交换信息，范围限制在15跳(15度)之内，再远，它就不关心了。RIP应用于OSI网络七层模型的网络层。各厂家定义的管理距离（AD，即优先级）如下：华为定义的优先级是100，思科定义的优先级是120。</p>
<p>43、OSPF</p>
<p>OSPF(Open Shortest Path First开放式最短路径优先）是一个内部网关协议(Interior Gateway Protocol，简称IGP），用于在单一自治系统（autonomous system,AS）内决策路由。是对链路状态路由协议的一种实现，隶属内部网关协议（IGP），故运作于自治系统内部。著名的迪克斯加算法(Dijkstra)被用来计算最短路径树。OSPF分为OSPFv2和OSPFv3两个版本,其中OSPFv2用在IPv4网络，OSPFv3用在IPv6网络。OSPFv2是由RFC 2328定义的，OSPFv3是由RFC 5340定义的。与RIP相比，OSPF是链路状态协议，而RIP是距离矢量协议。</p>
<p><img alt data-src="https://img3.doubanio.com/view/thing_review/l/public/p1491061.jpg"></p>
</html></form></blockquote></table></p></footer></aside></section></header></head></strong></li></ul></ul></ul></div>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Web/" rel="tag"><i class="fa fa-tag"></i> Web</a>
              <a href="/tags/Net/" rel="tag"><i class="fa fa-tag"></i> Net</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/Business/DeepCreator/Business/Technology/" rel="next" title="Technology">
                  <i class="fa fa-chevron-left"></i> Technology
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/IPR/DeepCreator/IPR/WIPO/" rel="prev" title="WIPO">
                  WIPO <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTML基础自学作业"><span class="nav-number">1.</span> <span class="nav-text">HTML基础自学作业</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">2.</span> <span class="nav-text">视频格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML-参考手册"><span class="nav-number">2.1.</span> <span class="nav-text">HTML 参考手册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS-教程"><span class="nav-number">2.2.</span> <span class="nav-text">CSS 教程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WEB设计的速查卡"><span class="nav-number">2.3.</span> <span class="nav-text">WEB设计的速查卡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反击爬虫，前端工程师的脑洞可以有多大？"><span class="nav-number">2.4.</span> <span class="nav-text">反击爬虫，前端工程师的脑洞可以有多大？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#再议减少HTTP请求"><span class="nav-number">2.5.</span> <span class="nav-text">再议减少HTTP请求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jQuery"><span class="nav-number">3.</span> <span class="nav-text">jQuery</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jQuery参考资料"><span class="nav-number">4.</span> <span class="nav-text">jQuery参考资料</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jQuery-教程"><span class="nav-number">4.1.</span> <span class="nav-text">jQuery 教程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jQuery-实例"><span class="nav-number">4.2.</span> <span class="nav-text">jQuery 实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jQuery-参考手册"><span class="nav-number">4.3.</span> <span class="nav-text">jQuery 参考手册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十分钟玩转-jQuery、实例大全"><span class="nav-number">4.4.</span> <span class="nav-text">十分钟玩转 jQuery、实例大全</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Markdown"><span class="nav-number">5.</span> <span class="nav-text">Markdown</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Markdown参考资料"><span class="nav-number">6.</span> <span class="nav-text">Markdown参考资料</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mark-Text-下一代所见即所得的Markdown编辑器"><span class="nav-number">6.1.</span> <span class="nav-text">Mark Text - 下一代所见即所得的Markdown编辑器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Markdown-语法说明-简体中文版"><span class="nav-number">6.2.</span> <span class="nav-text">Markdown 语法说明 (简体中文版)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hexo不渲染-md或者-html"><span class="nav-number">7.</span> <span class="nav-text">Hexo不渲染.md或者.html</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在主目录下添加README-md文件或者html文件"><span class="nav-number">8.</span> <span class="nav-text">在主目录下添加README.md文件或者html文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chrome"><span class="nav-number">9.</span> <span class="nav-text">Chrome</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Web前端性能优化——如何提高页面加载速度"><span class="nav-number">10.</span> <span class="nav-text">Web前端性能优化——如何提高页面加载速度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器野史-UserAgent列传（上）"><span class="nav-number">11.</span> <span class="nav-text">浏览器野史 UserAgent列传（上）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器野史-UserAgent列传（下）"><span class="nav-number">12.</span> <span class="nav-text">浏览器野史 UserAgent列传（下）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#兔子，胡萝卜与OAuth的故事"><span class="nav-number">13.</span> <span class="nav-text">兔子，胡萝卜与OAuth的故事</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈OAuth1-OAuth2异同"><span class="nav-number">14.</span> <span class="nav-text">谈谈OAuth1,OAuth2异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图解密码技术"><span class="nav-number">15.</span> <span class="nav-text">图解密码技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内容简介"><span class="nav-number">15.1.</span> <span class="nav-text">内容简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目录"><span class="nav-number">15.2.</span> <span class="nav-text">目录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图解TCP-IP-第5版"><span class="nav-number">16.</span> <span class="nav-text">图解TCP/IP : 第5版</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目录-1"><span class="nav-number">16.1.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#《图解TCP-IP》笔记"><span class="nav-number">16.2.</span> <span class="nav-text">《图解TCP/IP》笔记</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="IPCreator"
    src="/img/logo.jpg">
  <p class="site-author-name" itemprop="name">IPCreator</p>
  <div class="site-description" itemprop="description">Life is a journey.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">1505</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1441</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://blog.163.com/zhuxuanlv@126/" title="http://blog.163.com/zhuxuanlv@126/" rel="noopener" target="_blank">163 Blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">IPCreator</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">26.6m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">402:58</span>
</div>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.5.0
  </div>


<!-- 在网页底部添加网站运行时间 -->
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/24/2019 00:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = " "+dnum+" D ";
        document.getElementById("times").innerHTML = hnum + " H " + mnum + " M " + snum + " S";
    }
setInterval("createtime()",250);
</script>
        
<div class="busuanzi-count">
  <script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  



  <script pjax>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id: 11184,
      el: 'wpac-rating',
      color: 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  <script src="/js/local-search.js"></script>












    <div id="pjax">

  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'C75jI23HEPhTehiFhCvUSbJY-gzGzoHsz',
    appKey: 'qy3Id9srq8HBxwKg3CVSdNNq',
    placeholder: "Just go go",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

    </div>

</body>
</html>
